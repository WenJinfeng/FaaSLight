{
	"node_modules/base64-js/base64js.min----d": "function d(a) {\n    var b = a.length;\n    if (0 < b % 4) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var c = a.indexOf(\"=\");\n    -1 === c && (c = b);\n    var d = c === b ? 0 : 4 - c % 4;\n    return [ c, d ];\n}",
	"node_modules/base64-js/index----getLens": "function getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [ validLen, placeHoldersLen ];\n}",
	"node_modules/base64-js/index----byteLength": "function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}",
	"node_modules/base64-js/index----toByteArray": "function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    return arr;\n}",
	"node_modules/base64-js/index----encodeChunk": "function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}",
	"node_modules/base64-js/index----fromByteArray": "function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n    return parts.join(\"\");\n}",
	"node_modules/bl/bl----BufferListStream": "function BufferListStream(callback) {\n    if (!(this instanceof BufferListStream)) {\n        return new BufferListStream(callback);\n    }\n    if (typeof callback === \"function\") {\n        this._callback = callback;\n        const piper = function piper(err) {\n            if (this._callback) {\n                this._callback(err);\n                this._callback = null;\n            }\n        }.bind(this);\n        this.on(\"pipe\", function onPipe(src) {\n            src.on(\"error\", piper);\n        });\n        this.on(\"unpipe\", function onUnpipe(src) {\n            src.removeListener(\"error\", piper);\n        });\n        callback = null;\n    }\n    BufferList._init.call(this, callback);\n    DuplexStream.call(this);\n}",
	"node_modules/buffer/index----createBuffer": "function createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    }\n    var buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n}",
	"node_modules/buffer/index----from": "function from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n    }\n    if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n    }\n    if (value == null) {\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n    }\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof value === \"number\") {\n        throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    }\n    var valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) {\n        return Buffer.from(valueOf, encodingOrOffset, length);\n    }\n    var b = fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof value);\n}",
	"node_modules/buffer/index----alloc": "function alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(size);\n    }\n    if (fill !== undefined) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n    return createBuffer(size);\n}",
	"node_modules/buffer/index----fromString": "function fromString(string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n    var length = byteLength(string, encoding) | 0;\n    var buf = createBuffer(length);\n    var actual = buf.write(string, encoding);\n    if (actual !== length) {\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}",
	"node_modules/buffer/index----fromArrayLike": "function fromArrayLike(array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(length);\n    for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}",
	"node_modules/buffer/index----fromArrayBuffer": "function fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    var buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    } else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    } else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n}",
	"node_modules/buffer/index----byteLength": "function byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof string);\n    }\n    var len = string.length;\n    var mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n\n          case \"hex\":\n            return len >>> 1;\n\n          case \"base64\":\n            return base64ToBytes(string).length;\n\n          default:\n            if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/buffer/index----slowToString": "function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n\n          case \"base64\":\n            return base64Slice(this, start, end);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/buffer/index----bidirectionalIndexOf": "function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    if (buffer.length === 0) return -1;\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1; else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0; else return -1;\n    }\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/buffer/index----arrayIndexOf": "function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}",
	"node_modules/buffer/index----hexWrite": "function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    var strLen = string.length;\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}",
	"node_modules/buffer/index----utf8Slice": "function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                    codePoint = firstByte;\n                }\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n            }\n        }\n        if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}",
	"node_modules/buffer/index----decodeCodePointsArray": "function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}",
	"node_modules/buffer/index----asciiSlice": "function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n}",
	"node_modules/buffer/index----latin1Slice": "function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}",
	"node_modules/buffer/index----hexSlice": "function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n}",
	"node_modules/buffer/index----utf16leSlice": "function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}",
	"node_modules/buffer/index----writeFloat": "function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}",
	"node_modules/buffer/index----writeDouble": "function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}",
	"node_modules/buffer/index----base64clean": "function base64clean(str) {\n    str = str.split(\"=\")[0];\n    str = str.trim().replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2) return \"\";\n    while (str.length % 4 !== 0) {\n        str = str + \"=\";\n    }\n    return str;\n}",
	"node_modules/buffer/index----utf8ToBytes": "function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n                if (codePoint > 56319) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                } else if (i + 1 === length) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                }\n                leadSurrogate = codePoint;\n                continue;\n            }\n            if (codePoint < 56320) {\n                if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}",
	"node_modules/buffer/index----utf16leToBytes": "function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}",
	"node_modules/color/index----Color": "function Color(object, model) {\n    if (!(this instanceof Color)) {\n        return new Color(object, model);\n    }\n    if (model && model in skippedModels) {\n        model = null;\n    }\n    if (model && !(model in convert)) {\n        throw new Error(\"Unknown model: \" + model);\n    }\n    let i;\n    let channels;\n    if (object == null) {\n        this.model = \"rgb\";\n        this.color = [ 0, 0, 0 ];\n        this.valpha = 1;\n    } else if (object instanceof Color) {\n        this.model = object.model;\n        this.color = [ ...object.color ];\n        this.valpha = object.valpha;\n    } else if (typeof object === \"string\") {\n        const result = colorString.get(object);\n        if (result === null) {\n            throw new Error(\"Unable to parse color from string: \" + object);\n        }\n        this.model = result.model;\n        channels = convert[this.model].channels;\n        this.color = result.value.slice(0, channels);\n        this.valpha = typeof result.value[channels] === \"number\" ? result.value[channels] : 1;\n    } else if (object.length > 0) {\n        this.model = model || \"rgb\";\n        channels = convert[this.model].channels;\n        const newArray = Array.prototype.slice.call(object, 0, channels);\n        this.color = zeroArray(newArray, channels);\n        this.valpha = typeof object[channels] === \"number\" ? object[channels] : 1;\n    } else if (typeof object === \"number\") {\n        this.model = \"rgb\";\n        this.color = [ object >> 16 & 255, object >> 8 & 255, object & 255 ];\n        this.valpha = 1;\n    } else {\n        this.valpha = 1;\n        const keys = Object.keys(object);\n        if (\"alpha\" in object) {\n            keys.splice(keys.indexOf(\"alpha\"), 1);\n            this.valpha = typeof object.alpha === \"number\" ? object.alpha : 0;\n        }\n        const hashedKeys = keys.sort().join(\"\");\n        if (!(hashedKeys in hashedModelKeys)) {\n            throw new Error(\"Unable to parse color from object: \" + JSON.stringify(object));\n        }\n        this.model = hashedModelKeys[hashedKeys];\n        const {\n            labels\n        } = convert[this.model];\n        const color = [];\n        for (i = 0; i < labels.length; i++) {\n            color.push(object[labels[i]]);\n        }\n        this.color = zeroArray(color);\n    }\n    if (limiters[this.model]) {\n        channels = convert[this.model].channels;\n        for (i = 0; i < channels; i++) {\n            const limit = limiters[this.model][i];\n            if (limit) {\n                this.color[i] = limit(this.color[i]);\n            }\n        }\n    }\n    this.valpha = Math.max(0, Math.min(1, this.valpha));\n    if (Object.freeze) {\n        Object.freeze(this);\n    }\n}",
	"node_modules/eventemitter3/index----addListener": "function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++; else if (!emitter._events[evt].fn) emitter._events[evt].push(listener); else emitter._events[evt] = [ emitter._events[evt], listener ];\n    return emitter;\n}",
	"node_modules/hang/index----bro": "function bro() {\n    var self = this;\n    if (+new Date() > start) {\n        return fn.apply(self, arguments);\n    }\n    for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n        args[i] = arguments[i];\n    }\n    (global.setImmediate || global.setTimeout)(function delay() {\n        fn.apply(self, args);\n        self = args = null;\n    }, 0);\n}",
	"node_modules/ini/ini----encode": "function encode(obj, opt) {\n    var children = [];\n    var out = \"\";\n    if (typeof opt === \"string\") {\n        opt = {\n            section: opt,\n            whitespace: false\n        };\n    } else {\n        opt = opt || {};\n        opt.whitespace = opt.whitespace === true;\n    }\n    var separator = opt.whitespace ? \" = \" : \"=\";\n    Object.keys(obj).forEach(function(k, _, __) {\n        var val = obj[k];\n        if (val && Array.isArray(val)) {\n            val.forEach(function(item) {\n                out += safe(k + \"[]\") + separator + safe(item) + \"\\n\";\n            });\n        } else if (val && typeof val === \"object\") children.push(k); else out += safe(k) + separator + safe(val) + eol;\n    });\n    if (opt.section && out.length) out = \"[\" + safe(opt.section) + \"]\" + eol + out;\n    children.forEach(function(k, _, __) {\n        var nk = dotSplit(k).join(\"\\\\.\");\n        var section = (opt.section ? opt.section + \".\" : \"\") + nk;\n        var child = encode(obj[k], {\n            section: section,\n            whitespace: opt.whitespace\n        });\n        if (out.length && child.length) out += eol;\n        out += child;\n    });\n    return out;\n}",
	"node_modules/ini/ini----decode": "function decode(str) {\n    var out = {};\n    var p = out;\n    var section = null;\n    var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i;\n    var lines = str.split(/[\\r\\n]+/g);\n    lines.forEach(function(line, _, __) {\n        if (!line || line.match(/^\\s*[;#]/)) return;\n        var match = line.match(re);\n        if (!match) return;\n        if (match[1] !== undefined) {\n            section = unsafe(match[1]);\n            if (section === \"__proto__\") {\n                p = {};\n                return;\n            }\n            p = out[section] = out[section] || {};\n            return;\n        }\n        var key = unsafe(match[2]);\n        if (key === \"__proto__\") return;\n        var value = match[3] ? unsafe(match[4]) : true;\n        switch (value) {\n          case \"true\":\n          case \"false\":\n          case \"null\":\n            value = JSON.parse(value);\n        }\n        if (key.length > 2 && key.slice(-2) === \"[]\") {\n            key = key.substring(0, key.length - 2);\n            if (key === \"__proto__\") return;\n            if (!p[key]) p[key] = []; else if (!Array.isArray(p[key])) p[key] = [ p[key] ];\n        }\n        if (Array.isArray(p[key])) p[key].push(value); else p[key] = value;\n    });\n    Object.keys(out).filter(function(k, _, __) {\n        if (!out[k] || typeof out[k] !== \"object\" || Array.isArray(out[k])) return false;\n        var parts = dotSplit(k);\n        var p = out;\n        var l = parts.pop();\n        var nl = l.replace(/\\\\\\./g, \".\");\n        parts.forEach(function(part, _, __) {\n            if (part === \"__proto__\") return;\n            if (!p[part] || typeof p[part] !== \"object\") p[part] = {};\n            p = p[part];\n        });\n        if (p === out && nl === l) return false;\n        p[nl] = out[k];\n        return true;\n    }).forEach(function(del, _, __) {\n        delete out[del];\n    });\n    return out;\n}",
	"node_modules/jmespath/jmespath----strictDeepEqual": "function strictDeepEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n        return false;\n    }\n    if (isArray(first) === true) {\n        if (first.length !== second.length) {\n            return false;\n        }\n        for (var i = 0; i < first.length; i++) {\n            if (strictDeepEqual(first[i], second[i]) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (isObject(first) === true) {\n        var keysSeen = {};\n        for (var key in first) {\n            if (hasOwnProperty.call(first, key)) {\n                if (strictDeepEqual(first[key], second[key]) === false) {\n                    return false;\n                }\n                keysSeen[key] = true;\n            }\n        }\n        for (var key2 in second) {\n            if (hasOwnProperty.call(second, key2)) {\n                if (keysSeen[key2] !== true) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}",
	"node_modules/jmespath/jmespath----objValues": "function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n    }\n    return values;\n}",
	"node_modules/jmespath/jmespath----merge": "function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n        merged[key] = a[key];\n    }\n    for (var key2 in b) {\n        merged[key2] = b[key2];\n    }\n    return merged;\n}",
	"node_modules/jmespath/jmespath----search": "function search(data, expression) {\n    var parser = new Parser();\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n}",
	"node_modules/loads/index----loads": "function loads(xhr, ee) {\n    var onreadystatechange, onprogress, ontimeout, onabort, onerror, onload, timer;\n    onerror = xhr.onerror = one(function onerror(evt) {\n        var status = statuscode(xhr), err = fail(new Error(\"Network request failed\"), status);\n        ee.emit(\"error\", err);\n        ee.emit(\"end\", err, status);\n    });\n    onabort = xhr.onabort = function onabort(evt) {\n        onerror(evt);\n    };\n    onreadystatechange = xhr.onreadystatechange = function change(evt) {\n        var target = evt.target;\n        if (4 === target.readyState) return onload(evt);\n    };\n    ontimeout = xhr.ontimeout = one(function timeout(evt) {\n        ee.emit(\"timeout\", evt);\n        if (xhr.abort) xhr.abort();\n        onerror(evt);\n    });\n    if (xhr.timeout) timer = setTimeout(ontimeout, +xhr.timeout);\n    onprogress = xhr.onprogress = function progress(evt) {\n        var status = statuscode(xhr), data;\n        ee.emit(\"progress\", evt, status);\n        if (xhr.readyState >= 3 && status.code === 200 && (data = response(xhr))) {\n            ee.emit(\"stream\", data, status);\n        }\n    };\n    onload = xhr.onload = one(function load(evt) {\n        var status = statuscode(xhr), data = response(xhr);\n        if (status.code < 100 || status.code > 599) return onerror(evt);\n        if (data && status.code !== 204) {\n            ee.emit(\"stream\", data, status);\n        }\n        ee.emit(\"end\", undefined, status);\n    });\n    ee.once(\"end\", function cleanup() {\n        xhr.onreadystatechange = onreadystatechange = xhr.onprogress = onprogress = xhr.ontimeout = ontimeout = xhr.onerror = onerror = xhr.onabort = onabort = xhr.onload = onload = nope;\n        if (timer) clearTimeout(timer);\n    });\n    return xhr;\n}",
	"node_modules/minimist/index----setArg": "function setArg(key, val, arg) {\n    if (arg && flags.unknownFn && !argDefined(key, arg)) {\n        if (flags.unknownFn(arg) === false) return;\n    }\n    var value = !flags.strings[key] && isNumber(val) ? Number(val) : val;\n    setKey(argv, key.split(\".\"), value);\n    (aliases[key] || []).forEach(function(x) {\n        setKey(argv, x.split(\".\"), value);\n    });\n}",
	"node_modules/minimist/index----setKey": "function setKey(obj, keys, value) {\n    var o = obj;\n    for (var i = 0; i < keys.length - 1; i++) {\n        var key = keys[i];\n        if (isConstructorOrProto(o, key)) return;\n        if (o[key] === undefined) o[key] = {};\n        if (o[key] === Object.prototype || o[key] === Number.prototype || o[key] === String.prototype) o[key] = {};\n        if (o[key] === Array.prototype) o[key] = [];\n        o = o[key];\n    }\n    var key = keys[keys.length - 1];\n    if (isConstructorOrProto(o, key)) return;\n    if (o === Object.prototype || o === Number.prototype || o === String.prototype) o = {};\n    if (o === Array.prototype) o = [];\n    if (o[key] === undefined || flags.bools[key] || typeof o[key] === \"boolean\") {\n        o[key] = value;\n    } else if (Array.isArray(o[key])) {\n        o[key].push(value);\n    } else {\n        o[key] = [ o[key], value ];\n    }\n}",
	"node_modules/minimist/index----hasKey": "function hasKey(obj, keys) {\n    var o = obj;\n    keys.slice(0, -1).forEach(function(key) {\n        o = o[key] || {};\n    });\n    var key = keys[keys.length - 1];\n    return key in o;\n}",
	"node_modules/mkdirp-classic/index----mkdirP": "function mkdirP(p, opts, f, made) {\n    if (typeof opts === \"function\") {\n        f = opts;\n        opts = {};\n    } else if (!opts || typeof opts !== \"object\") {\n        opts = {\n            mode: opts\n        };\n    }\n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    if (mode === undefined) {\n        mode = _0777 & ~process.umask();\n    }\n    if (!made) made = null;\n    var cb = f || function() {};\n    p = path.resolve(p);\n    xfs.mkdir(p, mode, function(er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n          case \"ENOENT\":\n            mkdirP(path.dirname(p), opts, function(er, made) {\n                if (er) cb(er, made); else mkdirP(p, opts, cb, made);\n            });\n            break;\n\n          default:\n            xfs.stat(p, function(er2, stat) {\n                if (er2 || !stat.isDirectory()) cb(er, made); else cb(null, made);\n            });\n            break;\n        }\n    });\n}",
	"node_modules/node-abi/index----getNextTarget": "function getNextTarget(runtime, targets) {\n    if (targets == null) targets = allTargets;\n    var latest = targets.filter(function(t) {\n        return t.runtime === runtime;\n    }).slice(-1)[0];\n    var increment = runtime === \"electron\" ? \"minor\" : \"major\";\n    var next = semver.inc(latest.target, increment);\n    if (runtime === \"electron\" && semver.parse(latest.target).prerelease.length) {\n        next = semver.inc(next, \"major\");\n    }\n    return next;\n}",
	"node_modules/node-abi/index----getAbi": "function getAbi(target, runtime) {\n    if (target === String(Number(target))) return target;\n    if (target) target = target.replace(/^v/, \"\");\n    if (!runtime) runtime = \"node\";\n    if (runtime === \"node\") {\n        if (!target) return process.versions.modules;\n        if (target === process.versions.node) return process.versions.modules;\n    }\n    var abi;\n    var lastTarget;\n    for (var i = 0; i < allTargets.length; i++) {\n        var t = allTargets[i];\n        if (t.runtime !== runtime) continue;\n        if (semver.lte(t.target, target) && (!lastTarget || semver.gte(t.target, lastTarget))) {\n            abi = t.abi;\n            lastTarget = t.target;\n        }\n    }\n    if (abi && semver.lt(target, getNextTarget(runtime))) return abi;\n    throw new Error(\"Could not detect abi for version \" + target + \" and runtime \" + runtime + '.  Updating \"node-abi\" might help solve this issue if it is a new release of ' + runtime);\n}",
	"node_modules/node-abi/index----getTarget": "function getTarget(abi, runtime) {\n    if (abi && abi !== String(Number(abi))) return abi;\n    if (!runtime) runtime = \"node\";\n    if (runtime === \"node\" && !abi) return process.versions.node;\n    var match = allTargets.filter(function(t) {\n        return t.abi === abi && t.runtime === runtime;\n    }).map(function(t) {\n        return t.target;\n    });\n    if (match.length) {\n        var betaSeparatorIndex = match[0].indexOf(\"-\");\n        return betaSeparatorIndex > -1 ? match[0].substring(0, betaSeparatorIndex) : match[0];\n    }\n    throw new Error(\"Could not detect target for abi \" + abi + \" and runtime \" + runtime);\n}",
	"node_modules/node-abi/index----sortByTargetFn": "function sortByTargetFn(a, b) {\n    var abiComp = Number(a.abi) - Number(b.abi);\n    if (abiComp !== 0) return abiComp;\n    if (a.target < b.target) return -1;\n    if (a.target > b.target) return 1;\n    return 0;\n}",
	"node_modules/node-abi/index----loadGeneratedTargets": "function loadGeneratedTargets() {\n    var registry = require(\"./abi_registry.json\");\n    var targets = {\n        supported: [],\n        additional: [],\n        future: []\n    };\n    registry.forEach(function(item) {\n        var target = {\n            runtime: item.runtime,\n            target: item.target,\n            abi: item.abi\n        };\n        if (item.lts) {\n            var startDate = new Date(Date.parse(item.lts[0]));\n            var endDate = new Date(Date.parse(item.lts[1]));\n            var currentDate = new Date();\n            target.lts = startDate < currentDate && currentDate < endDate;\n        } else {\n            target.lts = false;\n        }\n        if (target.runtime === \"node-webkit\") {\n            targets.additional.push(target);\n        } else if (item.future) {\n            targets.future.push(target);\n        } else {\n            targets.supported.push(target);\n        }\n    });\n    targets.supported.sort(sortByTargetFn);\n    targets.additional.sort(sortByTargetFn);\n    targets.future.sort(sortByTargetFn);\n    return targets;\n}",
	"node_modules/object-inspect/index----addNumericSeparator": "function addNumericSeparator(num, str) {\n    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === \"number\") {\n        var int = num < 0 ? -$floor(-num) : $floor(num);\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, \"$&_\") + \".\" + $replace.call($replace.call(dec, /([0-9]{3})/g, \"$&_\"), /_$/, \"\");\n        }\n    }\n    return $replace.call(str, sepRegex, \"$&_\");\n}",
	"node_modules/object-inspect/index----isSymbol": "function isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === \"object\" && obj instanceof Symbol;\n    }\n    if (typeof obj === \"symbol\") {\n        return true;\n    }\n    if (!obj || typeof obj !== \"object\" || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}",
	"node_modules/object-inspect/index----nameOf": "function nameOf(f) {\n    if (f.name) {\n        return f.name;\n    }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) {\n        return m[1];\n    }\n    return null;\n}",
	"node_modules/object-inspect/index----lowbyte": "function lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: \"b\",\n        9: \"t\",\n        10: \"n\",\n        12: \"f\",\n        13: \"r\"\n    }[n];\n    if (x) {\n        return \"\\\\\" + x;\n    }\n    return \"\\\\x\" + (n < 16 ? \"0\" : \"\") + $toUpperCase.call(n.toString(16));\n}",
	"node_modules/object-inspect/index----arrObjKeys": "function arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : \"\";\n        }\n    }\n    var syms = typeof gOPS === \"function\" ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap[\"$\" + syms[k]] = syms[k];\n        }\n    }\n    for (var key in obj) {\n        if (!has(obj, key)) {\n            continue;\n        }\n        if (isArr && String(Number(key)) === key && key < obj.length) {\n            continue;\n        }\n        if (hasShammedSymbols && symMap[\"$\" + key] instanceof Symbol) {\n            continue;\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + \": \" + inspect(obj[key], obj));\n        } else {\n            xs.push(key + \": \" + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === \"function\") {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push(\"[\" + inspect(syms[j]) + \"]: \" + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}",
	"node_modules/once/once----onceStrict": "function onceStrict(fn) {\n    var f = function() {\n        if (f.called) throw new Error(f.onceError);\n        f.called = true;\n        return f.value = fn.apply(this, arguments);\n    };\n    var name = fn.name || \"Function wrapped with `once`\";\n    f.onceError = name + \" shouldn't be called more than once\";\n    f.called = false;\n    return f;\n}",
	"node_modules/one-time/index----onetime": "function onetime() {\n    if (called) return value;\n    called = 1;\n    value = fn.apply(this, arguments);\n    fn = null;\n    return value;\n}",
	"node_modules/prebuild-install/asset----findAssetId": "function findAssetId(opts, cb) {\n    const downloadUrl = util.getDownloadUrl(opts);\n    const apiUrl = util.getApiUrl(opts);\n    const log = opts.log || util.noopLogger;\n    log.http(\"request\", \"GET \" + apiUrl);\n    const reqOpts = proxy({\n        url: apiUrl,\n        json: true,\n        headers: {\n            \"User-Agent\": \"simple-get\",\n            Authorization: \"token \" + opts.token\n        }\n    }, opts);\n    const req = get.concat(reqOpts, function(err, res, data) {\n        if (err) return cb(err);\n        log.http(res.statusCode, apiUrl);\n        if (res.statusCode !== 200) return cb(err);\n        for (const release of data) {\n            if (release.tag_name === opts[\"tag-prefix\"] + opts.pkg.version) {\n                for (const asset of release.assets) {\n                    if (asset.browser_download_url === downloadUrl) {\n                        return cb(null, asset.id);\n                    }\n                }\n            }\n        }\n        cb(new Error(\"Could not find GitHub release for version\"));\n    });\n    req.setTimeout(30 * 1e3, function() {\n        req.abort();\n    });\n}",
	"node_modules/prebuild-install/download----downloadPrebuild": "function downloadPrebuild(downloadUrl, opts, cb) {\n    let cachedPrebuild = util.cachedPrebuild(downloadUrl);\n    const localPrebuild = util.localPrebuild(downloadUrl, opts);\n    const tempFile = util.tempFile(cachedPrebuild);\n    const log = opts.log || util.noopLogger;\n    if (opts.nolocal) return download();\n    log.info(\"looking for local prebuild @\", localPrebuild);\n    fs.access(localPrebuild, fs.R_OK | fs.W_OK, function(err) {\n        if (err && err.code === \"ENOENT\") {\n            return download();\n        }\n        log.info(\"found local prebuild\");\n        cachedPrebuild = localPrebuild;\n        unpack();\n    });\n    function download() {\n        ensureNpmCacheDir(function(err) {\n            if (err) return onerror(err);\n            log.info(\"looking for cached prebuild @\", cachedPrebuild);\n            fs.access(cachedPrebuild, fs.R_OK | fs.W_OK, function(err) {\n                if (!(err && err.code === \"ENOENT\")) {\n                    log.info(\"found cached prebuild\");\n                    return unpack();\n                }\n                log.http(\"request\", \"GET \" + downloadUrl);\n                const reqOpts = proxy({\n                    url: downloadUrl\n                }, opts);\n                if (opts.token) {\n                    reqOpts.headers = {\n                        \"User-Agent\": \"simple-get\",\n                        Accept: \"application/octet-stream\",\n                        Authorization: \"token \" + opts.token\n                    };\n                }\n                const req = get(reqOpts, function(err, res) {\n                    if (err) return onerror(err);\n                    log.http(res.statusCode, downloadUrl);\n                    if (res.statusCode !== 200) return onerror();\n                    mkdirp(util.prebuildCache(), function() {\n                        log.info(\"downloading to @\", tempFile);\n                        pump(res, fs.createWriteStream(tempFile), function(err) {\n                            if (err) return onerror(err);\n                            fs.rename(tempFile, cachedPrebuild, function(err) {\n                                if (err) return cb(err);\n                                log.info(\"renaming to @\", cachedPrebuild);\n                                unpack();\n                            });\n                        });\n                    });\n                });\n                req.setTimeout(30 * 1e3, function() {\n                    req.abort();\n                });\n            });\n            function onerror(err) {\n                fs.unlink(tempFile, function() {\n                    cb(err || error.noPrebuilts(opts));\n                });\n            }\n        });\n    }\n    function unpack() {\n        let binaryName;\n        const updateName = opts.updateName || function(entry) {\n            if (/\\.node$/i.test(entry.name)) binaryName = entry.name;\n        };\n        log.info(\"unpacking @\", cachedPrebuild);\n        const options = {\n            readable: true,\n            writable: true,\n            hardlinkAsFilesFallback: true\n        };\n        const extract = tfs.extract(opts.path, options).on(\"entry\", updateName);\n        pump(fs.createReadStream(cachedPrebuild), zlib.createGunzip(), extract, function(err) {\n            if (err) return cb(err);\n            let resolved;\n            if (binaryName) {\n                try {\n                    resolved = path.resolve(opts.path || \".\", binaryName);\n                } catch (err) {\n                    return cb(err);\n                }\n                log.info(\"unpack\", \"resolved to \" + resolved);\n                if (opts.runtime === \"node\" && opts.platform === process.platform && opts.abi === process.versions.modules && opts.arch === process.arch) {\n                    try {\n                        require(resolved);\n                    } catch (err) {\n                        return cb(err);\n                    }\n                    log.info(\"unpack\", \"required \" + resolved + \" successfully\");\n                }\n            }\n            cb(null, resolved);\n        });\n    }\n    function ensureNpmCacheDir(cb) {\n        const cacheFolder = util.npmCache();\n        fs.access(cacheFolder, fs.R_OK | fs.W_OK, function(err) {\n            if (err && err.code === \"ENOENT\") {\n                return makeNpmCacheDir();\n            }\n            cb(err);\n        });\n        function makeNpmCacheDir() {\n            log.info(\"npm cache directory missing, creating it...\");\n            mkdirp(cacheFolder, cb);\n        }\n    }\n}",
	"node_modules/prebuild-install/proxy----applyProxy": "function applyProxy(reqOpts, opts) {\n    const log = opts.log || util.noopLogger;\n    const proxy = opts[\"https-proxy\"] || opts.proxy;\n    if (proxy) {\n        const parsedDownloadUrl = url.parse(reqOpts.url);\n        const parsedProxy = url.parse(proxy);\n        const uriProtocol = parsedDownloadUrl.protocol === \"https:\" ? \"https\" : \"http\";\n        const proxyProtocol = parsedProxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n        const tunnelFnName = [ uriProtocol, proxyProtocol ].join(\"Over\");\n        reqOpts.agent = tunnel[tunnelFnName]({\n            proxy: {\n                host: parsedProxy.hostname,\n                port: +parsedProxy.port,\n                proxyAuth: parsedProxy.auth\n            }\n        });\n        log.http(\"request\", \"Proxy setup detected (Host: \" + parsedProxy.hostname + \", Port: \" + parsedProxy.port + \", Authentication: \" + (parsedProxy.auth ? \"Yes\" : \"No\") + \")\" + \" Tunneling with \" + tunnelFnName);\n    }\n    return reqOpts;\n}",
	"node_modules/prebuild-install/util----urlTemplate": "function urlTemplate(opts) {\n    if (typeof opts.download === \"string\") {\n        return opts.download;\n    }\n    const packageName = \"{name}-v{version}-{runtime}-v{abi}-{platform}{libc}-{arch}.tar.gz\";\n    const hostMirrorUrl = getHostMirrorUrl(opts);\n    if (hostMirrorUrl) {\n        return hostMirrorUrl + \"/{tag_prefix}{version}/\" + packageName;\n    }\n    if (opts.pkg.binary && opts.pkg.binary.host) {\n        return [ opts.pkg.binary.host, opts.pkg.binary.remote_path, opts.pkg.binary.package_name || packageName ].map(function(path) {\n            return trimSlashes(path);\n        }).filter(Boolean).join(\"/\");\n    }\n    return github(opts.pkg) + \"/releases/download/{tag_prefix}{version}/\" + packageName;\n}",
	"node_modules/punycode/punycode----map": "function map(array, fn) {\n    var length = array.length;\n    var result = [];\n    while (length--) {\n        result[length] = fn(array[length]);\n    }\n    return result;\n}",
	"node_modules/punycode/punycode----mapDomain": "function mapDomain(string, fn) {\n    var parts = string.split(\"@\");\n    var result = \"\";\n    if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n    }\n    string = string.replace(regexSeparators, \".\");\n    var labels = string.split(\".\");\n    var encoded = map(labels, fn).join(\".\");\n    return result + encoded;\n}",
	"node_modules/punycode/punycode----basicToDigit": "function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n        return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n        return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n        return codePoint - 97;\n    }\n    return base;\n}",
	"node_modules/punycode/punycode----adapt": "function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (;delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}",
	"node_modules/punycode/punycode----decode": "function decode(input) {\n    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n            error(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n    }\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        for (oldi = i, w = 1, k = base; ;k += base) {\n            if (index >= inputLength) {\n                error(\"invalid-input\");\n            }\n            digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > floor((maxInt - i) / w)) {\n                error(\"overflow\");\n            }\n            i += digit * w;\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n                break;\n            }\n            baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n                error(\"overflow\");\n            }\n            w *= baseMinusT;\n        }\n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n            error(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n}",
	"node_modules/punycode/punycode----encode": "function encode(input) {\n    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;\n    input = ucs2decode(input);\n    inputLength = input.length;\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n    for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < 128) {\n            output.push(stringFromCharCode(currentValue));\n        }\n    }\n    handledCPCount = basicLength = output.length;\n    if (basicLength) {\n        output.push(delimiter);\n    }\n    while (handledCPCount < inputLength) {\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue < n && ++delta > maxInt) {\n                error(\"overflow\");\n            }\n            if (currentValue == n) {\n                for (q = delta, k = base; ;k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                    q = floor(qMinusT / baseMinusT);\n                }\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n        ++delta;\n        ++n;\n    }\n    return output.join(\"\");\n}",
	"node_modules/readable-stream/errors-browser----createErrorType": "function createErrorType(code, message, Base) {\n    if (!Base) {\n        Base = Error;\n    }\n    function getMessage(arg1, arg2, arg3) {\n        if (typeof message === \"string\") {\n            return message;\n        } else {\n            return message(arg1, arg2, arg3);\n        }\n    }\n    var NodeError = function(_Base) {\n        _inheritsLoose(NodeError, _Base);\n        function NodeError(arg1, arg2, arg3) {\n            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n        }\n        return NodeError;\n    }(Base);\n    NodeError.prototype.name = Base.name;\n    NodeError.prototype.code = code;\n    codes[code] = NodeError;\n}",
	"node_modules/readable-stream/errors----createErrorType": "function createErrorType(code, message, Base) {\n    if (!Base) {\n        Base = Error;\n    }\n    function getMessage(arg1, arg2, arg3) {\n        if (typeof message === \"string\") {\n            return message;\n        } else {\n            return message(arg1, arg2, arg3);\n        }\n    }\n    class NodeError extends Base {\n        constructor(arg1, arg2, arg3) {\n            super(getMessage(arg1, arg2, arg3));\n        }\n    }\n    NodeError.prototype.name = Base.name;\n    NodeError.prototype.code = code;\n    codes[code] = NodeError;\n}",
	"node_modules/readable-stream/experimentalWarning----emitExperimentalWarning": "function emitExperimentalWarning(feature) {\n    if (experimentalWarnings.has(feature)) return;\n    var msg = feature + \" is an experimental feature. This feature could \" + \"change at any time\";\n    experimentalWarnings.add(feature);\n    process.emitWarning(msg, \"ExperimentalWarning\");\n}",
	"node_modules/requests/requested----Requested": "function Requested(url, options) {\n    EventEmitter.call(this);\n    this.merge(this, Requested.defaults, options || {});\n    this.id = ++Requested.requested;\n    this.readable = true;\n    this.writable = false;\n    if (this.initialize) this.initialize(url);\n    if (!this.manual && this.open) this.open(url);\n}",
	"node_modules/simple-get/index----simpleGet": "function simpleGet(opts, cb) {\n    opts = Object.assign({\n        maxRedirects: 10\n    }, typeof opts === \"string\" ? {\n        url: opts\n    } : opts);\n    cb = once(cb);\n    if (opts.url) {\n        const {\n            hostname,\n            port,\n            protocol,\n            auth,\n            path\n        } = url.parse(opts.url);\n        delete opts.url;\n        if (!hostname && !port && !protocol && !auth) opts.path = path; else Object.assign(opts, {\n            hostname: hostname,\n            port: port,\n            protocol: protocol,\n            auth: auth,\n            path: path\n        });\n    }\n    const headers = {\n        \"accept-encoding\": \"gzip, deflate\"\n    };\n    if (opts.headers) Object.keys(opts.headers).forEach(k => headers[k.toLowerCase()] = opts.headers[k]);\n    opts.headers = headers;\n    let body;\n    if (opts.body) {\n        body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;\n    } else if (opts.form) {\n        body = typeof opts.form === \"string\" ? opts.form : querystring.stringify(opts.form);\n        opts.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n    }\n    if (body) {\n        if (!opts.method) opts.method = \"POST\";\n        if (!isStream(body)) opts.headers[\"content-length\"] = Buffer.byteLength(body);\n        if (opts.json && !opts.form) opts.headers[\"content-type\"] = \"application/json\";\n    }\n    delete opts.body;\n    delete opts.form;\n    if (opts.json) opts.headers.accept = \"application/json\";\n    if (opts.method) opts.method = opts.method.toUpperCase();\n    const originalHost = opts.hostname;\n    const protocol = opts.protocol === \"https:\" ? https : http;\n    const req = protocol.request(opts, res => {\n        if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n            opts.url = res.headers.location;\n            delete opts.headers.host;\n            res.resume();\n            const redirectHost = url.parse(opts.url).hostname;\n            if (redirectHost !== null && redirectHost !== originalHost) {\n                delete opts.headers.cookie;\n                delete opts.headers.authorization;\n            }\n            if (opts.method === \"POST\" && [ 301, 302 ].includes(res.statusCode)) {\n                opts.method = \"GET\";\n                delete opts.headers[\"content-length\"];\n                delete opts.headers[\"content-type\"];\n            }\n            if (opts.maxRedirects-- === 0) return cb(new Error(\"too many redirects\")); else return simpleGet(opts, cb);\n        }\n        const tryUnzip = typeof decompressResponse === \"function\" && opts.method !== \"HEAD\";\n        cb(null, tryUnzip ? decompressResponse(res) : res);\n    });\n    req.on(\"timeout\", () => {\n        req.abort();\n        cb(new Error(\"Request timed out\"));\n    });\n    req.on(\"error\", cb);\n    if (isStream(body)) body.on(\"error\", cb).pipe(req); else req.end(body);\n    return req;\n}",
	"node_modules/tar-stream/headers----parse256": "function parse256(buf) {\n    var positive;\n    if (buf[0] === 128) positive = true; else if (buf[0] === 255) positive = false; else return null;\n    var tuple = [];\n    for (var i = buf.length - 1; i > 0; i--) {\n        var byte = buf[i];\n        if (positive) tuple.push(byte); else tuple.push(255 - byte);\n    }\n    var sum = 0;\n    var l = tuple.length;\n    for (i = 0; i < l; i++) {\n        sum += tuple[i] * Math.pow(256, i);\n    }\n    return positive ? sum : -1 * sum;\n}",
	"node_modules/tunnel-agent/index----httpsOverHttp": "function httpsOverHttp(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = http.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}",
	"node_modules/tunnel-agent/index----httpsOverHttps": "function httpsOverHttps(options) {\n    var agent = new TunnelingAgent(options);\n    agent.request = https.request;\n    agent.createSocket = createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}",
	"node_modules/tunnel-agent/index----TunnelingAgent": "function TunnelingAgent(options) {\n    var self = this;\n    self.options = options || {};\n    self.proxyOptions = self.options.proxy || {};\n    self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n    self.requests = [];\n    self.sockets = [];\n    self.on(\"free\", function onFree(socket, host, port) {\n        for (var i = 0, len = self.requests.length; i < len; ++i) {\n            var pending = self.requests[i];\n            if (pending.host === host && pending.port === port) {\n                self.requests.splice(i, 1);\n                pending.request.onSocket(socket);\n                return;\n            }\n        }\n        socket.destroy();\n        self.removeSocket(socket);\n    });\n}",
	"node_modules/tunnel-agent/index----onCloseOrRemove": "function onCloseOrRemove(err) {\n    self.removeSocket(socket);\n    socket.removeListener(\"free\", onFree);\n    socket.removeListener(\"close\", onCloseOrRemove);\n    socket.removeListener(\"agentRemove\", onCloseOrRemove);\n}",
	"node_modules/tunnel-agent/index----onError": "function onError(cause) {\n    connectReq.removeAllListeners();\n    debug(\"tunneling socket could not be established, cause=%s\\n\", cause.message, cause.stack);\n    var error = new Error(\"tunneling socket could not be established, \" + \"cause=\" + cause.message);\n    error.code = \"ECONNRESET\";\n    options.request.emit(\"error\", error);\n    self.removeSocket(placeholder);\n}",
	"node_modules/url/url----Url": "function Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n}",
	"node_modules/url/url----urlParse": "function urlParse(url, parseQueryString, slashesDenoteHost) {\n    if (url && isObject(url) && url instanceof Url) return url;\n    var u = new Url();\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n}",
	"node_modules/util/util----inspect": "function inspect(obj, opts) {\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n    } else if (opts) {\n        exports._extend(ctx, opts);\n    }\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}",
	"node_modules/util/util----formatValue": "function formatValue(ctx, value, recurseTimes) {\n    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n    if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n    }\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? \": \" + value.name : \"\";\n            return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n    }\n    var base = \"\", array = false, braces = [ \"{\", \"}\" ];\n    if (isArray(value)) {\n        array = true;\n        braces = [ \"[\", \"]\" ];\n    }\n    if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n    }\n    if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n    }\n    if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n    }\n    if (isError(value)) {\n        base = \" \" + formatError(value);\n    }\n    if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n    }\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n            return ctx.stylize(\"[Object]\", \"special\");\n        }\n    }\n    ctx.seen.push(value);\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function(key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n}",
	"node_modules/util/util----formatPrimitive": "function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n    if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n    }\n    if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n    if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n    if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}",
	"node_modules/util/util----formatArray": "function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n            output.push(\"\");\n        }\n    }\n    keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n    });\n    return output;\n}",
	"node_modules/util/util----formatProperty": "function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {\n        value: value[key]\n    };\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n            str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf(\"\\n\") > -1) {\n                if (array) {\n                    str = str.split(\"\\n\").map(function(line) {\n                        return \"  \" + line;\n                    }).join(\"\\n\").substr(2);\n                } else {\n                    str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                        return \"   \" + line;\n                    }).join(\"\\n\");\n                }\n            }\n        } else {\n            str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, \"name\");\n        } else {\n            name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, \"string\");\n        }\n    }\n    return name + \": \" + str;\n}",
	"node_modules/util/util----reduceToSingleString": "function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n    }, 0);\n    if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n    }\n    return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}",
	"node_modules/util/util----fn": "function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function(resolve, reject) {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    });\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n    }\n    args.push(function(err, value) {\n        if (err) {\n            promiseReject(err);\n        } else {\n            promiseResolve(value);\n        }\n    });\n    try {\n        original.apply(this, args);\n    } catch (err) {\n        promiseReject(err);\n    }\n    return promise;\n}",
	"node_modules/util/util----callbackify": "function callbackify(original) {\n    if (typeof original !== \"function\") {\n        throw new TypeError('The \"original\" argument must be of type Function');\n    }\n    function callbackified() {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        var maybeCb = args.pop();\n        if (typeof maybeCb !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n        }\n        var self = this;\n        var cb = function() {\n            return maybeCb.apply(self, arguments);\n        };\n        original.apply(this, args).then(function(ret) {\n            process.nextTick(cb.bind(null, null, ret));\n        }, function(rej) {\n            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));\n        });\n    }\n    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));\n    return callbackified;\n}",
	"node_modules/util-deprecate/browser----deprecate": "function deprecate(fn, msg) {\n    if (config(\"noDeprecation\")) {\n        return fn;\n    }\n    var warned = false;\n    function deprecated() {\n        if (!warned) {\n            if (config(\"throwDeprecation\")) {\n                throw new Error(msg);\n            } else if (config(\"traceDeprecation\")) {\n                console.trace(msg);\n            } else {\n                console.warn(msg);\n            }\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n    return deprecated;\n}",
	"node_modules/util-deprecate/browser----config": "function config(name) {\n    try {\n        if (!global.localStorage) return false;\n    } catch (_) {\n        return false;\n    }\n    var val = global.localStorage[name];\n    if (null == val) return false;\n    return String(val).toLowerCase() === \"true\";\n}",
	"node_modules/wrappy/wrappy----wrappy": "function wrappy(fn, cb) {\n    if (fn && cb) return wrappy(fn)(cb);\n    if (typeof fn !== \"function\") throw new TypeError(\"need wrapper function\");\n    Object.keys(fn).forEach(function(k) {\n        wrapper[k] = fn[k];\n    });\n    return wrapper;\n    function wrapper() {\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n        }\n        var ret = fn.apply(this, args);\n        var cb = args[args.length - 1];\n        if (typeof ret === \"function\" && ret !== cb) {\n            Object.keys(cb).forEach(function(k) {\n                ret[k] = cb[k];\n            });\n        }\n        return ret;\n    }\n}",
	"node_modules/yallist/yallist----Yallist": "function Yallist(list) {\n    var self = this;\n    if (!(self instanceof Yallist)) {\n        self = new Yallist();\n    }\n    self.tail = null;\n    self.head = null;\n    self.length = 0;\n    if (list && typeof list.forEach === \"function\") {\n        list.forEach(function(item) {\n            self.push(item);\n        });\n    } else if (arguments.length > 0) {\n        for (var i = 0, l = arguments.length; i < l; i++) {\n            self.push(arguments[i]);\n        }\n    }\n    return self;\n}",
	"node_modules/yallist/yallist----insert": "function insert(self, node, value) {\n    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);\n    if (inserted.next === null) {\n        self.tail = inserted;\n    }\n    if (inserted.prev === null) {\n        self.head = inserted;\n    }\n    self.length++;\n    return inserted;\n}",
	"node_modules/yallist/yallist----Node": "function Node(value, prev, next, list) {\n    if (!(this instanceof Node)) {\n        return new Node(value, prev, next, list);\n    }\n    this.list = list;\n    this.value = value;\n    if (prev) {\n        prev.next = this;\n        this.prev = prev;\n    } else {\n        this.prev = null;\n    }\n    if (next) {\n        next.prev = this;\n        this.next = next;\n    } else {\n        this.next = null;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----__webpack_require__": "function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = installedModules[moduleId] = {\n        exports: {},\n        id: moduleId,\n        loaded: false\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    module.loaded = true;\n    return module.exports;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----cleanUpNextTick": "function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----drainQueue": "function drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----setImmediate": "function setImmediate(callback) {\n    if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n    }\n    var args = new Array(arguments.length - 1);\n    for (var i = 0; i < args.length; i++) {\n        args[i] = arguments[i + 1];\n    }\n    var task = {\n        callback: callback,\n        args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----installPostMessageImplementation": "function installPostMessageImplementation() {\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n    var onGlobalMessage = function(event) {\n        if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n            runIfPresent(+event.data.slice(messagePrefix.length));\n        }\n    };\n    if (global.addEventListener) {\n        global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n        global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n    registerImmediate = function(handle) {\n        global.postMessage(messagePrefix + handle, \"*\");\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || _rng.default)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : (0, _bytesToUuid.default)(b);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----_default": "function _default(name, version, hashfunc) {\n    var generateUUID = function(value, namespace, buf, offset) {\n        var off = buf && offset || 0;\n        if (typeof value == \"string\") value = stringToBytes(value);\n        if (typeof namespace == \"string\") namespace = uuidToBytes(namespace);\n        if (!Array.isArray(value)) throw TypeError(\"value must be an array of bytes\");\n        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError(\"namespace must be uuid string or an Array of 16 byte values\");\n        var bytes = hashfunc(namespace.concat(value));\n        bytes[6] = bytes[6] & 15 | version;\n        bytes[8] = bytes[8] & 63 | 128;\n        if (buf) {\n            for (var idx = 0; idx < 16; ++idx) {\n                buf[off + idx] = bytes[idx];\n            }\n        }\n        return buf || (0, _bytesToUuid.default)(bytes);\n    };\n    try {\n        generateUUID.name = name;\n    } catch (err) {}\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----md5ToHexEncodedArray": "function md5ToHexEncodedArray(input) {\n    var i;\n    var x;\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    var hex;\n    for (i = 0; i < length32; i += 8) {\n        x = input[i >> 5] >>> i % 32 & 255;\n        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n        output.push(hex);\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----wordsToMd5": "function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var i;\n    var olda;\n    var oldb;\n    var oldc;\n    var oldd;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [ a, b, c, d ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----bytesToWords": "function bytesToWords(input) {\n    var i;\n    var output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    var length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || _rng.default)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || (0, _bytesToUuid.default)(rnds);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----sha1": "function sha1(bytes) {\n    var K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof bytes == \"string\") {\n        var msg = unescape(encodeURIComponent(bytes));\n        bytes = new Array(msg.length);\n        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {\n            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n        }\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var i = 0; i < N; i++) {\n        var W = new Array(80);\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 80; t++) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        var a = H[0];\n        var b = H[1];\n        var c = H[2];\n        var d = H[3];\n        var e = H[4];\n        for (var t = 0; t < 80; t++) {\n            var s = Math.floor(t / 20);\n            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = H[0] + a >>> 0;\n        H[1] = H[1] + b >>> 0;\n        H[2] = H[2] + c >>> 0;\n        H[3] = H[3] + d >>> 0;\n        H[4] = H[4] + e >>> 0;\n    }\n    return [ H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255 ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----buildRequest": "function buildRequest(req) {\n    populateMethod(req);\n    populateURI(req);\n    populateHeaders(req);\n    populateHostPrefix(req);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----extractError": "function extractError(resp) {\n    Rest.extractError(resp);\n    var data;\n    try {\n        data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());\n    } catch (e) {\n        data = {\n            Code: resp.httpResponse.statusCode,\n            Message: resp.httpResponse.statusMessage\n        };\n    }\n    if (data.Errors) data = data.Errors;\n    if (data.Error) data = data.Error;\n    if (data.Code) {\n        resp.error = util.error(new Error(), {\n            code: data.Code,\n            message: data.Message\n        });\n    } else {\n        resp.error = util.error(new Error(), {\n            code: resp.httpResponse.statusCode,\n            message: null\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----translateStructure": "function translateStructure(structure, shape) {\n    if (structure == null) return undefined;\n    if (shape.isDocument) return structure;\n    var struct = {};\n    var shapeMembers = shape.members;\n    util.each(shapeMembers, function(name, memberShape) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n            var value = structure[locationName];\n            var result = translate(value, memberShape);\n            if (result !== undefined) struct[name] = result;\n        }\n    });\n    return struct;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----translateList": "function translateList(list, shape) {\n    if (list == null) return undefined;\n    var out = [];\n    util.arrayEach(list, function(value) {\n        var result = translate(value, shape.member);\n        if (result === undefined) out.push(null); else out.push(result);\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----translateMap": "function translateMap(map, shape) {\n    if (map == null) return undefined;\n    var out = {};\n    util.each(map, function(key, value) {\n        var result = translate(value, shape.value);\n        if (result === undefined) out[key] = null; else out[key] = result;\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----populateHostPrefix": "function populateHostPrefix(request) {\n    var enabled = request.service.config.hostPrefixEnabled;\n    if (!enabled) return request;\n    var operationModel = request.service.api.operations[request.operation];\n    if (hasEndpointDiscover(request)) return request;\n    if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {\n        var hostPrefixNotation = operationModel.endpoint.hostPrefix;\n        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);\n        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);\n        validateHostname(request.httpRequest.endpoint.hostname);\n    }\n    return request;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----hasEndpointDiscover": "function hasEndpointDiscover(request) {\n    var api = request.service.api;\n    var operationModel = api.operations[request.operation];\n    var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);\n    return operationModel.endpointDiscoveryRequired !== \"NULL\" || isEndpointOperation === true;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----extractData": "function extractData(resp) {\n    Rest.extractData(resp);\n    var parser;\n    var req = resp.request;\n    var body = resp.httpResponse.body;\n    var operation = req.service.api.operations[req.operation];\n    var output = operation.output;\n    var hasEventOutput = operation.hasEventOutput;\n    var payload = output.payload;\n    if (payload) {\n        var payloadMember = output.members[payload];\n        if (payloadMember.isEventStream) {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);\n        } else if (payloadMember.type === \"structure\") {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = parser.parse(body.toString(), payloadMember);\n        } else if (payloadMember.type === \"binary\" || payloadMember.isStreaming) {\n            resp.data[payload] = body;\n        } else {\n            resp.data[payload] = payloadMember.toType(body);\n        }\n    } else if (body.length > 0) {\n        parser = new AWS.XML.Parser();\n        var data = parser.parse(body.toString(), output);\n        util.update(resp.data, data);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----Shape": "function Shape(shape, options, memberName) {\n    options = options || {};\n    property(this, \"shape\", shape.shape);\n    property(this, \"api\", options.api, false);\n    property(this, \"type\", shape.type);\n    property(this, \"enum\", shape.enum);\n    property(this, \"min\", shape.min);\n    property(this, \"max\", shape.max);\n    property(this, \"pattern\", shape.pattern);\n    property(this, \"location\", shape.location || this.location || \"body\");\n    property(this, \"name\", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);\n    property(this, \"isStreaming\", shape.streaming || this.isStreaming || false);\n    property(this, \"requiresLength\", shape.requiresLength, false);\n    property(this, \"isComposite\", shape.isComposite || false);\n    property(this, \"isShape\", true, false);\n    property(this, \"isQueryName\", Boolean(shape.queryName), false);\n    property(this, \"isLocationName\", Boolean(shape.locationName), false);\n    property(this, \"isIdempotent\", shape.idempotencyToken === true);\n    property(this, \"isJsonValue\", shape.jsonvalue === true);\n    property(this, \"isSensitive\", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);\n    property(this, \"isEventStream\", Boolean(shape.eventstream), false);\n    property(this, \"isEvent\", Boolean(shape.event), false);\n    property(this, \"isEventPayload\", Boolean(shape.eventpayload), false);\n    property(this, \"isEventHeader\", Boolean(shape.eventheader), false);\n    property(this, \"isTimestampFormatSet\", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);\n    property(this, \"endpointDiscoveryId\", Boolean(shape.endpointdiscoveryid), false);\n    property(this, \"hostLabel\", Boolean(shape.hostLabel), false);\n    if (options.documentation) {\n        property(this, \"documentation\", shape.documentation);\n        property(this, \"documentationUrl\", shape.documentationUrl);\n    }\n    if (shape.xmlAttribute) {\n        property(this, \"isXmlAttribute\", shape.xmlAttribute || false);\n    }\n    property(this, \"defaultValue\", null);\n    this.toWireFormat = function(value) {\n        if (value === null || value === undefined) return \"\";\n        return value;\n    };\n    this.toType = function(value) {\n        return value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----StructureShape": "function StructureShape(shape, options) {\n    var self = this;\n    var requiredMap = null, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"members\", {});\n        property(this, \"memberNames\", []);\n        property(this, \"required\", []);\n        property(this, \"isRequired\", function() {\n            return false;\n        });\n        property(this, \"isDocument\", Boolean(shape.document));\n    }\n    if (shape.members) {\n        property(this, \"members\", new Collection(shape.members, options, function(name, member) {\n            return Shape.create(member, options, name);\n        }));\n        memoizedProperty(this, \"memberNames\", function() {\n            return shape.xmlOrder || Object.keys(shape.members);\n        });\n        if (shape.event) {\n            memoizedProperty(this, \"eventPayloadMemberName\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventPayload) {\n                        return memberNames[i];\n                    }\n                }\n            });\n            memoizedProperty(this, \"eventHeaderMemberNames\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                var eventHeaderMemberNames = [];\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventHeader) {\n                        eventHeaderMemberNames.push(memberNames[i]);\n                    }\n                }\n                return eventHeaderMemberNames;\n            });\n        }\n    }\n    if (shape.required) {\n        property(this, \"required\", shape.required);\n        property(this, \"isRequired\", function(name) {\n            if (!requiredMap) {\n                requiredMap = {};\n                for (var i = 0; i < shape.required.length; i++) {\n                    requiredMap[shape.required[i]] = true;\n                }\n            }\n            return requiredMap[name];\n        }, false, true);\n    }\n    property(this, \"resultWrapper\", shape.resultWrapper || null);\n    if (shape.payload) {\n        property(this, \"payload\", shape.payload);\n    }\n    if (typeof shape.xmlNamespace === \"string\") {\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace);\n    } else if (typeof shape.xmlNamespace === \"object\") {\n        property(this, \"xmlNamespacePrefix\", shape.xmlNamespace.prefix);\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace.uri);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----ListShape": "function ListShape(shape, options) {\n    var self = this, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return [];\n        });\n    }\n    if (shape.member) {\n        memoizedProperty(this, \"member\", function() {\n            return Shape.create(shape.member, options);\n        });\n    }\n    if (this.flattened) {\n        var oldName = this.name;\n        memoizedProperty(this, \"name\", function() {\n            return self.member.name || oldName;\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----MapShape": "function MapShape(shape, options) {\n    var firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"key\", Shape.create({\n            type: \"string\"\n        }, options));\n        property(this, \"value\", Shape.create({\n            type: \"string\"\n        }, options));\n    }\n    if (shape.key) {\n        memoizedProperty(this, \"key\", function() {\n            return Shape.create(shape.key, options);\n        });\n    }\n    if (shape.value) {\n        memoizedProperty(this, \"value\", function() {\n            return Shape.create(shape.value, options);\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----TimestampShape": "function TimestampShape(shape) {\n    var self = this;\n    Shape.apply(this, arguments);\n    if (shape.timestampFormat) {\n        property(this, \"timestampFormat\", shape.timestampFormat);\n    } else if (self.isTimestampFormatSet && this.timestampFormat) {\n        property(this, \"timestampFormat\", this.timestampFormat);\n    } else if (this.location === \"header\") {\n        property(this, \"timestampFormat\", \"rfc822\");\n    } else if (this.location === \"querystring\") {\n        property(this, \"timestampFormat\", \"iso8601\");\n    } else if (this.api) {\n        switch (this.api.protocol) {\n          case \"json\":\n          case \"rest-json\":\n            property(this, \"timestampFormat\", \"unixTimestamp\");\n            break;\n\n          case \"rest-xml\":\n          case \"query\":\n          case \"ec2\":\n            property(this, \"timestampFormat\", \"iso8601\");\n            break;\n        }\n    }\n    this.toType = function(value) {\n        if (value === null || value === undefined) return null;\n        if (typeof value.toUTCString === \"function\") return value;\n        return typeof value === \"string\" || typeof value === \"number\" ? util.date.parseTimestamp(value) : null;\n    };\n    this.toWireFormat = function(value) {\n        return util.date.format(value, self.timestampFormat);\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----StringShape": "function StringShape() {\n    Shape.apply(this, arguments);\n    var nullLessProtocols = [ \"rest-xml\", \"query\", \"ec2\" ];\n    this.toType = function(value) {\n        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || \"\" : value;\n        if (this.isJsonValue) {\n            return JSON.parse(value);\n        }\n        return value && typeof value.toString === \"function\" ? value.toString() : value;\n    };\n    this.toWireFormat = function(value) {\n        return this.isJsonValue ? JSON.stringify(value) : value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----generateURI": "function generateURI(endpointPath, operationPath, input, params) {\n    var uri = [ endpointPath, operationPath ].join(\"/\");\n    uri = uri.replace(/\\/+/g, \"/\");\n    var queryString = {}, queryStringSet = false;\n    util.each(input.members, function(name, member) {\n        var paramValue = params[name];\n        if (paramValue === null || paramValue === undefined) return;\n        if (member.location === \"uri\") {\n            var regex = new RegExp(\"\\\\{\" + member.name + \"(\\\\+)?\\\\}\");\n            uri = uri.replace(regex, function(_, plus) {\n                var fn = plus ? util.uriEscapePath : util.uriEscape;\n                return fn(String(paramValue));\n            });\n        } else if (member.location === \"querystring\") {\n            queryStringSet = true;\n            if (member.type === \"list\") {\n                queryString[member.name] = paramValue.map(function(val) {\n                    return util.uriEscape(member.member.toWireFormat(val).toString());\n                });\n            } else if (member.type === \"map\") {\n                util.each(paramValue, function(key, value) {\n                    if (Array.isArray(value)) {\n                        queryString[key] = value.map(function(val) {\n                            return util.uriEscape(String(val));\n                        });\n                    } else {\n                        queryString[key] = util.uriEscape(String(value));\n                    }\n                });\n            } else {\n                queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());\n            }\n        }\n    });\n    if (queryStringSet) {\n        uri += uri.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n        var parts = [];\n        util.arrayEach(Object.keys(queryString).sort(), function(key) {\n            if (!Array.isArray(queryString[key])) {\n                queryString[key] = [ queryString[key] ];\n            }\n            for (var i = 0; i < queryString[key].length; i++) {\n                parts.push(util.uriEscape(String(key)) + \"=\" + queryString[key][i]);\n            }\n        });\n        uri += parts.join(\"&\");\n    }\n    return uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----populateURI": "function populateURI(req) {\n    var operation = req.service.api.operations[req.operation];\n    var input = operation.input;\n    var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);\n    req.httpRequest.path = uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----populateBody": "function populateBody(req) {\n    var input = req.service.api.operations[req.operation].input;\n    var builder = new AWS.XML.Builder();\n    var params = req.params;\n    var payload = input.payload;\n    if (payload) {\n        var payloadMember = input.members[payload];\n        params = params[payload];\n        if (params === undefined) return;\n        if (payloadMember.type === \"structure\") {\n            var rootElement = payloadMember.name;\n            req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n        } else {\n            req.httpRequest.body = params;\n        }\n    } else {\n        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + \"Request\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----XmlNode": "function XmlNode(name, children) {\n    if (children === void 0) {\n        children = [];\n    }\n    this.name = name;\n    this.children = children;\n    this.attributes = {};\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----Api": "function Api(api, options) {\n    var self = this;\n    api = api || {};\n    options = options || {};\n    options.api = this;\n    api.metadata = api.metadata || {};\n    var serviceIdentifier = options.serviceIdentifier;\n    delete options.serviceIdentifier;\n    property(this, \"isApi\", true, false);\n    property(this, \"apiVersion\", api.metadata.apiVersion);\n    property(this, \"endpointPrefix\", api.metadata.endpointPrefix);\n    property(this, \"signingName\", api.metadata.signingName);\n    property(this, \"globalEndpoint\", api.metadata.globalEndpoint);\n    property(this, \"signatureVersion\", api.metadata.signatureVersion);\n    property(this, \"jsonVersion\", api.metadata.jsonVersion);\n    property(this, \"targetPrefix\", api.metadata.targetPrefix);\n    property(this, \"protocol\", api.metadata.protocol);\n    property(this, \"timestampFormat\", api.metadata.timestampFormat);\n    property(this, \"xmlNamespaceUri\", api.metadata.xmlNamespace);\n    property(this, \"abbreviation\", api.metadata.serviceAbbreviation);\n    property(this, \"fullName\", api.metadata.serviceFullName);\n    property(this, \"serviceId\", api.metadata.serviceId);\n    if (serviceIdentifier && metadata[serviceIdentifier]) {\n        property(this, \"xmlNoDefaultLists\", metadata[serviceIdentifier].xmlNoDefaultLists, false);\n    }\n    memoizedProperty(this, \"className\", function() {\n        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;\n        if (!name) return null;\n        name = name.replace(/^Amazon|AWS\\s*|\\(.*|\\s+|\\W+/g, \"\");\n        if (name === \"ElasticLoadBalancing\") name = \"ELB\";\n        return name;\n    });\n    function addEndpointOperation(name, operation) {\n        if (operation.endpointoperation === true) {\n            property(self, \"endpointOperation\", util.string.lowerFirst(name));\n        }\n        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {\n            property(self, \"hasRequiredEndpointDiscovery\", operation.endpointdiscovery.required === true);\n        }\n    }\n    property(this, \"operations\", new Collection(api.operations, options, function(name, operation) {\n        return new Operation(name, operation, options);\n    }, util.string.lowerFirst, addEndpointOperation));\n    property(this, \"shapes\", new Collection(api.shapes, options, function(name, shape) {\n        return Shape.create(shape, options);\n    }));\n    property(this, \"paginators\", new Collection(api.paginators, options, function(name, paginator) {\n        return new Paginator(name, paginator, options);\n    }));\n    property(this, \"waiters\", new Collection(api.waiters, options, function(name, waiter) {\n        return new ResourceWaiter(name, waiter, options);\n    }, util.string.lowerFirst));\n    if (options.documentation) {\n        property(this, \"documentation\", api.documentation);\n        property(this, \"documentationUrl\", api.documentationUrl);\n    }\n    property(this, \"errorCodeMapping\", api.awsQueryCompatible);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----Operation": "function Operation(name, operation, options) {\n    var self = this;\n    options = options || {};\n    property(this, \"name\", operation.name || name);\n    property(this, \"api\", options.api, false);\n    operation.http = operation.http || {};\n    property(this, \"endpoint\", operation.endpoint);\n    property(this, \"httpMethod\", operation.http.method || \"POST\");\n    property(this, \"httpPath\", operation.http.requestUri || \"/\");\n    property(this, \"authtype\", operation.authtype || \"\");\n    property(this, \"endpointDiscoveryRequired\", operation.endpointdiscovery ? operation.endpointdiscovery.required ? \"REQUIRED\" : \"OPTIONAL\" : \"NULL\");\n    var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;\n    property(this, \"httpChecksumRequired\", httpChecksumRequired, false);\n    memoizedProperty(this, \"input\", function() {\n        if (!operation.input) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.input, options);\n    });\n    memoizedProperty(this, \"output\", function() {\n        if (!operation.output) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.output, options);\n    });\n    memoizedProperty(this, \"errors\", function() {\n        var list = [];\n        if (!operation.errors) return null;\n        for (var i = 0; i < operation.errors.length; i++) {\n            list.push(Shape.create(operation.errors[i], options));\n        }\n        return list;\n    });\n    memoizedProperty(this, \"paginator\", function() {\n        return options.api.paginators[name];\n    });\n    if (options.documentation) {\n        property(this, \"documentation\", operation.documentation);\n        property(this, \"documentationUrl\", operation.documentationUrl);\n    }\n    memoizedProperty(this, \"idempotentMembers\", function() {\n        var idempotentMembers = [];\n        var input = self.input;\n        var members = input.members;\n        if (!input.members) {\n            return idempotentMembers;\n        }\n        for (var name in members) {\n            if (!members.hasOwnProperty(name)) {\n                continue;\n            }\n            if (members[name].isIdempotent === true) {\n                idempotentMembers.push(name);\n            }\n        }\n        return idempotentMembers;\n    });\n    memoizedProperty(this, \"hasEventOutput\", function() {\n        var output = self.output;\n        return hasEventStream(output);\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----hasEventStream": "function hasEventStream(topLevelShape) {\n    var members = topLevelShape.members;\n    var payload = topLevelShape.payload;\n    if (!topLevelShape.members) {\n        return false;\n    }\n    if (payload) {\n        var payloadMember = members[payload];\n        return payloadMember.isEventStream;\n    }\n    for (var name in members) {\n        if (!members.hasOwnProperty(name)) {\n            if (members[name].isEventStream === true) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----Paginator": "function Paginator(name, paginator) {\n    property(this, \"inputToken\", paginator.input_token);\n    property(this, \"limitKey\", paginator.limit_key);\n    property(this, \"moreResults\", paginator.more_results);\n    property(this, \"outputToken\", paginator.output_token);\n    property(this, \"resultKey\", paginator.result_key);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----ResourceWaiter": "function ResourceWaiter(name, waiter, options) {\n    options = options || {};\n    property(this, \"name\", name);\n    property(this, \"api\", options.api, false);\n    if (waiter.operation) {\n        property(this, \"operation\", util.string.lowerFirst(waiter.operation));\n    }\n    var self = this;\n    var keys = [ \"type\", \"description\", \"delay\", \"maxAttempts\", \"acceptors\" ];\n    keys.forEach(function(key) {\n        var value = waiter[key];\n        if (value) {\n            property(self, key, value);\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----LRUCache": "function LRUCache(size) {\n    this.nodeMap = {};\n    this.size = 0;\n    if (typeof size !== \"number\" || size < 1) {\n        throw new Error(\"Cache size can only be positive number\");\n    }\n    this.sizeLimit = size;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----generateRegionPrefix": "function generateRegionPrefix(region) {\n    if (!region) return null;\n    var parts = region.split(\"-\");\n    if (parts.length < 3) return null;\n    return parts.slice(0, parts.length - 2).join(\"-\") + \"-*\";\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----derivedKeys": "function derivedKeys(service) {\n    var region = service.config.region;\n    var regionPrefix = generateRegionPrefix(region);\n    var endpointPrefix = service.api.endpointPrefix;\n    return [ [ region, endpointPrefix ], [ regionPrefix, endpointPrefix ], [ region, \"*\" ], [ regionPrefix, \"*\" ], [ \"*\", endpointPrefix ], [ \"*\", \"*\" ] ].map(function(item) {\n        return item[0] && item[1] ? item.join(\"/\") : null;\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----configureEndpoint": "function configureEndpoint(service) {\n    var keys = derivedKeys(service);\n    var useFipsEndpoint = service.config.useFipsEndpoint;\n    var useDualstackEndpoint = service.config.useDualstackEndpoint;\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!key) continue;\n        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;\n        if (Object.prototype.hasOwnProperty.call(rules, key)) {\n            var config = rules[key];\n            if (typeof config === \"string\") {\n                config = regionConfig.patterns[config];\n            }\n            service.isGlobalEndpoint = !!config.globalEndpoint;\n            if (config.signingRegion) {\n                service.signingRegion = config.signingRegion;\n            }\n            if (!config.signatureVersion) config.signatureVersion = \"v4\";\n            applyConfig(service, config);\n            return;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----getEndpointSuffix": "function getEndpointSuffix(region) {\n    var regionRegexes = {\n        \"^(us|eu|ap|sa|ca|me)\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^cn\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com.cn\",\n        \"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\": \"c2s.ic.gov\",\n        \"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\": \"sc2s.sgov.gov\"\n    };\n    var defaultSuffix = \"amazonaws.com\";\n    var regexes = Object.keys(regionRegexes);\n    for (var i = 0; i < regexes.length; i++) {\n        var regionPattern = RegExp(regexes[i]);\n        var dnsSuffix = regionRegexes[regexes[i]];\n        if (regionPattern.test(region)) return dnsSuffix;\n    }\n    return defaultSuffix;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----resolveNext": "function resolveNext(err, creds) {\n    if (!err && creds || index === providers.length) {\n        AWS.util.arrayEach(self.resolveCallbacks, function(callback) {\n            callback(err, creds);\n        });\n        self.resolveCallbacks.length = 0;\n        return;\n    }\n    var provider = providers[index++];\n    if (typeof provider === \"function\") {\n        creds = provider.call();\n    } else {\n        creds = provider;\n    }\n    if (creds.get) {\n        creds.get(function(getErr) {\n            resolveNext(getErr, getErr ? null : creds);\n        });\n    } else {\n        resolveNext(null, creds);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----callback": "function callback(httpResp) {\n    resp.httpResponse.stream = httpResp;\n    var stream = resp.request.httpRequest.stream;\n    var service = resp.request.service;\n    var api = service.api;\n    var operationName = resp.request.operation;\n    var operation = api.operations[operationName] || {};\n    httpResp.on(\"headers\", function onHeaders(statusCode, headers, statusMessage) {\n        resp.request.emit(\"httpHeaders\", [ statusCode, headers, resp, statusMessage ]);\n        if (!resp.httpResponse.streaming) {\n            if (AWS.HttpClient.streamsApiVersion === 2) {\n                if (operation.hasEventOutput && service.successfulResponse(resp)) {\n                    resp.request.emit(\"httpDone\");\n                    done();\n                    return;\n                }\n                httpResp.on(\"readable\", function onReadable() {\n                    var data = httpResp.read();\n                    if (data !== null) {\n                        resp.request.emit(\"httpData\", [ data, resp ]);\n                    }\n                });\n            } else {\n                httpResp.on(\"data\", function onData(data) {\n                    resp.request.emit(\"httpData\", [ data, resp ]);\n                });\n            }\n        }\n    });\n    httpResp.on(\"end\", function onEnd() {\n        if (!stream || !stream.didCallback) {\n            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {\n                return;\n            }\n            resp.request.emit(\"httpDone\");\n            done();\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----buildMessage": "function buildMessage() {\n    var time = resp.request.service.getSkewCorrectedDate().getTime();\n    var delta = (time - req.startTime.getTime()) / 1e3;\n    var ansi = logger.isTTY ? true : false;\n    var status = resp.httpResponse.statusCode;\n    var censoredParams = req.params;\n    if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {\n        var inputShape = req.service.api.operations[req.operation].input;\n        censoredParams = filterSensitiveLog(inputShape, req.params);\n    }\n    var params = __webpack_require__(52).inspect(censoredParams, true, null);\n    var message = \"\";\n    if (ansi) message += \"\u001b[33m\";\n    message += \"[AWS \" + req.service.serviceIdentifier + \" \" + status;\n    message += \" \" + delta.toString() + \"s \" + resp.retryCount + \" retries]\";\n    if (ansi) message += \"\u001b[0;1m\";\n    message += \" \" + AWS.util.string.lowerFirst(req.operation);\n    message += \"(\" + params + \")\";\n    if (ansi) message += \"\u001b[0m\";\n    return message;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----getCacheKey": "function getCacheKey(request) {\n    var service = request.service;\n    var api = service.api || {};\n    var operations = api.operations;\n    var identifiers = {};\n    if (service.config.region) {\n        identifiers.region = service.config.region;\n    }\n    if (api.serviceId) {\n        identifiers.serviceId = api.serviceId;\n    }\n    if (service.config.credentials.accessKeyId) {\n        identifiers.accessKeyId = service.config.credentials.accessKeyId;\n    }\n    return identifiers;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----optionalDiscoverEndpoint": "function optionalDiscoverEndpoint(request) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var endpoints = AWS.endpointCache.get(cacheKey);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        addApiVersionHeader(endpointRequest);\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        endpointRequest.removeListener(\"retry\", AWS.EventListeners.Core.RETRY_CHECK);\n        AWS.endpointCache.put(cacheKey, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 1\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (data && data.Endpoints) {\n                AWS.endpointCache.put(cacheKey, data.Endpoints);\n            } else if (err) {\n                AWS.endpointCache.put(cacheKey, [ {\n                    Address: \"\",\n                    CachePeriodInMinutes: 1\n                } ]);\n            }\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----requiredDiscoverEndpoint": "function requiredDiscoverEndpoint(request, done) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n    var endpoints = AWS.endpointCache.get(cacheKeyStr);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n        requestQueue[cacheKeyStr].push({\n            request: request,\n            callback: done\n        });\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n        done();\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        addApiVersionHeader(endpointRequest);\n        AWS.endpointCache.put(cacheKeyStr, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 60\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (err) {\n                request.response.error = util.error(err, {\n                    retryable: false\n                });\n                AWS.endpointCache.remove(cacheKey);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.response.error = util.error(err, {\n                            retryable: false\n                        });\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            } else if (data) {\n                AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n                request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            }\n            done();\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----hasCustomEndpoint": "function hasCustomEndpoint(client) {\n    if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n        throw util.error(new Error(), {\n            code: \"ConfigurationException\",\n            message: \"Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.\"\n        });\n    }\n    var svcConfig = AWS.config[client.serviceIdentifier] || {};\n    return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----resolveEndpointDiscoveryConfig": "function resolveEndpointDiscoveryConfig(request) {\n    var service = request.service || {};\n    if (service.config.endpointDiscoveryEnabled !== undefined) {\n        return service.config.endpointDiscoveryEnabled;\n    }\n    if (util.isBrowser()) return undefined;\n    for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n        var env = endpointDiscoveryEnabledEnvs[i];\n        if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n            if (process.env[env] === \"\" || process.env[env] === undefined) {\n                throw util.error(new Error(), {\n                    code: \"ConfigurationException\",\n                    message: \"environmental variable \" + env + \" cannot be set to nothing\"\n                });\n            }\n            return !isFalsy(process.env[env]);\n        }\n    }\n    var configFile = {};\n    try {\n        configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n            isConfig: true,\n            filename: process.env[AWS.util.sharedConfigFileEnv]\n        }) : {};\n    } catch (e) {}\n    var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};\n    if (Object.prototype.hasOwnProperty.call(sharedFileConfig, \"endpoint_discovery_enabled\")) {\n        if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n            throw util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"config file entry 'endpoint_discovery_enabled' cannot be set to nothing\"\n            });\n        }\n        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);\n    }\n    return undefined;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----discoverEndpoint": "function discoverEndpoint(request, done) {\n    var service = request.service || {};\n    if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n    var operations = service.api.operations || {};\n    var operationModel = operations[request.operation];\n    var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : \"NULL\";\n    var isEnabled = resolveEndpointDiscoveryConfig(request);\n    var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;\n    if (isEnabled || hasRequiredEndpointDiscovery) {\n        request.httpRequest.appendToUserAgent(\"endpoint-discovery\");\n    }\n    switch (isEndpointDiscoveryRequired) {\n      case \"OPTIONAL\":\n        if (isEnabled || hasRequiredEndpointDiscovery) {\n            optionalDiscoverEndpoint(request);\n            request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        }\n        done();\n        break;\n\n      case \"REQUIRED\":\n        if (isEnabled === false) {\n            request.response.error = util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"Endpoint Discovery is disabled but \" + service.api.className + \".\" + request.operation + \"() requires it. Please check your configurations.\"\n            });\n            done();\n            break;\n        }\n        request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        requiredDiscoverEndpoint(request, done);\n        break;\n\n      case \"NULL\":\n      default:\n        done();\n        break;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----inspect": "function inspect(obj, opts) {\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n    } else if (opts) {\n        exports._extend(ctx, opts);\n    }\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----formatValue": "function formatValue(ctx, value, recurseTimes) {\n    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n    if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n    }\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? \": \" + value.name : \"\";\n            return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n    }\n    var base = \"\", array = false, braces = [ \"{\", \"}\" ];\n    if (isArray(value)) {\n        array = true;\n        braces = [ \"[\", \"]\" ];\n    }\n    if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n    }\n    if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n    }\n    if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n    }\n    if (isError(value)) {\n        base = \" \" + formatError(value);\n    }\n    if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n    }\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n            return ctx.stylize(\"[Object]\", \"special\");\n        }\n    }\n    ctx.seen.push(value);\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function(key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----formatPrimitive": "function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n    if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n    }\n    if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n    if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n    if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----formatArray": "function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n            output.push(\"\");\n        }\n    }\n    keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n    });\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----formatProperty": "function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {\n        value: value[key]\n    };\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n            str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf(\"\\n\") > -1) {\n                if (array) {\n                    str = str.split(\"\\n\").map(function(line) {\n                        return \"  \" + line;\n                    }).join(\"\\n\").substr(2);\n                } else {\n                    str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                        return \"   \" + line;\n                    }).join(\"\\n\");\n                }\n            }\n        } else {\n            str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, \"name\");\n        } else {\n            name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, \"string\");\n        }\n    }\n    return name + \": \" + str;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----reduceToSingleString": "function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n    }, 0);\n    if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n    }\n    return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----fn": "function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function(resolve, reject) {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    });\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n    }\n    args.push(function(err, value) {\n        if (err) {\n            promiseReject(err);\n        } else {\n            promiseResolve(value);\n        }\n    });\n    try {\n        original.apply(this, args);\n    } catch (err) {\n        promiseReject(err);\n    }\n    return promise;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----callbackify": "function callbackify(original) {\n    if (typeof original !== \"function\") {\n        throw new TypeError('The \"original\" argument must be of type Function');\n    }\n    function callbackified() {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        var maybeCb = args.pop();\n        if (typeof maybeCb !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n        }\n        var self = this;\n        var cb = function() {\n            return maybeCb.apply(self, arguments);\n        };\n        original.apply(this, args).then(function(ret) {\n            process.nextTick(cb.bind(null, null, ret));\n        }, function(rej) {\n            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));\n        });\n    }\n    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));\n    return callbackified;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----wrappedCallback": "function wrappedCallback(err, data) {\n    if (err) return callback(err, null);\n    if (data === null) return callback(null, null);\n    var config = self.service.paginationConfig(self.operation);\n    var resultKey = config.resultKey;\n    if (Array.isArray(resultKey)) resultKey = resultKey[0];\n    var items = jmespath.search(data, resultKey);\n    var continueIteration = true;\n    AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n            return AWS.util.abort;\n        }\n    });\n    return continueIteration;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----strictDeepEqual": "function strictDeepEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n        return false;\n    }\n    if (isArray(first) === true) {\n        if (first.length !== second.length) {\n            return false;\n        }\n        for (var i = 0; i < first.length; i++) {\n            if (strictDeepEqual(first[i], second[i]) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (isObject(first) === true) {\n        var keysSeen = {};\n        for (var key in first) {\n            if (hasOwnProperty.call(first, key)) {\n                if (strictDeepEqual(first[key], second[key]) === false) {\n                    return false;\n                }\n                keysSeen[key] = true;\n            }\n        }\n        for (var key2 in second) {\n            if (hasOwnProperty.call(second, key2)) {\n                if (keysSeen[key2] !== true) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----objValues": "function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n    }\n    return values;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----merge": "function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n        merged[key] = a[key];\n    }\n    for (var key2 in b) {\n        merged[key2] = b[key2];\n    }\n    return merged;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----search": "function search(data, expression) {\n    var parser = new Parser();\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----CHECK_ACCEPTORS": "function CHECK_ACCEPTORS(resp) {\n    var waiter = resp.request._waiter;\n    var acceptors = waiter.config.acceptors;\n    var acceptorMatched = false;\n    var state = \"retry\";\n    acceptors.forEach(function(acceptor) {\n        if (!acceptorMatched) {\n            var matcher = waiter.matchers[acceptor.matcher];\n            if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n                acceptorMatched = true;\n                state = acceptor.state;\n            }\n        }\n    });\n    if (!acceptorMatched && resp.error) state = \"failure\";\n    if (state === \"success\") {\n        waiter.setSuccess(resp);\n    } else {\n        waiter.setError(resp, state === \"retry\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----signedUrlBuilder": "function signedUrlBuilder(request) {\n    var expires = request.httpRequest.headers[expiresHeader];\n    var signerClass = request.service.getSignerClass(request);\n    delete request.httpRequest.headers[\"User-Agent\"];\n    delete request.httpRequest.headers[\"X-Amz-User-Agent\"];\n    if (signerClass === AWS.Signers.V4) {\n        if (expires > 604800) {\n            var message = \"Presigning does not support expiry time greater \" + \"than a week with SigV4 signing.\";\n            throw AWS.util.error(new Error(), {\n                code: \"InvalidExpiryTime\",\n                message: message,\n                retryable: false\n            });\n        }\n        request.httpRequest.headers[expiresHeader] = expires;\n    } else if (signerClass === AWS.Signers.S3) {\n        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();\n        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();\n    } else {\n        throw AWS.util.error(new Error(), {\n            message: \"Presigning only supports S3 or SigV4 signing.\",\n            code: \"UnsupportedSigner\",\n            retryable: false\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-core-react-native----signedUrlSigner": "function signedUrlSigner(request) {\n    var endpoint = request.httpRequest.endpoint;\n    var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n    var queryParams = {};\n    if (parsedUrl.search) {\n        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n    }\n    var auth = request.httpRequest.headers[\"Authorization\"].split(\" \");\n    if (auth[0] === \"AWS\") {\n        auth = auth[1].split(\":\");\n        queryParams[\"Signature\"] = auth.pop();\n        queryParams[\"AWSAccessKeyId\"] = auth.join(\":\");\n        AWS.util.each(request.httpRequest.headers, function(key, value) {\n            if (key === expiresHeader) key = \"Expires\";\n            if (key.indexOf(\"x-amz-meta-\") === 0) {\n                delete queryParams[key];\n                key = key.toLowerCase();\n            }\n            queryParams[key] = value;\n        });\n        delete request.httpRequest.headers[expiresHeader];\n        delete queryParams[\"Authorization\"];\n        delete queryParams[\"Host\"];\n    } else if (auth[0] === \"AWS4-HMAC-SHA256\") {\n        auth.shift();\n        var rest = auth.join(\" \");\n        var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n        queryParams[\"X-Amz-Signature\"] = signature;\n        delete queryParams[\"Expires\"];\n    }\n    endpoint.pathname = parsedUrl.pathname;\n    endpoint.search = AWS.util.queryParamsToString(queryParams);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----__webpack_require__": "function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = installedModules[moduleId] = {\n        exports: {},\n        id: moduleId,\n        loaded: false\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    module.loaded = true;\n    return module.exports;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----cleanUpNextTick": "function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----drainQueue": "function drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----setImmediate": "function setImmediate(callback) {\n    if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n    }\n    var args = new Array(arguments.length - 1);\n    for (var i = 0; i < args.length; i++) {\n        args[i] = arguments[i + 1];\n    }\n    var task = {\n        callback: callback,\n        args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----installPostMessageImplementation": "function installPostMessageImplementation() {\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n    var onGlobalMessage = function(event) {\n        if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n            runIfPresent(+event.data.slice(messagePrefix.length));\n        }\n    };\n    if (global.addEventListener) {\n        global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n        global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n    registerImmediate = function(handle) {\n        global.postMessage(messagePrefix + handle, \"*\");\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || _rng.default)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : (0, _bytesToUuid.default)(b);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----_default": "function _default(name, version, hashfunc) {\n    var generateUUID = function(value, namespace, buf, offset) {\n        var off = buf && offset || 0;\n        if (typeof value == \"string\") value = stringToBytes(value);\n        if (typeof namespace == \"string\") namespace = uuidToBytes(namespace);\n        if (!Array.isArray(value)) throw TypeError(\"value must be an array of bytes\");\n        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError(\"namespace must be uuid string or an Array of 16 byte values\");\n        var bytes = hashfunc(namespace.concat(value));\n        bytes[6] = bytes[6] & 15 | version;\n        bytes[8] = bytes[8] & 63 | 128;\n        if (buf) {\n            for (var idx = 0; idx < 16; ++idx) {\n                buf[off + idx] = bytes[idx];\n            }\n        }\n        return buf || (0, _bytesToUuid.default)(bytes);\n    };\n    try {\n        generateUUID.name = name;\n    } catch (err) {}\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----md5ToHexEncodedArray": "function md5ToHexEncodedArray(input) {\n    var i;\n    var x;\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    var hex;\n    for (i = 0; i < length32; i += 8) {\n        x = input[i >> 5] >>> i % 32 & 255;\n        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n        output.push(hex);\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----wordsToMd5": "function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var i;\n    var olda;\n    var oldb;\n    var oldc;\n    var oldd;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [ a, b, c, d ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----bytesToWords": "function bytesToWords(input) {\n    var i;\n    var output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    var length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || _rng.default)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || (0, _bytesToUuid.default)(rnds);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----sha1": "function sha1(bytes) {\n    var K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof bytes == \"string\") {\n        var msg = unescape(encodeURIComponent(bytes));\n        bytes = new Array(msg.length);\n        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {\n            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n        }\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var i = 0; i < N; i++) {\n        var W = new Array(80);\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 80; t++) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        var a = H[0];\n        var b = H[1];\n        var c = H[2];\n        var d = H[3];\n        var e = H[4];\n        for (var t = 0; t < 80; t++) {\n            var s = Math.floor(t / 20);\n            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = H[0] + a >>> 0;\n        H[1] = H[1] + b >>> 0;\n        H[2] = H[2] + c >>> 0;\n        H[3] = H[3] + d >>> 0;\n        H[4] = H[4] + e >>> 0;\n    }\n    return [ H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255 ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----buildRequest": "function buildRequest(req) {\n    populateMethod(req);\n    populateURI(req);\n    populateHeaders(req);\n    populateHostPrefix(req);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----extractError": "function extractError(resp) {\n    Rest.extractError(resp);\n    var data;\n    try {\n        data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());\n    } catch (e) {\n        data = {\n            Code: resp.httpResponse.statusCode,\n            Message: resp.httpResponse.statusMessage\n        };\n    }\n    if (data.Errors) data = data.Errors;\n    if (data.Error) data = data.Error;\n    if (data.Code) {\n        resp.error = util.error(new Error(), {\n            code: data.Code,\n            message: data.Message\n        });\n    } else {\n        resp.error = util.error(new Error(), {\n            code: resp.httpResponse.statusCode,\n            message: null\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----translateStructure": "function translateStructure(structure, shape) {\n    if (structure == null) return undefined;\n    if (shape.isDocument) return structure;\n    var struct = {};\n    var shapeMembers = shape.members;\n    util.each(shapeMembers, function(name, memberShape) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n            var value = structure[locationName];\n            var result = translate(value, memberShape);\n            if (result !== undefined) struct[name] = result;\n        }\n    });\n    return struct;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----translateList": "function translateList(list, shape) {\n    if (list == null) return undefined;\n    var out = [];\n    util.arrayEach(list, function(value) {\n        var result = translate(value, shape.member);\n        if (result === undefined) out.push(null); else out.push(result);\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----translateMap": "function translateMap(map, shape) {\n    if (map == null) return undefined;\n    var out = {};\n    util.each(map, function(key, value) {\n        var result = translate(value, shape.value);\n        if (result === undefined) out[key] = null; else out[key] = result;\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----populateHostPrefix": "function populateHostPrefix(request) {\n    var enabled = request.service.config.hostPrefixEnabled;\n    if (!enabled) return request;\n    var operationModel = request.service.api.operations[request.operation];\n    if (hasEndpointDiscover(request)) return request;\n    if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {\n        var hostPrefixNotation = operationModel.endpoint.hostPrefix;\n        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);\n        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);\n        validateHostname(request.httpRequest.endpoint.hostname);\n    }\n    return request;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----hasEndpointDiscover": "function hasEndpointDiscover(request) {\n    var api = request.service.api;\n    var operationModel = api.operations[request.operation];\n    var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);\n    return operationModel.endpointDiscoveryRequired !== \"NULL\" || isEndpointOperation === true;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----extractData": "function extractData(resp) {\n    Rest.extractData(resp);\n    var parser;\n    var req = resp.request;\n    var body = resp.httpResponse.body;\n    var operation = req.service.api.operations[req.operation];\n    var output = operation.output;\n    var hasEventOutput = operation.hasEventOutput;\n    var payload = output.payload;\n    if (payload) {\n        var payloadMember = output.members[payload];\n        if (payloadMember.isEventStream) {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);\n        } else if (payloadMember.type === \"structure\") {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = parser.parse(body.toString(), payloadMember);\n        } else if (payloadMember.type === \"binary\" || payloadMember.isStreaming) {\n            resp.data[payload] = body;\n        } else {\n            resp.data[payload] = payloadMember.toType(body);\n        }\n    } else if (body.length > 0) {\n        parser = new AWS.XML.Parser();\n        var data = parser.parse(body.toString(), output);\n        util.update(resp.data, data);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Shape": "function Shape(shape, options, memberName) {\n    options = options || {};\n    property(this, \"shape\", shape.shape);\n    property(this, \"api\", options.api, false);\n    property(this, \"type\", shape.type);\n    property(this, \"enum\", shape.enum);\n    property(this, \"min\", shape.min);\n    property(this, \"max\", shape.max);\n    property(this, \"pattern\", shape.pattern);\n    property(this, \"location\", shape.location || this.location || \"body\");\n    property(this, \"name\", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);\n    property(this, \"isStreaming\", shape.streaming || this.isStreaming || false);\n    property(this, \"requiresLength\", shape.requiresLength, false);\n    property(this, \"isComposite\", shape.isComposite || false);\n    property(this, \"isShape\", true, false);\n    property(this, \"isQueryName\", Boolean(shape.queryName), false);\n    property(this, \"isLocationName\", Boolean(shape.locationName), false);\n    property(this, \"isIdempotent\", shape.idempotencyToken === true);\n    property(this, \"isJsonValue\", shape.jsonvalue === true);\n    property(this, \"isSensitive\", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);\n    property(this, \"isEventStream\", Boolean(shape.eventstream), false);\n    property(this, \"isEvent\", Boolean(shape.event), false);\n    property(this, \"isEventPayload\", Boolean(shape.eventpayload), false);\n    property(this, \"isEventHeader\", Boolean(shape.eventheader), false);\n    property(this, \"isTimestampFormatSet\", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);\n    property(this, \"endpointDiscoveryId\", Boolean(shape.endpointdiscoveryid), false);\n    property(this, \"hostLabel\", Boolean(shape.hostLabel), false);\n    if (options.documentation) {\n        property(this, \"documentation\", shape.documentation);\n        property(this, \"documentationUrl\", shape.documentationUrl);\n    }\n    if (shape.xmlAttribute) {\n        property(this, \"isXmlAttribute\", shape.xmlAttribute || false);\n    }\n    property(this, \"defaultValue\", null);\n    this.toWireFormat = function(value) {\n        if (value === null || value === undefined) return \"\";\n        return value;\n    };\n    this.toType = function(value) {\n        return value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----StructureShape": "function StructureShape(shape, options) {\n    var self = this;\n    var requiredMap = null, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"members\", {});\n        property(this, \"memberNames\", []);\n        property(this, \"required\", []);\n        property(this, \"isRequired\", function() {\n            return false;\n        });\n        property(this, \"isDocument\", Boolean(shape.document));\n    }\n    if (shape.members) {\n        property(this, \"members\", new Collection(shape.members, options, function(name, member) {\n            return Shape.create(member, options, name);\n        }));\n        memoizedProperty(this, \"memberNames\", function() {\n            return shape.xmlOrder || Object.keys(shape.members);\n        });\n        if (shape.event) {\n            memoizedProperty(this, \"eventPayloadMemberName\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventPayload) {\n                        return memberNames[i];\n                    }\n                }\n            });\n            memoizedProperty(this, \"eventHeaderMemberNames\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                var eventHeaderMemberNames = [];\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventHeader) {\n                        eventHeaderMemberNames.push(memberNames[i]);\n                    }\n                }\n                return eventHeaderMemberNames;\n            });\n        }\n    }\n    if (shape.required) {\n        property(this, \"required\", shape.required);\n        property(this, \"isRequired\", function(name) {\n            if (!requiredMap) {\n                requiredMap = {};\n                for (var i = 0; i < shape.required.length; i++) {\n                    requiredMap[shape.required[i]] = true;\n                }\n            }\n            return requiredMap[name];\n        }, false, true);\n    }\n    property(this, \"resultWrapper\", shape.resultWrapper || null);\n    if (shape.payload) {\n        property(this, \"payload\", shape.payload);\n    }\n    if (typeof shape.xmlNamespace === \"string\") {\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace);\n    } else if (typeof shape.xmlNamespace === \"object\") {\n        property(this, \"xmlNamespacePrefix\", shape.xmlNamespace.prefix);\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace.uri);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----ListShape": "function ListShape(shape, options) {\n    var self = this, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return [];\n        });\n    }\n    if (shape.member) {\n        memoizedProperty(this, \"member\", function() {\n            return Shape.create(shape.member, options);\n        });\n    }\n    if (this.flattened) {\n        var oldName = this.name;\n        memoizedProperty(this, \"name\", function() {\n            return self.member.name || oldName;\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----MapShape": "function MapShape(shape, options) {\n    var firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"key\", Shape.create({\n            type: \"string\"\n        }, options));\n        property(this, \"value\", Shape.create({\n            type: \"string\"\n        }, options));\n    }\n    if (shape.key) {\n        memoizedProperty(this, \"key\", function() {\n            return Shape.create(shape.key, options);\n        });\n    }\n    if (shape.value) {\n        memoizedProperty(this, \"value\", function() {\n            return Shape.create(shape.value, options);\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----TimestampShape": "function TimestampShape(shape) {\n    var self = this;\n    Shape.apply(this, arguments);\n    if (shape.timestampFormat) {\n        property(this, \"timestampFormat\", shape.timestampFormat);\n    } else if (self.isTimestampFormatSet && this.timestampFormat) {\n        property(this, \"timestampFormat\", this.timestampFormat);\n    } else if (this.location === \"header\") {\n        property(this, \"timestampFormat\", \"rfc822\");\n    } else if (this.location === \"querystring\") {\n        property(this, \"timestampFormat\", \"iso8601\");\n    } else if (this.api) {\n        switch (this.api.protocol) {\n          case \"json\":\n          case \"rest-json\":\n            property(this, \"timestampFormat\", \"unixTimestamp\");\n            break;\n\n          case \"rest-xml\":\n          case \"query\":\n          case \"ec2\":\n            property(this, \"timestampFormat\", \"iso8601\");\n            break;\n        }\n    }\n    this.toType = function(value) {\n        if (value === null || value === undefined) return null;\n        if (typeof value.toUTCString === \"function\") return value;\n        return typeof value === \"string\" || typeof value === \"number\" ? util.date.parseTimestamp(value) : null;\n    };\n    this.toWireFormat = function(value) {\n        return util.date.format(value, self.timestampFormat);\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----StringShape": "function StringShape() {\n    Shape.apply(this, arguments);\n    var nullLessProtocols = [ \"rest-xml\", \"query\", \"ec2\" ];\n    this.toType = function(value) {\n        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || \"\" : value;\n        if (this.isJsonValue) {\n            return JSON.parse(value);\n        }\n        return value && typeof value.toString === \"function\" ? value.toString() : value;\n    };\n    this.toWireFormat = function(value) {\n        return this.isJsonValue ? JSON.stringify(value) : value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----generateURI": "function generateURI(endpointPath, operationPath, input, params) {\n    var uri = [ endpointPath, operationPath ].join(\"/\");\n    uri = uri.replace(/\\/+/g, \"/\");\n    var queryString = {}, queryStringSet = false;\n    util.each(input.members, function(name, member) {\n        var paramValue = params[name];\n        if (paramValue === null || paramValue === undefined) return;\n        if (member.location === \"uri\") {\n            var regex = new RegExp(\"\\\\{\" + member.name + \"(\\\\+)?\\\\}\");\n            uri = uri.replace(regex, function(_, plus) {\n                var fn = plus ? util.uriEscapePath : util.uriEscape;\n                return fn(String(paramValue));\n            });\n        } else if (member.location === \"querystring\") {\n            queryStringSet = true;\n            if (member.type === \"list\") {\n                queryString[member.name] = paramValue.map(function(val) {\n                    return util.uriEscape(member.member.toWireFormat(val).toString());\n                });\n            } else if (member.type === \"map\") {\n                util.each(paramValue, function(key, value) {\n                    if (Array.isArray(value)) {\n                        queryString[key] = value.map(function(val) {\n                            return util.uriEscape(String(val));\n                        });\n                    } else {\n                        queryString[key] = util.uriEscape(String(value));\n                    }\n                });\n            } else {\n                queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());\n            }\n        }\n    });\n    if (queryStringSet) {\n        uri += uri.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n        var parts = [];\n        util.arrayEach(Object.keys(queryString).sort(), function(key) {\n            if (!Array.isArray(queryString[key])) {\n                queryString[key] = [ queryString[key] ];\n            }\n            for (var i = 0; i < queryString[key].length; i++) {\n                parts.push(util.uriEscape(String(key)) + \"=\" + queryString[key][i]);\n            }\n        });\n        uri += parts.join(\"&\");\n    }\n    return uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----populateURI": "function populateURI(req) {\n    var operation = req.service.api.operations[req.operation];\n    var input = operation.input;\n    var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);\n    req.httpRequest.path = uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----populateBody": "function populateBody(req) {\n    var input = req.service.api.operations[req.operation].input;\n    var builder = new AWS.XML.Builder();\n    var params = req.params;\n    var payload = input.payload;\n    if (payload) {\n        var payloadMember = input.members[payload];\n        params = params[payload];\n        if (params === undefined) return;\n        if (payloadMember.type === \"structure\") {\n            var rootElement = payloadMember.name;\n            req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n        } else {\n            req.httpRequest.body = params;\n        }\n    } else {\n        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + \"Request\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XmlNode": "function XmlNode(name, children) {\n    if (children === void 0) {\n        children = [];\n    }\n    this.name = name;\n    this.children = children;\n    this.attributes = {};\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Api": "function Api(api, options) {\n    var self = this;\n    api = api || {};\n    options = options || {};\n    options.api = this;\n    api.metadata = api.metadata || {};\n    var serviceIdentifier = options.serviceIdentifier;\n    delete options.serviceIdentifier;\n    property(this, \"isApi\", true, false);\n    property(this, \"apiVersion\", api.metadata.apiVersion);\n    property(this, \"endpointPrefix\", api.metadata.endpointPrefix);\n    property(this, \"signingName\", api.metadata.signingName);\n    property(this, \"globalEndpoint\", api.metadata.globalEndpoint);\n    property(this, \"signatureVersion\", api.metadata.signatureVersion);\n    property(this, \"jsonVersion\", api.metadata.jsonVersion);\n    property(this, \"targetPrefix\", api.metadata.targetPrefix);\n    property(this, \"protocol\", api.metadata.protocol);\n    property(this, \"timestampFormat\", api.metadata.timestampFormat);\n    property(this, \"xmlNamespaceUri\", api.metadata.xmlNamespace);\n    property(this, \"abbreviation\", api.metadata.serviceAbbreviation);\n    property(this, \"fullName\", api.metadata.serviceFullName);\n    property(this, \"serviceId\", api.metadata.serviceId);\n    if (serviceIdentifier && metadata[serviceIdentifier]) {\n        property(this, \"xmlNoDefaultLists\", metadata[serviceIdentifier].xmlNoDefaultLists, false);\n    }\n    memoizedProperty(this, \"className\", function() {\n        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;\n        if (!name) return null;\n        name = name.replace(/^Amazon|AWS\\s*|\\(.*|\\s+|\\W+/g, \"\");\n        if (name === \"ElasticLoadBalancing\") name = \"ELB\";\n        return name;\n    });\n    function addEndpointOperation(name, operation) {\n        if (operation.endpointoperation === true) {\n            property(self, \"endpointOperation\", util.string.lowerFirst(name));\n        }\n        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {\n            property(self, \"hasRequiredEndpointDiscovery\", operation.endpointdiscovery.required === true);\n        }\n    }\n    property(this, \"operations\", new Collection(api.operations, options, function(name, operation) {\n        return new Operation(name, operation, options);\n    }, util.string.lowerFirst, addEndpointOperation));\n    property(this, \"shapes\", new Collection(api.shapes, options, function(name, shape) {\n        return Shape.create(shape, options);\n    }));\n    property(this, \"paginators\", new Collection(api.paginators, options, function(name, paginator) {\n        return new Paginator(name, paginator, options);\n    }));\n    property(this, \"waiters\", new Collection(api.waiters, options, function(name, waiter) {\n        return new ResourceWaiter(name, waiter, options);\n    }, util.string.lowerFirst));\n    if (options.documentation) {\n        property(this, \"documentation\", api.documentation);\n        property(this, \"documentationUrl\", api.documentationUrl);\n    }\n    property(this, \"errorCodeMapping\", api.awsQueryCompatible);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Operation": "function Operation(name, operation, options) {\n    var self = this;\n    options = options || {};\n    property(this, \"name\", operation.name || name);\n    property(this, \"api\", options.api, false);\n    operation.http = operation.http || {};\n    property(this, \"endpoint\", operation.endpoint);\n    property(this, \"httpMethod\", operation.http.method || \"POST\");\n    property(this, \"httpPath\", operation.http.requestUri || \"/\");\n    property(this, \"authtype\", operation.authtype || \"\");\n    property(this, \"endpointDiscoveryRequired\", operation.endpointdiscovery ? operation.endpointdiscovery.required ? \"REQUIRED\" : \"OPTIONAL\" : \"NULL\");\n    var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;\n    property(this, \"httpChecksumRequired\", httpChecksumRequired, false);\n    memoizedProperty(this, \"input\", function() {\n        if (!operation.input) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.input, options);\n    });\n    memoizedProperty(this, \"output\", function() {\n        if (!operation.output) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.output, options);\n    });\n    memoizedProperty(this, \"errors\", function() {\n        var list = [];\n        if (!operation.errors) return null;\n        for (var i = 0; i < operation.errors.length; i++) {\n            list.push(Shape.create(operation.errors[i], options));\n        }\n        return list;\n    });\n    memoizedProperty(this, \"paginator\", function() {\n        return options.api.paginators[name];\n    });\n    if (options.documentation) {\n        property(this, \"documentation\", operation.documentation);\n        property(this, \"documentationUrl\", operation.documentationUrl);\n    }\n    memoizedProperty(this, \"idempotentMembers\", function() {\n        var idempotentMembers = [];\n        var input = self.input;\n        var members = input.members;\n        if (!input.members) {\n            return idempotentMembers;\n        }\n        for (var name in members) {\n            if (!members.hasOwnProperty(name)) {\n                continue;\n            }\n            if (members[name].isIdempotent === true) {\n                idempotentMembers.push(name);\n            }\n        }\n        return idempotentMembers;\n    });\n    memoizedProperty(this, \"hasEventOutput\", function() {\n        var output = self.output;\n        return hasEventStream(output);\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----hasEventStream": "function hasEventStream(topLevelShape) {\n    var members = topLevelShape.members;\n    var payload = topLevelShape.payload;\n    if (!topLevelShape.members) {\n        return false;\n    }\n    if (payload) {\n        var payloadMember = members[payload];\n        return payloadMember.isEventStream;\n    }\n    for (var name in members) {\n        if (!members.hasOwnProperty(name)) {\n            if (members[name].isEventStream === true) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Paginator": "function Paginator(name, paginator) {\n    property(this, \"inputToken\", paginator.input_token);\n    property(this, \"limitKey\", paginator.limit_key);\n    property(this, \"moreResults\", paginator.more_results);\n    property(this, \"outputToken\", paginator.output_token);\n    property(this, \"resultKey\", paginator.result_key);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----ResourceWaiter": "function ResourceWaiter(name, waiter, options) {\n    options = options || {};\n    property(this, \"name\", name);\n    property(this, \"api\", options.api, false);\n    if (waiter.operation) {\n        property(this, \"operation\", util.string.lowerFirst(waiter.operation));\n    }\n    var self = this;\n    var keys = [ \"type\", \"description\", \"delay\", \"maxAttempts\", \"acceptors\" ];\n    keys.forEach(function(key) {\n        var value = waiter[key];\n        if (value) {\n            property(self, key, value);\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----LRUCache": "function LRUCache(size) {\n    this.nodeMap = {};\n    this.size = 0;\n    if (typeof size !== \"number\" || size < 1) {\n        throw new Error(\"Cache size can only be positive number\");\n    }\n    this.sizeLimit = size;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----generateRegionPrefix": "function generateRegionPrefix(region) {\n    if (!region) return null;\n    var parts = region.split(\"-\");\n    if (parts.length < 3) return null;\n    return parts.slice(0, parts.length - 2).join(\"-\") + \"-*\";\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----derivedKeys": "function derivedKeys(service) {\n    var region = service.config.region;\n    var regionPrefix = generateRegionPrefix(region);\n    var endpointPrefix = service.api.endpointPrefix;\n    return [ [ region, endpointPrefix ], [ regionPrefix, endpointPrefix ], [ region, \"*\" ], [ regionPrefix, \"*\" ], [ \"*\", endpointPrefix ], [ \"*\", \"*\" ] ].map(function(item) {\n        return item[0] && item[1] ? item.join(\"/\") : null;\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----configureEndpoint": "function configureEndpoint(service) {\n    var keys = derivedKeys(service);\n    var useFipsEndpoint = service.config.useFipsEndpoint;\n    var useDualstackEndpoint = service.config.useDualstackEndpoint;\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!key) continue;\n        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;\n        if (Object.prototype.hasOwnProperty.call(rules, key)) {\n            var config = rules[key];\n            if (typeof config === \"string\") {\n                config = regionConfig.patterns[config];\n            }\n            service.isGlobalEndpoint = !!config.globalEndpoint;\n            if (config.signingRegion) {\n                service.signingRegion = config.signingRegion;\n            }\n            if (!config.signatureVersion) config.signatureVersion = \"v4\";\n            applyConfig(service, config);\n            return;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----getEndpointSuffix": "function getEndpointSuffix(region) {\n    var regionRegexes = {\n        \"^(us|eu|ap|sa|ca|me)\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^cn\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com.cn\",\n        \"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\": \"c2s.ic.gov\",\n        \"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\": \"sc2s.sgov.gov\"\n    };\n    var defaultSuffix = \"amazonaws.com\";\n    var regexes = Object.keys(regionRegexes);\n    for (var i = 0; i < regexes.length; i++) {\n        var regionPattern = RegExp(regexes[i]);\n        var dnsSuffix = regionRegexes[regexes[i]];\n        if (regionPattern.test(region)) return dnsSuffix;\n    }\n    return defaultSuffix;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----resolveNext": "function resolveNext(err, creds) {\n    if (!err && creds || index === providers.length) {\n        AWS.util.arrayEach(self.resolveCallbacks, function(callback) {\n            callback(err, creds);\n        });\n        self.resolveCallbacks.length = 0;\n        return;\n    }\n    var provider = providers[index++];\n    if (typeof provider === \"function\") {\n        creds = provider.call();\n    } else {\n        creds = provider;\n    }\n    if (creds.get) {\n        creds.get(function(getErr) {\n            resolveNext(getErr, getErr ? null : creds);\n        });\n    } else {\n        resolveNext(null, creds);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----callback": "function callback(httpResp) {\n    resp.httpResponse.stream = httpResp;\n    var stream = resp.request.httpRequest.stream;\n    var service = resp.request.service;\n    var api = service.api;\n    var operationName = resp.request.operation;\n    var operation = api.operations[operationName] || {};\n    httpResp.on(\"headers\", function onHeaders(statusCode, headers, statusMessage) {\n        resp.request.emit(\"httpHeaders\", [ statusCode, headers, resp, statusMessage ]);\n        if (!resp.httpResponse.streaming) {\n            if (AWS.HttpClient.streamsApiVersion === 2) {\n                if (operation.hasEventOutput && service.successfulResponse(resp)) {\n                    resp.request.emit(\"httpDone\");\n                    done();\n                    return;\n                }\n                httpResp.on(\"readable\", function onReadable() {\n                    var data = httpResp.read();\n                    if (data !== null) {\n                        resp.request.emit(\"httpData\", [ data, resp ]);\n                    }\n                });\n            } else {\n                httpResp.on(\"data\", function onData(data) {\n                    resp.request.emit(\"httpData\", [ data, resp ]);\n                });\n            }\n        }\n    });\n    httpResp.on(\"end\", function onEnd() {\n        if (!stream || !stream.didCallback) {\n            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {\n                return;\n            }\n            resp.request.emit(\"httpDone\");\n            done();\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----buildMessage": "function buildMessage() {\n    var time = resp.request.service.getSkewCorrectedDate().getTime();\n    var delta = (time - req.startTime.getTime()) / 1e3;\n    var ansi = logger.isTTY ? true : false;\n    var status = resp.httpResponse.statusCode;\n    var censoredParams = req.params;\n    if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {\n        var inputShape = req.service.api.operations[req.operation].input;\n        censoredParams = filterSensitiveLog(inputShape, req.params);\n    }\n    var params = __webpack_require__(52).inspect(censoredParams, true, null);\n    var message = \"\";\n    if (ansi) message += \"\u001b[33m\";\n    message += \"[AWS \" + req.service.serviceIdentifier + \" \" + status;\n    message += \" \" + delta.toString() + \"s \" + resp.retryCount + \" retries]\";\n    if (ansi) message += \"\u001b[0;1m\";\n    message += \" \" + AWS.util.string.lowerFirst(req.operation);\n    message += \"(\" + params + \")\";\n    if (ansi) message += \"\u001b[0m\";\n    return message;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----getCacheKey": "function getCacheKey(request) {\n    var service = request.service;\n    var api = service.api || {};\n    var operations = api.operations;\n    var identifiers = {};\n    if (service.config.region) {\n        identifiers.region = service.config.region;\n    }\n    if (api.serviceId) {\n        identifiers.serviceId = api.serviceId;\n    }\n    if (service.config.credentials.accessKeyId) {\n        identifiers.accessKeyId = service.config.credentials.accessKeyId;\n    }\n    return identifiers;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----optionalDiscoverEndpoint": "function optionalDiscoverEndpoint(request) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var endpoints = AWS.endpointCache.get(cacheKey);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        addApiVersionHeader(endpointRequest);\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        endpointRequest.removeListener(\"retry\", AWS.EventListeners.Core.RETRY_CHECK);\n        AWS.endpointCache.put(cacheKey, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 1\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (data && data.Endpoints) {\n                AWS.endpointCache.put(cacheKey, data.Endpoints);\n            } else if (err) {\n                AWS.endpointCache.put(cacheKey, [ {\n                    Address: \"\",\n                    CachePeriodInMinutes: 1\n                } ]);\n            }\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----requiredDiscoverEndpoint": "function requiredDiscoverEndpoint(request, done) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n    var endpoints = AWS.endpointCache.get(cacheKeyStr);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n        requestQueue[cacheKeyStr].push({\n            request: request,\n            callback: done\n        });\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n        done();\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        addApiVersionHeader(endpointRequest);\n        AWS.endpointCache.put(cacheKeyStr, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 60\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (err) {\n                request.response.error = util.error(err, {\n                    retryable: false\n                });\n                AWS.endpointCache.remove(cacheKey);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.response.error = util.error(err, {\n                            retryable: false\n                        });\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            } else if (data) {\n                AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n                request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            }\n            done();\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----hasCustomEndpoint": "function hasCustomEndpoint(client) {\n    if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n        throw util.error(new Error(), {\n            code: \"ConfigurationException\",\n            message: \"Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.\"\n        });\n    }\n    var svcConfig = AWS.config[client.serviceIdentifier] || {};\n    return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----resolveEndpointDiscoveryConfig": "function resolveEndpointDiscoveryConfig(request) {\n    var service = request.service || {};\n    if (service.config.endpointDiscoveryEnabled !== undefined) {\n        return service.config.endpointDiscoveryEnabled;\n    }\n    if (util.isBrowser()) return undefined;\n    for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n        var env = endpointDiscoveryEnabledEnvs[i];\n        if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n            if (process.env[env] === \"\" || process.env[env] === undefined) {\n                throw util.error(new Error(), {\n                    code: \"ConfigurationException\",\n                    message: \"environmental variable \" + env + \" cannot be set to nothing\"\n                });\n            }\n            return !isFalsy(process.env[env]);\n        }\n    }\n    var configFile = {};\n    try {\n        configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n            isConfig: true,\n            filename: process.env[AWS.util.sharedConfigFileEnv]\n        }) : {};\n    } catch (e) {}\n    var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};\n    if (Object.prototype.hasOwnProperty.call(sharedFileConfig, \"endpoint_discovery_enabled\")) {\n        if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n            throw util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"config file entry 'endpoint_discovery_enabled' cannot be set to nothing\"\n            });\n        }\n        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);\n    }\n    return undefined;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----discoverEndpoint": "function discoverEndpoint(request, done) {\n    var service = request.service || {};\n    if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n    var operations = service.api.operations || {};\n    var operationModel = operations[request.operation];\n    var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : \"NULL\";\n    var isEnabled = resolveEndpointDiscoveryConfig(request);\n    var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;\n    if (isEnabled || hasRequiredEndpointDiscovery) {\n        request.httpRequest.appendToUserAgent(\"endpoint-discovery\");\n    }\n    switch (isEndpointDiscoveryRequired) {\n      case \"OPTIONAL\":\n        if (isEnabled || hasRequiredEndpointDiscovery) {\n            optionalDiscoverEndpoint(request);\n            request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        }\n        done();\n        break;\n\n      case \"REQUIRED\":\n        if (isEnabled === false) {\n            request.response.error = util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"Endpoint Discovery is disabled but \" + service.api.className + \".\" + request.operation + \"() requires it. Please check your configurations.\"\n            });\n            done();\n            break;\n        }\n        request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        requiredDiscoverEndpoint(request, done);\n        break;\n\n      case \"NULL\":\n      default:\n        done();\n        break;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----inspect": "function inspect(obj, opts) {\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n    } else if (opts) {\n        exports._extend(ctx, opts);\n    }\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----formatValue": "function formatValue(ctx, value, recurseTimes) {\n    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n    if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n    }\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? \": \" + value.name : \"\";\n            return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n    }\n    var base = \"\", array = false, braces = [ \"{\", \"}\" ];\n    if (isArray(value)) {\n        array = true;\n        braces = [ \"[\", \"]\" ];\n    }\n    if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n    }\n    if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n    }\n    if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n    }\n    if (isError(value)) {\n        base = \" \" + formatError(value);\n    }\n    if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n    }\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n            return ctx.stylize(\"[Object]\", \"special\");\n        }\n    }\n    ctx.seen.push(value);\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function(key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----formatPrimitive": "function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n    if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n    }\n    if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n    if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n    if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----formatArray": "function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n            output.push(\"\");\n        }\n    }\n    keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n    });\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----formatProperty": "function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {\n        value: value[key]\n    };\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n            str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf(\"\\n\") > -1) {\n                if (array) {\n                    str = str.split(\"\\n\").map(function(line) {\n                        return \"  \" + line;\n                    }).join(\"\\n\").substr(2);\n                } else {\n                    str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                        return \"   \" + line;\n                    }).join(\"\\n\");\n                }\n            }\n        } else {\n            str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, \"name\");\n        } else {\n            name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, \"string\");\n        }\n    }\n    return name + \": \" + str;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----reduceToSingleString": "function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n    }, 0);\n    if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n    }\n    return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fn": "function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function(resolve, reject) {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    });\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n    }\n    args.push(function(err, value) {\n        if (err) {\n            promiseReject(err);\n        } else {\n            promiseResolve(value);\n        }\n    });\n    try {\n        original.apply(this, args);\n    } catch (err) {\n        promiseReject(err);\n    }\n    return promise;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----callbackify": "function callbackify(original) {\n    if (typeof original !== \"function\") {\n        throw new TypeError('The \"original\" argument must be of type Function');\n    }\n    function callbackified() {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        var maybeCb = args.pop();\n        if (typeof maybeCb !== \"function\") {\n            throw new TypeError(\"The last argument must be of type Function\");\n        }\n        var self = this;\n        var cb = function() {\n            return maybeCb.apply(self, arguments);\n        };\n        original.apply(this, args).then(function(ret) {\n            process.nextTick(cb.bind(null, null, ret));\n        }, function(rej) {\n            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));\n        });\n    }\n    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));\n    return callbackified;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----wrappedCallback": "function wrappedCallback(err, data) {\n    if (err) return callback(err, null);\n    if (data === null) return callback(null, null);\n    var config = self.service.paginationConfig(self.operation);\n    var resultKey = config.resultKey;\n    if (Array.isArray(resultKey)) resultKey = resultKey[0];\n    var items = jmespath.search(data, resultKey);\n    var continueIteration = true;\n    AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n            return AWS.util.abort;\n        }\n    });\n    return continueIteration;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----strictDeepEqual": "function strictDeepEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n        return false;\n    }\n    if (isArray(first) === true) {\n        if (first.length !== second.length) {\n            return false;\n        }\n        for (var i = 0; i < first.length; i++) {\n            if (strictDeepEqual(first[i], second[i]) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (isObject(first) === true) {\n        var keysSeen = {};\n        for (var key in first) {\n            if (hasOwnProperty.call(first, key)) {\n                if (strictDeepEqual(first[key], second[key]) === false) {\n                    return false;\n                }\n                keysSeen[key] = true;\n            }\n        }\n        for (var key2 in second) {\n            if (hasOwnProperty.call(second, key2)) {\n                if (keysSeen[key2] !== true) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----objValues": "function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n    }\n    return values;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----merge": "function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n        merged[key] = a[key];\n    }\n    for (var key2 in b) {\n        merged[key2] = b[key2];\n    }\n    return merged;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----search": "function search(data, expression) {\n    var parser = new Parser();\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----CHECK_ACCEPTORS": "function CHECK_ACCEPTORS(resp) {\n    var waiter = resp.request._waiter;\n    var acceptors = waiter.config.acceptors;\n    var acceptorMatched = false;\n    var state = \"retry\";\n    acceptors.forEach(function(acceptor) {\n        if (!acceptorMatched) {\n            var matcher = waiter.matchers[acceptor.matcher];\n            if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n                acceptorMatched = true;\n                state = acceptor.state;\n            }\n        }\n    });\n    if (!acceptorMatched && resp.error) state = \"failure\";\n    if (state === \"success\") {\n        waiter.setSuccess(resp);\n    } else {\n        waiter.setError(resp, state === \"retry\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----signedUrlBuilder": "function signedUrlBuilder(request) {\n    var expires = request.httpRequest.headers[expiresHeader];\n    var signerClass = request.service.getSignerClass(request);\n    delete request.httpRequest.headers[\"User-Agent\"];\n    delete request.httpRequest.headers[\"X-Amz-User-Agent\"];\n    if (signerClass === AWS.Signers.V4) {\n        if (expires > 604800) {\n            var message = \"Presigning does not support expiry time greater \" + \"than a week with SigV4 signing.\";\n            throw AWS.util.error(new Error(), {\n                code: \"InvalidExpiryTime\",\n                message: message,\n                retryable: false\n            });\n        }\n        request.httpRequest.headers[expiresHeader] = expires;\n    } else if (signerClass === AWS.Signers.S3) {\n        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();\n        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();\n    } else {\n        throw AWS.util.error(new Error(), {\n            message: \"Presigning only supports S3 or SigV4 signing.\",\n            code: \"UnsupportedSigner\",\n            retryable: false\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----signedUrlSigner": "function signedUrlSigner(request) {\n    var endpoint = request.httpRequest.endpoint;\n    var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n    var queryParams = {};\n    if (parsedUrl.search) {\n        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n    }\n    var auth = request.httpRequest.headers[\"Authorization\"].split(\" \");\n    if (auth[0] === \"AWS\") {\n        auth = auth[1].split(\":\");\n        queryParams[\"Signature\"] = auth.pop();\n        queryParams[\"AWSAccessKeyId\"] = auth.join(\":\");\n        AWS.util.each(request.httpRequest.headers, function(key, value) {\n            if (key === expiresHeader) key = \"Expires\";\n            if (key.indexOf(\"x-amz-meta-\") === 0) {\n                delete queryParams[key];\n                key = key.toLowerCase();\n            }\n            queryParams[key] = value;\n        });\n        delete request.httpRequest.headers[expiresHeader];\n        delete queryParams[\"Authorization\"];\n        delete queryParams[\"Host\"];\n    } else if (auth[0] === \"AWS4-HMAC-SHA256\") {\n        auth.shift();\n        var rest = auth.join(\" \");\n        var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n        queryParams[\"X-Amz-Signature\"] = signature;\n        delete queryParams[\"Expires\"];\n    }\n    endpoint.pathname = parsedUrl.pathname;\n    endpoint.search = AWS.util.queryParamsToString(queryParams);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Hmac": "function Hmac(alg, key) {\n    if (!(this instanceof Hmac)) return new Hmac(alg, key);\n    this._opad = opad;\n    this._alg = alg;\n    var blocksize = alg === \"sha512\" ? 128 : 64;\n    key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key;\n    if (key.length > blocksize) {\n        key = createHash(alg).update(key).digest();\n    } else if (key.length < blocksize) {\n        key = Buffer.concat([ key, zeroBuffer ], blocksize);\n    }\n    var ipad = this._ipad = new Buffer(blocksize);\n    var opad = this._opad = new Buffer(blocksize);\n    for (var i = 0; i < blocksize; i++) {\n        ipad[i] = key[i] ^ 54;\n        opad[i] = key[i] ^ 92;\n    }\n    this._hash = createHash(alg).update(ipad);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----bufferFromSecret": "function bufferFromSecret(hashCtor, secret) {\n    var input = hashUtils.convertToBuffer(secret);\n    if (input.byteLength > hashCtor.BLOCK_SIZE) {\n        var bufferHash = new hashCtor();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n    }\n    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\n    buffer.set(input);\n    return buffer;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----from": "function from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----alloc": "function alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----allocUnsafe": "function allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fromString": "function fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        that = that.slice(0, actual);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fromArrayLike": "function fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fromArrayBuffer": "function fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength;\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----byteLength": "function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----slowToString": "function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n\n          case \"base64\":\n            return base64Slice(this, start, end);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----bidirectionalIndexOf": "function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    if (buffer.length === 0) return -1;\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (isNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1; else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0; else return -1;\n    }\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----arrayIndexOf": "function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----hexWrite": "function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf8Slice": "function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                    codePoint = firstByte;\n                }\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n            }\n        }\n        if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----decodeCodePointsArray": "function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----asciiSlice": "function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----latin1Slice": "function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----hexSlice": "function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf16leSlice": "function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----base64clean": "function base64clean(str) {\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2) return \"\";\n    while (str.length % 4 !== 0) {\n        str = str + \"=\";\n    }\n    return str;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf8ToBytes": "function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n                if (codePoint > 56319) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                } else if (i + 1 === length) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                }\n                leadSurrogate = codePoint;\n                continue;\n            }\n            if (codePoint < 56320) {\n                if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf16leToBytes": "function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----getLens": "function getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [ validLen, placeHoldersLen ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----toByteArray": "function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    return arr;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----encodeChunk": "function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fromByteArray": "function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n    return parts.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Md5": "function Md5() {\n    this.state = [ 1732584193, 4023233417, 2562383102, 271733878 ];\n    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Sha1": "function Sha1() {\n    if (POOL.length) return POOL.pop().init();\n    if (!(this instanceof Sha1)) return new Sha1();\n    this._w = W;\n    Hash.call(this, 16 * 4, 14 * 4);\n    this._h = null;\n    this.init();\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Sha256": "function Sha256() {\n    this.state = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(64);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Url": "function Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----urlParse": "function urlParse(url, parseQueryString, slashesDenoteHost) {\n    if (url && isObject(url) && url instanceof Url) return url;\n    var u = new Url();\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----map": "function map(array, fn) {\n    var length = array.length;\n    var result = [];\n    while (length--) {\n        result[length] = fn(array[length]);\n    }\n    return result;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----mapDomain": "function mapDomain(string, fn) {\n    var parts = string.split(\"@\");\n    var result = \"\";\n    if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n    }\n    string = string.replace(regexSeparators, \".\");\n    var labels = string.split(\".\");\n    var encoded = map(labels, fn).join(\".\");\n    return result + encoded;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----basicToDigit": "function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n        return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n        return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n        return codePoint - 97;\n    }\n    return base;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----adapt": "function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (;delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----decode": "function decode(input) {\n    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n            error(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n    }\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        for (oldi = i, w = 1, k = base; ;k += base) {\n            if (index >= inputLength) {\n                error(\"invalid-input\");\n            }\n            digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > floor((maxInt - i) / w)) {\n                error(\"overflow\");\n            }\n            i += digit * w;\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n                break;\n            }\n            baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n                error(\"overflow\");\n            }\n            w *= baseMinusT;\n        }\n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n            error(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----encode": "function encode(input) {\n    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;\n    input = ucs2decode(input);\n    inputLength = input.length;\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n    for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < 128) {\n            output.push(stringFromCharCode(currentValue));\n        }\n    }\n    handledCPCount = basicLength = output.length;\n    if (basicLength) {\n        output.push(delimiter);\n    }\n    while (handledCPCount < inputLength) {\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue < n && ++delta > maxInt) {\n                error(\"overflow\");\n            }\n            if (currentValue == n) {\n                for (q = delta, k = base; ;k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                    q = floor(qMinusT / baseMinusT);\n                }\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n        ++delta;\n        ++n;\n    }\n    return output.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----createEventStream": "function createEventStream(body, parser, model) {\n    var eventMessages = eventMessageChunker(body);\n    var events = [];\n    for (var i = 0; i < eventMessages.length; i++) {\n        events.push(parseEvent(parser, eventMessages[i], model));\n    }\n    return events;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----eventMessageChunker": "function eventMessageChunker(buffer) {\n    var messages = [];\n    var offset = 0;\n    while (offset < buffer.length) {\n        var totalLength = buffer.readInt32BE(offset);\n        var message = buffer.slice(offset, totalLength + offset);\n        offset += totalLength;\n        messages.push(message);\n    }\n    return messages;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseEvent": "function parseEvent(parser, message, shape) {\n    var parsedMessage = parseMessage(message);\n    var messageType = parsedMessage.headers[\":message-type\"];\n    if (messageType) {\n        if (messageType.value === \"error\") {\n            throw parseError(parsedMessage);\n        } else if (messageType.value !== \"event\") {\n            return;\n        }\n    }\n    var eventType = parsedMessage.headers[\":event-type\"];\n    var eventModel = shape.members[eventType.value];\n    if (!eventModel) {\n        return;\n    }\n    var result = {};\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n    if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName];\n        if (payloadShape.type === \"binary\") {\n            result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n    }\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\n    for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n        if (parsedMessage.headers[name]) {\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n    }\n    var output = {};\n    output[eventType.value] = result;\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseError": "function parseError(message) {\n    var errorCode = message.headers[\":error-code\"];\n    var errorMessage = message.headers[\":error-message\"];\n    var error = new Error(errorMessage.value || errorMessage);\n    error.code = error.name = errorCode.value || errorCode;\n    return error;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseHeaders": "function parseHeaders(headers) {\n    var out = {};\n    var position = 0;\n    while (position < headers.length) {\n        var nameLength = headers.readUInt8(position++);\n        var name = headers.slice(position, position + nameLength).toString();\n        position += nameLength;\n        switch (headers.readUInt8(position++)) {\n          case 0:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: true\n            };\n            break;\n\n          case 1:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: false\n            };\n            break;\n\n          case 2:\n            out[name] = {\n                type: BYTE_TAG,\n                value: headers.readInt8(position++)\n            };\n            break;\n\n          case 3:\n            out[name] = {\n                type: SHORT_TAG,\n                value: headers.readInt16BE(position)\n            };\n            position += 2;\n            break;\n\n          case 4:\n            out[name] = {\n                type: INT_TAG,\n                value: headers.readInt32BE(position)\n            };\n            position += 4;\n            break;\n\n          case 5:\n            out[name] = {\n                type: LONG_TAG,\n                value: new Int64(headers.slice(position, position + 8))\n            };\n            position += 8;\n            break;\n\n          case 6:\n            var binaryLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: BINARY_TAG,\n                value: headers.slice(position, position + binaryLength)\n            };\n            position += binaryLength;\n            break;\n\n          case 7:\n            var stringLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: STRING_TAG,\n                value: headers.slice(position, position + stringLength).toString()\n            };\n            position += stringLength;\n            break;\n\n          case 8:\n            out[name] = {\n                type: TIMESTAMP_TAG,\n                value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())\n            };\n            position += 8;\n            break;\n\n          case 9:\n            var uuidChars = headers.slice(position, position + 16).toString(\"hex\");\n            position += 16;\n            out[name] = {\n                type: UUID_TAG,\n                value: uuidChars.substr(0, 8) + \"-\" + uuidChars.substr(8, 4) + \"-\" + uuidChars.substr(12, 4) + \"-\" + uuidChars.substr(16, 4) + \"-\" + uuidChars.substr(20)\n            };\n            break;\n\n          default:\n            throw new Error(\"Unrecognized header type tag\");\n        }\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----splitMessage": "function splitMessage(message) {\n    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\n    if (message.length < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    if (message.length !== message.readUInt32BE(0)) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\n    if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {\n        throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum.\");\n    }\n    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\n    if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {\n        throw new Error(\"The message checksum did not match the expected value of \" + expectedMessageChecksum);\n    }\n    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\n    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\n    return {\n        headers: message.slice(headersStart, headersEnd),\n        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----resolveRegionalEndpointsFlag": "function resolveRegionalEndpointsFlag(originalConfig, options) {\n    originalConfig = originalConfig || {};\n    var resolved;\n    if (originalConfig[options.clientConfig]) {\n        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {\n            code: \"InvalidConfiguration\",\n            message: 'invalid \"' + options.clientConfig + '\" configuration. Expect \"legacy\" ' + ' or \"regional\". Got \"' + originalConfig[options.clientConfig] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    if (!AWS.util.isNode()) return resolved;\n    if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {\n        var envFlag = process.env[options.env];\n        resolved = validateRegionalEndpointsFlagValue(envFlag, {\n            code: \"InvalidEnvironmentalVariable\",\n            message: \"invalid \" + options.env + ' environmental variable. Expect \"legacy\" ' + ' or \"regional\". Got \"' + process.env[options.env] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    var profile = {};\n    try {\n        var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);\n        profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];\n    } catch (e) {}\n    if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {\n        var fileFlag = profile[options.sharedConfig];\n        resolved = validateRegionalEndpointsFlagValue(fileFlag, {\n            code: \"InvalidConfiguration\",\n            message: \"invalid \" + options.sharedConfig + ' profile config. Expect \"legacy\" ' + ' or \"regional\". Got \"' + profile[options.sharedConfig] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    return resolved;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseStructure": "function parseStructure(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    util.each(shape.members, function(memberName, memberShape) {\n        var xmlName = memberShape.name;\n        if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {\n            var xmlChild = xml[xmlName];\n            if (!memberShape.flattened) xmlChild = xmlChild[0];\n            data[memberName] = parseXml(xmlChild, memberShape);\n        } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {\n            data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n        } else if (memberShape.type === \"list\" && !shape.api.xmlNoDefaultLists) {\n            data[memberName] = memberShape.defaultValue;\n        }\n    });\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseMap": "function parseMap(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    var xmlKey = shape.key.name || \"key\";\n    var xmlValue = shape.value.name || \"value\";\n    var iterable = shape.flattened ? xml : xml.entry;\n    if (Array.isArray(iterable)) {\n        util.arrayEach(iterable, function(child) {\n            data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n        });\n    }\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseList": "function parseList(xml, shape) {\n    var data = [];\n    var name = shape.member.name || \"member\";\n    if (shape.flattened) {\n        util.arrayEach(xml, function(xmlChild) {\n            data.push(parseXml(xmlChild, shape.member));\n        });\n    } else if (xml && Array.isArray(xml[name])) {\n        util.arrayEach(xml[name], function(child) {\n            data.push(parseXml(child, shape.member));\n        });\n    }\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseUnknown": "function parseUnknown(xml) {\n    if (xml === undefined || xml === null) return \"\";\n    if (typeof xml === \"string\") return xml;\n    if (Array.isArray(xml)) {\n        var arr = [];\n        for (i = 0; i < xml.length; i++) {\n            arr.push(parseXml(xml[i], {}));\n        }\n        return arr;\n    }\n    var keys = Object.keys(xml), i;\n    if (keys.length === 0 || keys.length === 1 && keys[0] === \"$\") {\n        return {};\n    }\n    var data = {};\n    for (i = 0; i < keys.length; i++) {\n        var key = keys[i], value = xml[key];\n        if (key === \"$\") continue;\n        if (value.length > 1) {\n            data[key] = parseList(value, {\n                member: {}\n            });\n        } else {\n            data[key] = parseXml(value[0], {});\n        }\n    }\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Builder": "function Builder(opts) {\n    var key, ref, value;\n    this.options = {};\n    ref = defaults[\"0.2\"];\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n    }\n    for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDocument": "function XMLDocument(options) {\n    XMLDocument.__super__.constructor.call(this, null);\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter();\n    }\n    this.options = options;\n    this.stringify = new XMLStringifier(options);\n    this.isDocument = true;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLNode": "function XMLNode(parent) {\n    this.parent = parent;\n    if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n    }\n    this.children = [];\n    if (!XMLElement) {\n        XMLElement = __webpack_require__(8);\n        XMLCData = __webpack_require__(10);\n        XMLComment = __webpack_require__(11);\n        XMLDeclaration = __webpack_require__(12);\n        XMLDocType = __webpack_require__(13);\n        XMLRaw = __webpack_require__(18);\n        XMLText = __webpack_require__(19);\n        XMLProcessingInstruction = __webpack_require__(20);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLElement": "function XMLElement(parent, name, attributes) {\n    XMLElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing element name\");\n    }\n    this.name = this.stringify.eleName(name);\n    this.attributes = {};\n    if (attributes != null) {\n        this.attribute(attributes);\n    }\n    if (parent.isDocument) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLAttribute": "function XMLAttribute(parent, name, value) {\n    this.options = parent.options;\n    this.stringify = parent.stringify;\n    if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n    }\n    if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n    }\n    this.name = this.stringify.attName(name);\n    this.value = this.stringify.attValue(value);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDeclaration": "function XMLDeclaration(parent, version, encoding, standalone) {\n    var ref;\n    XMLDeclaration.__super__.constructor.call(this, parent);\n    if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n    }\n    if (!version) {\n        version = \"1.0\";\n    }\n    this.version = this.stringify.xmlVersion(version);\n    if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n    }\n    if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDocType": "function XMLDocType(parent, pubID, sysID) {\n    var ref, ref1;\n    XMLDocType.__super__.constructor.call(this, parent);\n    this.documentObject = parent;\n    if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n    }\n    if (sysID == null) {\n        ref1 = [ pubID, sysID ], sysID = ref1[0], pubID = ref1[1];\n    }\n    if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n    }\n    if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDTDAttList": "function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n    XMLDTDAttList.__super__.constructor.call(this, parent);\n    if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n    }\n    if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n    }\n    if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n    }\n    if (defaultValueType.indexOf(\"#\") !== 0) {\n        defaultValueType = \"#\" + defaultValueType;\n    }\n    if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n    }\n    if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n    }\n    this.elementName = this.stringify.eleName(elementName);\n    this.attributeName = this.stringify.attName(attributeName);\n    this.attributeType = this.stringify.dtdAttType(attributeType);\n    this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n    this.defaultValueType = defaultValueType;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDTDEntity": "function XMLDTDEntity(parent, pe, name, value) {\n    XMLDTDEntity.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing entity name\");\n    }\n    if (value == null) {\n        throw new Error(\"Missing entity value\");\n    }\n    this.pe = !!pe;\n    this.name = this.stringify.eleName(name);\n    if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n    } else {\n        if (!value.pubID && !value.sysID) {\n            throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n            throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n            this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n            this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n            this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n            throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDTDElement": "function XMLDTDElement(parent, name, value) {\n    XMLDTDElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (!value) {\n        value = \"(#PCDATA)\";\n    }\n    if (Array.isArray(value)) {\n        value = \"(\" + value.join(\",\") + \")\";\n    }\n    this.name = this.stringify.eleName(name);\n    this.value = this.stringify.dtdElementValue(value);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDTDNotation": "function XMLDTDNotation(parent, name, value) {\n    XMLDTDNotation.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing notation name\");\n    }\n    if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n    }\n    this.name = this.stringify.eleName(name);\n    if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n    }\n    if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLProcessingInstruction": "function XMLProcessingInstruction(parent, target, value) {\n    XMLProcessingInstruction.__super__.constructor.call(this, parent);\n    if (target == null) {\n        throw new Error(\"Missing instruction target\");\n    }\n    this.target = this.stringify.insTarget(target);\n    if (value) {\n        this.value = this.stringify.insValue(value);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLStringifier": "function XMLStringifier(options) {\n    this.assertLegalChar = bind(this.assertLegalChar, this);\n    var key, ref, value;\n    options || (options = {});\n    this.noDoubleEncoding = options.noDoubleEncoding;\n    ref = options.stringify || {};\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLWriterBase": "function XMLWriterBase(options) {\n    var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;\n    options || (options = {});\n    this.pretty = options.pretty || false;\n    this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;\n    if (this.pretty) {\n        this.indent = (ref1 = options.indent) != null ? ref1 : \"  \";\n        this.newline = (ref2 = options.newline) != null ? ref2 : \"\\n\";\n        this.offset = (ref3 = options.offset) != null ? ref3 : 0;\n        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;\n    } else {\n        this.indent = \"\";\n        this.newline = \"\";\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n    }\n    this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : \"\";\n    if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = \" \";\n    }\n    this.newlinedefault = this.newline;\n    this.prettydefault = this.pretty;\n    ref6 = options.writer || {};\n    for (key in ref6) {\n        if (!hasProp.call(ref6, key)) continue;\n        value = ref6[key];\n        this[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----XMLDocumentCB": "function XMLDocumentCB(options, onData, onEnd) {\n    var writerOptions;\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter(options);\n    } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter(writerOptions);\n    }\n    this.options = options;\n    this.writer = options.writer;\n    this.stringify = new XMLStringifier(options);\n    this.onDataCallback = onData || function() {};\n    this.onEndCallback = onEnd || function() {};\n    this.currentNode = null;\n    this.currentLevel = -1;\n    this.openTags = {};\n    this.documentStarted = false;\n    this.documentCompleted = false;\n    this.root = null;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Parser": "function Parser(opts) {\n    this.parseString = bind(this.parseString, this);\n    this.reset = bind(this.reset, this);\n    this.assignOrPush = bind(this.assignOrPush, this);\n    this.processAsync = bind(this.processAsync, this);\n    var key, ref, value;\n    if (!(this instanceof exports.Parser)) {\n        return new exports.Parser(opts);\n    }\n    this.options = {};\n    ref = defaults[\"0.2\"];\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n    }\n    for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n    }\n    if (this.options.xmlns) {\n        this.options.xmlnskey = this.options.attrkey + \"ns\";\n    }\n    if (this.options.normalizeTags) {\n        if (!this.options.tagNameProcessors) {\n            this.options.tagNameProcessors = [];\n        }\n        this.options.tagNameProcessors.unshift(processors.normalize);\n    }\n    this.reset();\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----SAXParser": "function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n        return new SAXParser(strict, opt);\n    }\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n    if (parser.opt.xmlns) {\n        parser.ns = Object.create(rootNS);\n    }\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n        parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----checkBufferLength": "function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n        var len = parser[buffers[i]].length;\n        if (len > maxAllowed) {\n            switch (buffers[i]) {\n              case \"textNode\":\n                closeText(parser);\n                break;\n\n              case \"cdata\":\n                emitNode(parser, \"oncdata\", parser.cdata);\n                parser.cdata = \"\";\n                break;\n\n              case \"script\":\n                emitNode(parser, \"onscript\", parser.script);\n                parser.script = \"\";\n                break;\n\n              default:\n                error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n            }\n        }\n        maxActual = Math.max(maxActual, len);\n    }\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----SAXStream": "function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n        return new SAXStream(strict, opt);\n    }\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n    this._parser.onend = function() {\n        me.emit(\"end\");\n    };\n    this._parser.onerror = function(er) {\n        me.emit(\"error\", er);\n        me._parser.error = null;\n    };\n    this._decoder = null;\n    streamWraps.forEach(function(ev) {\n        Object.defineProperty(me, \"on\" + ev, {\n            get: function() {\n                return me._parser[\"on\" + ev];\n            },\n            set: function(h) {\n                if (!h) {\n                    me.removeAllListeners(ev);\n                    me._parser[\"on\" + ev] = h;\n                    return h;\n                }\n                me.on(ev, h);\n            },\n            enumerable: true,\n            configurable: false\n        });\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----error": "function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n        er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----end": "function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n        error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----newTag": "function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n    };\n    if (parser.opt.xmlns) {\n        tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----qname": "function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [ \"\", name ] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n    if (attribute && name === \"xmlns\") {\n        prefix = \"xmlns\";\n        local = \"\";\n    }\n    return {\n        prefix: prefix,\n        local: local\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----attrib": "function attrib(parser) {\n    if (!parser.strict) {\n        parser.attribName = parser.attribName[parser.looseCase]();\n    }\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n        parser.attribName = parser.attribValue = \"\";\n        return;\n    }\n    if (parser.opt.xmlns) {\n        var qn = qname(parser.attribName, true);\n        var prefix = qn.prefix;\n        var local = qn.local;\n        if (prefix === \"xmlns\") {\n            if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n                strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else {\n                var tag = parser.tag;\n                var parent = parser.tags[parser.tags.length - 1] || parser;\n                if (tag.ns === parent.ns) {\n                    tag.ns = Object.create(parent.ns);\n                }\n                tag.ns[local] = parser.attribValue;\n            }\n        }\n        parser.attribList.push([ parser.attribName, parser.attribValue ]);\n    } else {\n        parser.tag.attributes[parser.attribName] = parser.attribValue;\n        emitNode(parser, \"onattribute\", {\n            name: parser.attribName,\n            value: parser.attribValue\n        });\n    }\n    parser.attribName = parser.attribValue = \"\";\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----openTag": "function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n        var tag = parser.tag;\n        var qn = qname(parser.tagName);\n        tag.prefix = qn.prefix;\n        tag.local = qn.local;\n        tag.uri = tag.ns[qn.prefix] || \"\";\n        if (tag.prefix && !tag.uri) {\n            strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n            tag.uri = qn.prefix;\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (tag.ns && parent.ns !== tag.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                emitNode(parser, \"onopennamespace\", {\n                    prefix: p,\n                    uri: tag.ns[p]\n                });\n            });\n        }\n        for (var i = 0, l = parser.attribList.length; i < l; i++) {\n            var nv = parser.attribList[i];\n            var name = nv[0];\n            var value = nv[1];\n            var qualName = qname(name, true);\n            var prefix = qualName.prefix;\n            var local = qualName.local;\n            var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n            var a = {\n                name: name,\n                value: value,\n                prefix: prefix,\n                local: local,\n                uri: uri\n            };\n            if (prefix && prefix !== \"xmlns\" && !uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                a.uri = prefix;\n            }\n            parser.tag.attributes[name] = a;\n            emitNode(parser, \"onattribute\", a);\n        }\n        parser.attribList.length = 0;\n    }\n    parser.tag.isSelfClosing = !!selfClosing;\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n        if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n            parser.state = S.SCRIPT;\n        } else {\n            parser.state = S.TEXT;\n        }\n        parser.tag = null;\n        parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----closeTag": "function closeTag(parser) {\n    if (!parser.tagName) {\n        strictFail(parser, \"Weird empty close tag.\");\n        parser.textNode += \"</>\";\n        parser.state = S.TEXT;\n        return;\n    }\n    if (parser.script) {\n        if (parser.tagName !== \"script\") {\n            parser.script += \"</\" + parser.tagName + \">\";\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n            return;\n        }\n        emitNode(parser, \"onscript\", parser.script);\n        parser.script = \"\";\n    }\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n        tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n        var close = parser.tags[t];\n        if (close.name !== closeTo) {\n            strictFail(parser, \"Unexpected close tag\");\n        } else {\n            break;\n        }\n    }\n    if (t < 0) {\n        strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n        parser.textNode += \"</\" + parser.tagName + \">\";\n        parser.state = S.TEXT;\n        return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n        var tag = parser.tag = parser.tags.pop();\n        parser.tagName = parser.tag.name;\n        emitNode(parser, \"onclosetag\", parser.tagName);\n        var x = {};\n        for (var i in tag.ns) {\n            x[i] = tag.ns[i];\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (parser.opt.xmlns && tag.ns !== parent.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                var n = tag.ns[p];\n                emitNode(parser, \"onclosenamespace\", {\n                    prefix: p,\n                    uri: n\n                });\n            });\n        }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----parseEntity": "function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n    if (parser.ENTITIES[entity]) {\n        return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n        return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n        if (entity.charAt(1) === \"x\") {\n            entity = entity.slice(2);\n            num = parseInt(entity, 16);\n            numStr = num.toString(16);\n        } else {\n            entity = entity.slice(1);\n            num = parseInt(entity, 10);\n            numStr = num.toString(10);\n        }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (numStr.toLowerCase() !== entity) {\n        strictFail(parser, \"Invalid character entity\");\n        return \"&\" + parser.entity + \";\";\n    }\n    return String.fromCodePoint(num);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----write": "function write(chunk) {\n    var parser = this;\n    if (this.error) {\n        throw this.error;\n    }\n    if (parser.closed) {\n        return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    }\n    if (chunk === null) {\n        return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n        chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n        c = charAt(chunk, i++);\n        parser.c = c;\n        if (!c) {\n            break;\n        }\n        if (parser.trackPosition) {\n            parser.position++;\n            if (c === \"\\n\") {\n                parser.line++;\n                parser.column = 0;\n            } else {\n                parser.column++;\n            }\n        }\n        switch (parser.state) {\n          case S.BEGIN:\n            parser.state = S.BEGIN_WHITESPACE;\n            if (c === \"\\ufeff\") {\n                continue;\n            }\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.BEGIN_WHITESPACE:\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.TEXT:\n            if (parser.sawRoot && !parser.closedRoot) {\n                var starti = i - 1;\n                while (c && c !== \"<\" && c !== \"&\") {\n                    c = charAt(chunk, i++);\n                    if (c && parser.trackPosition) {\n                        parser.position++;\n                        if (c === \"\\n\") {\n                            parser.line++;\n                            parser.column = 0;\n                        } else {\n                            parser.column++;\n                        }\n                    }\n                }\n                parser.textNode += chunk.substring(starti, i - 1);\n            }\n            if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n            } else {\n                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n                    strictFail(parser, \"Text data outside of root node.\");\n                }\n                if (c === \"&\") {\n                    parser.state = S.TEXT_ENTITY;\n                } else {\n                    parser.textNode += c;\n                }\n            }\n            continue;\n\n          case S.SCRIPT:\n            if (c === \"<\") {\n                parser.state = S.SCRIPT_ENDING;\n            } else {\n                parser.script += c;\n            }\n            continue;\n\n          case S.SCRIPT_ENDING:\n            if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n            } else {\n                parser.script += \"<\" + c;\n                parser.state = S.SCRIPT;\n            }\n            continue;\n\n          case S.OPEN_WAKA:\n            if (c === \"!\") {\n                parser.state = S.SGML_DECL;\n                parser.sgmlDecl = \"\";\n            } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {\n                parser.state = S.OPEN_TAG;\n                parser.tagName = c;\n            } else if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n                parser.tagName = \"\";\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST;\n                parser.procInstName = parser.procInstBody = \"\";\n            } else {\n                strictFail(parser, \"Unencoded <\");\n                if (parser.startTagPosition + 1 < parser.position) {\n                    var pad = parser.position - parser.startTagPosition;\n                    c = new Array(pad).join(\" \") + c;\n                }\n                parser.textNode += \"<\" + c;\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.SGML_DECL:\n            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                emitNode(parser, \"onopencdata\");\n                parser.state = S.CDATA;\n                parser.sgmlDecl = \"\";\n                parser.cdata = \"\";\n            } else if (parser.sgmlDecl + c === \"--\") {\n                parser.state = S.COMMENT;\n                parser.comment = \"\";\n                parser.sgmlDecl = \"\";\n            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                parser.state = S.DOCTYPE;\n                if (parser.doctype || parser.sawRoot) {\n                    strictFail(parser, \"Inappropriately located doctype declaration\");\n                }\n                parser.doctype = \"\";\n                parser.sgmlDecl = \"\";\n            } else if (c === \">\") {\n                emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                parser.sgmlDecl = \"\";\n                parser.state = S.TEXT;\n            } else if (is(quote, c)) {\n                parser.state = S.SGML_DECL_QUOTED;\n                parser.sgmlDecl += c;\n            } else {\n                parser.sgmlDecl += c;\n            }\n            continue;\n\n          case S.SGML_DECL_QUOTED:\n            if (c === parser.q) {\n                parser.state = S.SGML_DECL;\n                parser.q = \"\";\n            }\n            parser.sgmlDecl += c;\n            continue;\n\n          case S.DOCTYPE:\n            if (c === \">\") {\n                parser.state = S.TEXT;\n                emitNode(parser, \"ondoctype\", parser.doctype);\n                parser.doctype = true;\n            } else {\n                parser.doctype += c;\n                if (c === \"[\") {\n                    parser.state = S.DOCTYPE_DTD;\n                } else if (is(quote, c)) {\n                    parser.state = S.DOCTYPE_QUOTED;\n                    parser.q = c;\n                }\n            }\n            continue;\n\n          case S.DOCTYPE_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.q = \"\";\n                parser.state = S.DOCTYPE;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD:\n            parser.doctype += c;\n            if (c === \"]\") {\n                parser.state = S.DOCTYPE;\n            } else if (is(quote, c)) {\n                parser.state = S.DOCTYPE_DTD_QUOTED;\n                parser.q = c;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.q = \"\";\n            }\n            continue;\n\n          case S.COMMENT:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDING;\n            } else {\n                parser.comment += c;\n            }\n            continue;\n\n          case S.COMMENT_ENDING:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDED;\n                parser.comment = textopts(parser.opt, parser.comment);\n                if (parser.comment) {\n                    emitNode(parser, \"oncomment\", parser.comment);\n                }\n                parser.comment = \"\";\n            } else {\n                parser.comment += \"-\" + c;\n                parser.state = S.COMMENT;\n            }\n            continue;\n\n          case S.COMMENT_ENDED:\n            if (c !== \">\") {\n                strictFail(parser, \"Malformed comment\");\n                parser.comment += \"--\" + c;\n                parser.state = S.COMMENT;\n            } else {\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.CDATA:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING;\n            } else {\n                parser.cdata += c;\n            }\n            continue;\n\n          case S.CDATA_ENDING:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING_2;\n            } else {\n                parser.cdata += \"]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.CDATA_ENDING_2:\n            if (c === \">\") {\n                if (parser.cdata) {\n                    emitNode(parser, \"oncdata\", parser.cdata);\n                }\n                emitNode(parser, \"onclosecdata\");\n                parser.cdata = \"\";\n                parser.state = S.TEXT;\n            } else if (c === \"]\") {\n                parser.cdata += \"]\";\n            } else {\n                parser.cdata += \"]]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.PROC_INST:\n            if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else if (is(whitespace, c)) {\n                parser.state = S.PROC_INST_BODY;\n            } else {\n                parser.procInstName += c;\n            }\n            continue;\n\n          case S.PROC_INST_BODY:\n            if (!parser.procInstBody && is(whitespace, c)) {\n                continue;\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else {\n                parser.procInstBody += c;\n            }\n            continue;\n\n          case S.PROC_INST_ENDING:\n            if (c === \">\") {\n                emitNode(parser, \"onprocessinginstruction\", {\n                    name: parser.procInstName,\n                    body: parser.procInstBody\n                });\n                parser.procInstName = parser.procInstBody = \"\";\n                parser.state = S.TEXT;\n            } else {\n                parser.procInstBody += \"?\" + c;\n                parser.state = S.PROC_INST_BODY;\n            }\n            continue;\n\n          case S.OPEN_TAG:\n            if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else {\n                newTag(parser);\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (c === \"/\") {\n                    parser.state = S.OPEN_TAG_SLASH;\n                } else {\n                    if (not(whitespace, c)) {\n                        strictFail(parser, \"Invalid character in tag name\");\n                    }\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.OPEN_TAG_SLASH:\n            if (c === \">\") {\n                openTag(parser, true);\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.ATTRIB:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (c === \">\") {\n                strictFail(parser, \"Attribute without value\");\n                parser.attribValue = parser.attribName;\n                attrib(parser);\n                openTag(parser);\n            } else if (is(whitespace, c)) {\n                parser.state = S.ATTRIB_NAME_SAW_WHITE;\n            } else if (is(nameBody, c)) {\n                parser.attribName += c;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME_SAW_WHITE:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (is(whitespace, c)) {\n                continue;\n            } else {\n                strictFail(parser, \"Attribute without value\");\n                parser.tag.attributes[parser.attribName] = \"\";\n                parser.attribValue = \"\";\n                emitNode(parser, \"onattribute\", {\n                    name: parser.attribName,\n                    value: \"\"\n                });\n                parser.attribName = \"\";\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (is(nameStart, c)) {\n                    parser.attribName = c;\n                    parser.state = S.ATTRIB_NAME;\n                } else {\n                    strictFail(parser, \"Invalid attribute name\");\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.ATTRIB_VALUE:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (is(quote, c)) {\n                parser.q = c;\n                parser.state = S.ATTRIB_VALUE_QUOTED;\n            } else {\n                strictFail(parser, \"Unquoted attribute value\");\n                parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                parser.attribValue = c;\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_QUOTED:\n            if (c !== parser.q) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            parser.q = \"\";\n            parser.state = S.ATTRIB_VALUE_CLOSED;\n            continue;\n\n          case S.ATTRIB_VALUE_CLOSED:\n            if (is(whitespace, c)) {\n                parser.state = S.ATTRIB;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                strictFail(parser, \"No whitespace between attributes\");\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_UNQUOTED:\n            if (not(attribEnd, c)) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            if (c === \">\") {\n                openTag(parser);\n            } else {\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.CLOSE_TAG:\n            if (!parser.tagName) {\n                if (is(whitespace, c)) {\n                    continue;\n                } else if (not(nameStart, c)) {\n                    if (parser.script) {\n                        parser.script += \"</\" + c;\n                        parser.state = S.SCRIPT;\n                    } else {\n                        strictFail(parser, \"Invalid tagname in closing tag.\");\n                    }\n                } else {\n                    parser.tagName = c;\n                }\n            } else if (c === \">\") {\n                closeTag(parser);\n            } else if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else if (parser.script) {\n                parser.script += \"</\" + parser.tagName;\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n            } else {\n                if (not(whitespace, c)) {\n                    strictFail(parser, \"Invalid tagname in closing tag\");\n                }\n                parser.state = S.CLOSE_TAG_SAW_WHITE;\n            }\n            continue;\n\n          case S.CLOSE_TAG_SAW_WHITE:\n            if (is(whitespace, c)) {\n                continue;\n            }\n            if (c === \">\") {\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Invalid characters in closing tag\");\n            }\n            continue;\n\n          case S.TEXT_ENTITY:\n          case S.ATTRIB_VALUE_ENTITY_Q:\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState;\n            var buffer;\n            switch (parser.state) {\n              case S.TEXT_ENTITY:\n                returnState = S.TEXT;\n                buffer = \"textNode\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_Q:\n                returnState = S.ATTRIB_VALUE_QUOTED;\n                buffer = \"attribValue\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_U:\n                returnState = S.ATTRIB_VALUE_UNQUOTED;\n                buffer = \"attribValue\";\n                break;\n            }\n            if (c === \";\") {\n                parser[buffer] += parseEntity(parser);\n                parser.entity = \"\";\n                parser.state = returnState;\n            } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n                parser.entity += c;\n            } else {\n                strictFail(parser, \"Invalid character in entity name\");\n                parser[buffer] += \"&\" + parser.entity + c;\n                parser.entity = \"\";\n                parser.state = returnState;\n            }\n            continue;\n\n          default:\n            throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n    }\n    if (parser.position >= parser.bufferCheckPosition) {\n        checkBufferLength(parser);\n    }\n    return parser;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----cleanup": "function cleanup() {\n    debug(\"cleanup\");\n    dest.removeListener(\"close\", onclose);\n    dest.removeListener(\"finish\", onfinish);\n    dest.removeListener(\"drain\", ondrain);\n    dest.removeListener(\"error\", onerror);\n    dest.removeListener(\"unpipe\", onunpipe);\n    src.removeListener(\"end\", onend);\n    src.removeListener(\"end\", unpipe);\n    src.removeListener(\"data\", ondata);\n    cleanedUp = true;\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----ReadableState": "function ReadableState(options, stream) {\n    Duplex = Duplex || __webpack_require__(422);\n    options = options || {};\n    var isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    var hwm = options.highWaterMark;\n    var readableHwm = options.readableHighWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm;\n    this.highWaterMark = Math.floor(this.highWaterMark);\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    this.sync = true;\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n    this.destroyed = false;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.awaitDrain = 0;\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = __webpack_require__(425).StringDecoder;\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Readable": "function Readable(options) {\n    Duplex = Duplex || __webpack_require__(422);\n    if (!(this instanceof Readable)) return new Readable(options);\n    this._readableState = new ReadableState(options, this);\n    this.readable = true;\n    if (options) {\n        if (typeof options.read === \"function\") this._read = options.read;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n    }\n    Stream.call(this);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----howMuchToRead": "function howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return 1;\n    if (n !== n) {\n        if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;\n    }\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state.length) return n;\n    if (!state.ended) {\n        state.needReadable = true;\n        return 0;\n    }\n    return state.length;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----onEofChunk": "function onEofChunk(stream, state) {\n    if (state.ended) return;\n    if (state.decoder) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    emitReadable(stream);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----ondata": "function ondata(chunk) {\n    debug(\"ondata\");\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n            debug(\"false write response, pause\", src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n        }\n        src.pause();\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----onerror": "function onerror(er) {\n    debug(\"onerror\", er);\n    unpipe();\n    dest.removeListener(\"error\", onerror);\n    if (EElistenerCount(dest, \"error\") === 0) dest.emit(\"error\", er);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----resume_": "function resume_(stream, state) {\n    if (!state.reading) {\n        debug(\"resume read 0\");\n        stream.read(0);\n    }\n    state.resumeScheduled = false;\n    state.awaitDrain = 0;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----fromList": "function fromList(n, state) {\n    if (state.length === 0) return null;\n    var ret;\n    if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\"); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else {\n        ret = fromListPartial(n, state.buffer, state.decoder);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----copyFromBufferString": "function copyFromBufferString(n, list) {\n    var p = list.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n    while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str; else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n            if (nb === str.length) {\n                ++c;\n                if (p.next) list.head = p.next; else list.head = list.tail = null;\n            } else {\n                list.head = p;\n                p.data = str.slice(nb);\n            }\n            break;\n        }\n        ++c;\n    }\n    list.length -= c;\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----copyFromBuffer": "function copyFromBuffer(n, list) {\n    var ret = Buffer.allocUnsafe(n);\n    var p = list.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n    while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n            if (nb === buf.length) {\n                ++c;\n                if (p.next) list.head = p.next; else list.head = list.tail = null;\n            } else {\n                list.head = p;\n                p.data = buf.slice(nb);\n            }\n            break;\n        }\n        ++c;\n    }\n    list.length -= c;\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----nextTick": "function nextTick(fn, arg1, arg2, arg3) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError('\"callback\" argument must be a function');\n    }\n    var len = arguments.length;\n    var args, i;\n    switch (len) {\n      case 0:\n      case 1:\n        return process.nextTick(fn);\n\n      case 2:\n        return process.nextTick(function afterTickOne() {\n            fn.call(null, arg1);\n        });\n\n      case 3:\n        return process.nextTick(function afterTickTwo() {\n            fn.call(null, arg1, arg2);\n        });\n\n      case 4:\n        return process.nextTick(function afterTickThree() {\n            fn.call(null, arg1, arg2, arg3);\n        });\n\n      default:\n        args = new Array(len - 1);\n        i = 0;\n        while (i < args.length) {\n            args[i++] = arguments[i];\n        }\n        return process.nextTick(function afterTick() {\n            fn.apply(null, args);\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----BufferList": "function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----destroy": "function destroy(err, cb) {\n    var _this = this;\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n    if (readableDestroyed || writableDestroyed) {\n        if (cb) {\n            cb(err);\n        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n        }\n        return this;\n    }\n    if (this._readableState) {\n        this._readableState.destroyed = true;\n    }\n    if (this._writableState) {\n        this._writableState.destroyed = true;\n    }\n    this._destroy(err || null, function(err) {\n        if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n            if (_this._writableState) {\n                _this._writableState.errorEmitted = true;\n            }\n        } else if (cb) {\n            cb(err);\n        }\n    });\n    return this;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Duplex": "function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once(\"end\", onend);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----WriteReq": "function WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----CorkedRequest": "function CorkedRequest(state) {\n    var _this = this;\n    this.next = null;\n    this.entry = null;\n    this.finish = function() {\n        onCorkedFinish(_this, state);\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----WritableState": "function WritableState(options, stream) {\n    Duplex = Duplex || __webpack_require__(422);\n    options = options || {};\n    var isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    var hwm = options.highWaterMark;\n    var writableHwm = options.writableHighWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm;\n    this.highWaterMark = Math.floor(this.highWaterMark);\n    this.finalCalled = false;\n    this.needDrain = false;\n    this.ending = false;\n    this.ended = false;\n    this.finished = false;\n    this.destroyed = false;\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.length = 0;\n    this.writing = false;\n    this.corked = 0;\n    this.sync = true;\n    this.bufferProcessing = false;\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    this.writecb = null;\n    this.writelen = 0;\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n    this.pendingcb = 0;\n    this.prefinished = false;\n    this.errorEmitted = false;\n    this.bufferedRequestCount = 0;\n    this.corkedRequestsFree = new CorkedRequest(this);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Writable": "function Writable(options) {\n    Duplex = Duplex || __webpack_require__(422);\n    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n        return new Writable(options);\n    }\n    this._writableState = new WritableState(options, this);\n    this.writable = true;\n    if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n    }\n    Stream.call(this);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----validChunk": "function validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    var er = false;\n    if (chunk === null) {\n        er = new TypeError(\"May not write null values to stream\");\n    } else if (typeof chunk !== \"string\" && chunk !== undefined && !state.objectMode) {\n        er = new TypeError(\"Invalid non-string/buffer chunk\");\n    }\n    if (er) {\n        stream.emit(\"error\", er);\n        pna.nextTick(cb, er);\n        valid = false;\n    }\n    return valid;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----writeOrBuffer": "function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n    if (!isBuf) {\n        var newChunk = decodeChunk(state, chunk, encoding);\n        if (chunk !== newChunk) {\n            isBuf = true;\n            encoding = \"buffer\";\n            chunk = newChunk;\n        }\n    }\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = {\n            chunk: chunk,\n            encoding: encoding,\n            isBuf: isBuf,\n            callback: cb,\n            next: null\n        };\n        if (last) {\n            last.next = state.lastBufferedRequest;\n        } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n        }\n        state.bufferedRequestCount += 1;\n    } else {\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----doWrite": "function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----onwriteStateUpdate": "function onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----onwrite": "function onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb); else {\n        var finished = needFinish(state);\n        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            asyncWrite(afterWrite, stream, state, finished, cb);\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----afterWrite": "function afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----clearBuffer": "function clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n    if (stream._writev && entry && entry.next) {\n        var l = state.bufferedRequestCount;\n        var buffer = new Array(l);\n        var holder = state.corkedRequestsFree;\n        holder.entry = entry;\n        var count = 0;\n        var allBuffers = true;\n        while (entry) {\n            buffer[count] = entry;\n            if (!entry.isBuf) allBuffers = false;\n            entry = entry.next;\n            count += 1;\n        }\n        buffer.allBuffers = allBuffers;\n        doWrite(stream, state, true, state.length, buffer, \"\", holder.finish);\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n        if (holder.next) {\n            state.corkedRequestsFree = holder.next;\n            holder.next = null;\n        } else {\n            state.corkedRequestsFree = new CorkedRequest(state);\n        }\n        state.bufferedRequestCount = 0;\n    } else {\n        while (entry) {\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            state.bufferedRequestCount--;\n            if (state.writing) {\n                break;\n            }\n        }\n        if (entry === null) state.lastBufferedRequest = null;\n    }\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----endWritable": "function endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) pna.nextTick(cb); else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n    stream.writable = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----onCorkedFinish": "function onCorkedFinish(corkReq, state, err) {\n    var entry = corkReq.entry;\n    corkReq.entry = null;\n    while (entry) {\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n        state.corkedRequestsFree.next = corkReq;\n    } else {\n        state.corkedRequestsFree = corkReq;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----deprecate": "function deprecate(fn, msg) {\n    if (config(\"noDeprecation\")) {\n        return fn;\n    }\n    var warned = false;\n    function deprecated() {\n        if (!warned) {\n            if (config(\"throwDeprecation\")) {\n                throw new Error(msg);\n            } else if (config(\"traceDeprecation\")) {\n                console.trace(msg);\n            } else {\n                console.warn(msg);\n            }\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n    return deprecated;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----config": "function config(name) {\n    try {\n        if (!global.localStorage) return false;\n    } catch (_) {\n        return false;\n    }\n    var val = global.localStorage[name];\n    if (null == val) return false;\n    return String(val).toLowerCase() === \"true\";\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----StringDecoder": "function StringDecoder(encoding) {\n    this.encoding = normalizeEncoding(encoding);\n    var nb;\n    switch (this.encoding) {\n      case \"utf16le\":\n        this.text = utf16Text;\n        this.end = utf16End;\n        nb = 4;\n        break;\n\n      case \"utf8\":\n        this.fillLast = utf8FillLast;\n        nb = 4;\n        break;\n\n      case \"base64\":\n        this.text = base64Text;\n        this.end = base64End;\n        nb = 3;\n        break;\n\n      default:\n        this.write = simpleWrite;\n        this.end = simpleEnd;\n        return;\n    }\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = Buffer.allocUnsafe(nb);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf8CheckIncomplete": "function utf8CheckIncomplete(self, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 1;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 2;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) {\n            if (nb === 2) nb = 0; else self.lastNeed = nb - 3;\n        }\n        return nb;\n    }\n    return 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf8FillLast": "function utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = utf8CheckExtraBytes(this, buf, p);\n    if (r !== undefined) return r;\n    if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, p, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf8Text": "function utf8Text(buf, i) {\n    var total = utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString(\"utf8\", i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString(\"utf8\", i, end);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----utf16Text": "function utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n        var r = buf.toString(\"utf16le\", i);\n        if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 55296 && c <= 56319) {\n                this.lastNeed = 2;\n                this.lastTotal = 4;\n                this.lastChar[0] = buf[buf.length - 2];\n                this.lastChar[1] = buf[buf.length - 1];\n                return r.slice(0, -1);\n            }\n        }\n        return r;\n    }\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString(\"utf16le\", i, buf.length - 1);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----base64Text": "function base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString(\"base64\", i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n    if (n === 1) {\n        this.lastChar[0] = buf[buf.length - 1];\n    } else {\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n    }\n    return buf.toString(\"base64\", i, buf.length - n);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----afterTransform": "function afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (!cb) {\n        return this.emit(\"error\", new Error(\"write callback called multiple times\"));\n    }\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null) this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        this._read(rs.highWaterMark);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Transform": "function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n        afterTransform: afterTransform.bind(this),\n        needTransform: false,\n        transforming: false,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n    };\n    this._readableState.needReadable = true;\n    this._readableState.sync = false;\n    if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    this.on(\"prefinish\", prefinish);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----done": "function done(stream, er, data) {\n    if (er) return stream.emit(\"error\", er);\n    if (data != null) stream.push(data);\n    if (stream._writableState.length) throw new Error(\"Calling transform done when ws.length != 0\");\n    if (stream._transformState.transforming) throw new Error(\"Calling transform done when still transforming\");\n    return stream.push(null);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----formatSet": "function formatSet(data, options) {\n    options = options || {};\n    var values = data.values;\n    if (options.convertEmptyValues) {\n        values = filterEmptySetValues(data);\n        if (values.length === 0) {\n            return AWS.DynamoDB.Converter.input(null);\n        }\n    }\n    var map = {};\n    switch (data.type) {\n      case \"String\":\n        map[\"SS\"] = values;\n        break;\n\n      case \"Binary\":\n        map[\"BS\"] = values;\n        break;\n\n      case \"Number\":\n        map[\"NS\"] = values.map(function(value) {\n            return value.toString();\n        });\n    }\n    return map;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----filterEmptySetValues": "function filterEmptySetValues(set) {\n    var nonEmptyValues = [];\n    var potentiallyEmptyTypes = {\n        String: true,\n        Binary: true,\n        Number: false\n    };\n    if (potentiallyEmptyTypes[set.type]) {\n        for (var i = 0; i < set.values.length; i++) {\n            if (set.values[i].length === 0) {\n                continue;\n            }\n            nonEmptyValues.push(set.values[i]);\n        }\n        return nonEmptyValues;\n    }\n    return set.values;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----isBinary": "function isBinary(data) {\n    var types = [ \"Buffer\", \"File\", \"Blob\", \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\" ];\n    if (util.isNode()) {\n        var Stream = util.stream.Stream;\n        if (util.Buffer.isBuffer(data) || data instanceof Stream) {\n            return true;\n        }\n    }\n    for (var i = 0; i < types.length; i++) {\n        if (data !== undefined && data.constructor) {\n            if (util.isType(data, types[i])) return true;\n            if (util.typeName(data.constructor) === types[i]) return true;\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Hash": "function Hash(blockSize, finalSize) {\n    this._block = new Buffer(blockSize);\n    this._finalSize = finalSize;\n    this._blockSize = blockSize;\n    this._len = 0;\n    this._s = 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----sha1_ft": "function sha1_ft(t, b, c, d) {\n    if (t < 20) return b & c | ~b & d;\n    if (t < 40) return b ^ c ^ d;\n    if (t < 60) return b & c | b & d | c & d;\n    return b ^ c ^ d;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----core_md5": "function core_md5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (var i = 0; i < x.length; i += 16) {\n        var olda = a;\n        var oldb = b;\n        var oldc = c;\n        var oldd = d;\n        a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n        d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n        a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n        c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n        d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safe_add(a, olda);\n        b = safe_add(b, oldb);\n        c = safe_add(c, oldc);\n        d = safe_add(d, oldd);\n    }\n    return Array(a, b, c, d);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----toArray": "function toArray(buf, bigEndian) {\n    if (buf.length % intSize !== 0) {\n        var len = buf.length + (intSize - buf.length % intSize);\n        buf = Buffer.concat([ buf, zeroBuffer ], len);\n    }\n    var arr = [];\n    var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n    for (var i = 0; i < buf.length; i += intSize) {\n        arr.push(fn.call(buf, i));\n    }\n    return arr;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----toBuffer": "function toBuffer(arr, size, bigEndian) {\n    var buf = new Buffer(size);\n    var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n    for (var i = 0; i < arr.length; i++) {\n        fn.call(buf, arr[i], i * 4, true);\n    }\n    return buf;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----ripemd160": "function ripemd160(message) {\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof message == \"string\") message = new Buffer(message, \"utf8\");\n    var m = bytesToWords(message);\n    var nBitsLeft = message.length * 8;\n    var nBitsTotal = message.length * 8;\n    m[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    m[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;\n    for (var i = 0; i < m.length; i += 16) {\n        processBlock(H, m, i);\n    }\n    for (var i = 0; i < 5; i++) {\n        var H_i = H[i];\n        H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;\n    }\n    var digestbytes = wordsToBytes(H);\n    return new Buffer(digestbytes);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----pbkdf2Sync": "function pbkdf2Sync(password, salt, iterations, keylen, digest) {\n    if (\"number\" !== typeof iterations) throw new TypeError(\"Iterations not a number\");\n    if (iterations < 0) throw new TypeError(\"Bad iterations\");\n    if (\"number\" !== typeof keylen) throw new TypeError(\"Key length not a number\");\n    if (keylen < 0) throw new TypeError(\"Bad key length\");\n    digest = digest || \"sha1\";\n    if (!Buffer.isBuffer(password)) password = new Buffer(password);\n    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt);\n    var hLen, l = 1, r, T;\n    var DK = new Buffer(keylen);\n    var block1 = new Buffer(salt.length + 4);\n    salt.copy(block1, 0, 0, salt.length);\n    for (var i = 1; i <= l; i++) {\n        block1.writeUInt32BE(i, salt.length);\n        var U = crypto.createHmac(digest, password).update(block1).digest();\n        if (!hLen) {\n            hLen = U.length;\n            T = new Buffer(hLen);\n            l = Math.ceil(keylen / hLen);\n            r = keylen - (l - 1) * hLen;\n            if (keylen > (Math.pow(2, 32) - 1) * hLen) throw new TypeError(\"keylen exceeds maximum length\");\n        }\n        U.copy(T, 0, 0, hLen);\n        for (var j = 1; j < iterations; j++) {\n            U = crypto.createHmac(digest, password).update(U).digest();\n            for (var k = 0; k < hLen; k++) {\n                T[k] ^= U[k];\n            }\n        }\n        var destPos = (i - 1) * hLen;\n        var len = i == l ? r : hLen;\n        T.copy(DK, destPos, 0, len);\n    }\n    return DK;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Cipher": "function Cipher(mode, key, iv) {\n    if (!(this instanceof Cipher)) {\n        return new Cipher(mode, key, iv);\n    }\n    Transform.call(this);\n    this._cache = new Splitter();\n    this._cipher = new aes.AES(key);\n    this._prev = new Buffer(iv.length);\n    iv.copy(this._prev);\n    this._mode = mode;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----createCipheriv": "function createCipheriv(suite, password, iv) {\n    var config = modes[suite];\n    if (!config) {\n        throw new TypeError(\"invalid suite type\");\n    }\n    if (typeof iv === \"string\") {\n        iv = new Buffer(iv);\n    }\n    if (typeof password === \"string\") {\n        password = new Buffer(password);\n    }\n    if (password.length !== config.key / 8) {\n        throw new TypeError(\"invalid key length \" + password.length);\n    }\n    if (iv.length !== config.iv) {\n        throw new TypeError(\"invalid iv length \" + iv.length);\n    }\n    if (config.type === \"stream\") {\n        return new StreamCipher(modelist[config.mode], password, iv);\n    }\n    return new Cipher(modelist[config.mode], password, iv);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----createCipher": "function createCipher(suite, password) {\n    var config = modes[suite];\n    if (!config) {\n        throw new TypeError(\"invalid suite type\");\n    }\n    var keys = ebtk(crypto, password, config.key, config.iv);\n    return createCipheriv(suite, keys.key, keys.iv);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Global": "function Global() {\n    var i;\n    this.SBOX = [];\n    this.INV_SBOX = [];\n    this.SUB_MIX = function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 4; i = ++_i) {\n            _results.push([]);\n        }\n        return _results;\n    }();\n    this.INV_SUB_MIX = function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 4; i = ++_i) {\n            _results.push([]);\n        }\n        return _results;\n    }();\n    this.init();\n    this.RCON = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----bufferToArray": "function bufferToArray(buf) {\n    var len = buf.length / 4;\n    var out = new Array(len);\n    var i = -1;\n    while (++i < len) {\n        out[i] = buf.readUInt32BE(i * 4);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----StreamCipher": "function StreamCipher(mode, key, iv, decrypt) {\n    if (!(this instanceof StreamCipher)) {\n        return new StreamCipher(mode, key, iv);\n    }\n    Transform.call(this);\n    this._cipher = new aes.AES(key);\n    this._prev = new Buffer(iv.length);\n    this._cache = new Buffer(\"\");\n    this._secCache = new Buffer(\"\");\n    this._decrypt = decrypt;\n    iv.copy(this._prev);\n    this._mode = mode;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----xor": "function xor(a, b) {\n    var len = Math.min(a.length, b.length);\n    var out = new Buffer(len);\n    var i = -1;\n    while (++i < len) {\n        out.writeUInt8(a[i] ^ b[i], i);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----encryptStart": "function encryptStart(self, data, decrypt) {\n    var len = data.length;\n    var out = xor(data, self._cache);\n    self._cache = self._cache.slice(len);\n    self._prev = Buffer.concat([ self._prev, decrypt ? data : out ]);\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----Decipher": "function Decipher(mode, key, iv) {\n    if (!(this instanceof Decipher)) {\n        return new Decipher(mode, key, iv);\n    }\n    Transform.call(this);\n    this._cache = new Splitter();\n    this._last = void 0;\n    this._cipher = new aes.AES(key);\n    this._prev = new Buffer(iv.length);\n    iv.copy(this._prev);\n    this._mode = mode;\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----createDecipheriv": "function createDecipheriv(suite, password, iv) {\n    var config = modes[suite];\n    if (!config) {\n        throw new TypeError(\"invalid suite type\");\n    }\n    if (typeof iv === \"string\") {\n        iv = new Buffer(iv);\n    }\n    if (typeof password === \"string\") {\n        password = new Buffer(password);\n    }\n    if (password.length !== config.key / 8) {\n        throw new TypeError(\"invalid key length \" + password.length);\n    }\n    if (iv.length !== config.iv) {\n        throw new TypeError(\"invalid iv length \" + iv.length);\n    }\n    if (config.type === \"stream\") {\n        return new StreamCipher(modelist[config.mode], password, iv, true);\n    }\n    return new Decipher(modelist[config.mode], password, iv);\n}",
	"node_modules/aws-sdk/dist/aws-sdk-react-native----createDecipher": "function createDecipher(suite, password) {\n    var config = modes[suite];\n    if (!config) {\n        throw new TypeError(\"invalid suite type\");\n    }\n    var keys = ebtk(crypto, password, config.key, config.iv);\n    return createDecipheriv(suite, keys.key, keys.iv);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Hmac": "function Hmac(hashCtor, secret) {\n    this.hash = new hashCtor();\n    this.outer = new hashCtor();\n    var inner = bufferFromSecret(hashCtor, secret);\n    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);\n    outer.set(inner);\n    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {\n        inner[i] ^= 54;\n        outer[i] ^= 92;\n    }\n    this.hash.update(inner);\n    this.outer.update(outer);\n    for (var i = 0; i < inner.byteLength; i++) {\n        inner[i] = 0;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----bufferFromSecret": "function bufferFromSecret(hashCtor, secret) {\n    var input = hashUtils.convertToBuffer(secret);\n    if (input.byteLength > hashCtor.BLOCK_SIZE) {\n        var bufferHash = new hashCtor();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n    }\n    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\n    buffer.set(input);\n    return buffer;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Md5": "function Md5() {\n    this.state = [ 1732584193, 4023233417, 2562383102, 271733878 ];\n    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Sha1": "function Sha1() {\n    this.h0 = 1732584193;\n    this.h1 = 4023233417;\n    this.h2 = 2562383102;\n    this.h3 = 271733878;\n    this.h4 = 3285377520;\n    this.block = new Uint32Array(80);\n    this.offset = 0;\n    this.shift = 24;\n    this.totalLength = 0;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Sha256": "function Sha256() {\n    this.state = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(64);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----resolveRegionalEndpointsFlag": "function resolveRegionalEndpointsFlag(originalConfig, options) {\n    originalConfig = originalConfig || {};\n    var resolved;\n    if (originalConfig[options.clientConfig]) {\n        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {\n            code: \"InvalidConfiguration\",\n            message: 'invalid \"' + options.clientConfig + '\" configuration. Expect \"legacy\" ' + ' or \"regional\". Got \"' + originalConfig[options.clientConfig] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    if (!AWS.util.isNode()) return resolved;\n    if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {\n        var envFlag = process.env[options.env];\n        resolved = validateRegionalEndpointsFlagValue(envFlag, {\n            code: \"InvalidEnvironmentalVariable\",\n            message: \"invalid \" + options.env + ' environmental variable. Expect \"legacy\" ' + ' or \"regional\". Got \"' + process.env[options.env] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    var profile = {};\n    try {\n        var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);\n        profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];\n    } catch (e) {}\n    if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {\n        var fileFlag = profile[options.sharedConfig];\n        resolved = validateRegionalEndpointsFlagValue(fileFlag, {\n            code: \"InvalidConfiguration\",\n            message: \"invalid \" + options.sharedConfig + ' profile config. Expect \"legacy\" ' + ' or \"regional\". Got \"' + profile[options.sharedConfig] + '\".'\n        });\n        if (resolved) return resolved;\n    }\n    return resolved;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----resolveNext": "function resolveNext(err, creds) {\n    if (!err && creds || index === providers.length) {\n        AWS.util.arrayEach(self.resolveCallbacks, function(callback) {\n            callback(err, creds);\n        });\n        self.resolveCallbacks.length = 0;\n        return;\n    }\n    var provider = providers[index++];\n    if (typeof provider === \"function\") {\n        creds = provider.call();\n    } else {\n        creds = provider;\n    }\n    if (creds.get) {\n        creds.get(function(getErr) {\n            resolveNext(getErr, getErr ? null : creds);\n        });\n    } else {\n        resolveNext(null, creds);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----getCacheKey": "function getCacheKey(request) {\n    var service = request.service;\n    var api = service.api || {};\n    var operations = api.operations;\n    var identifiers = {};\n    if (service.config.region) {\n        identifiers.region = service.config.region;\n    }\n    if (api.serviceId) {\n        identifiers.serviceId = api.serviceId;\n    }\n    if (service.config.credentials.accessKeyId) {\n        identifiers.accessKeyId = service.config.credentials.accessKeyId;\n    }\n    return identifiers;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----optionalDiscoverEndpoint": "function optionalDiscoverEndpoint(request) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var endpoints = AWS.endpointCache.get(cacheKey);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        addApiVersionHeader(endpointRequest);\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        endpointRequest.removeListener(\"retry\", AWS.EventListeners.Core.RETRY_CHECK);\n        AWS.endpointCache.put(cacheKey, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 1\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (data && data.Endpoints) {\n                AWS.endpointCache.put(cacheKey, data.Endpoints);\n            } else if (err) {\n                AWS.endpointCache.put(cacheKey, [ {\n                    Address: \"\",\n                    CachePeriodInMinutes: 1\n                } ]);\n            }\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----requiredDiscoverEndpoint": "function requiredDiscoverEndpoint(request, done) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n    var endpoints = AWS.endpointCache.get(cacheKeyStr);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n        requestQueue[cacheKeyStr].push({\n            request: request,\n            callback: done\n        });\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n        done();\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        addApiVersionHeader(endpointRequest);\n        AWS.endpointCache.put(cacheKeyStr, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 60\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (err) {\n                request.response.error = util.error(err, {\n                    retryable: false\n                });\n                AWS.endpointCache.remove(cacheKey);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.response.error = util.error(err, {\n                            retryable: false\n                        });\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            } else if (data) {\n                AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n                request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            }\n            done();\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----hasCustomEndpoint": "function hasCustomEndpoint(client) {\n    if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n        throw util.error(new Error(), {\n            code: \"ConfigurationException\",\n            message: \"Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.\"\n        });\n    }\n    var svcConfig = AWS.config[client.serviceIdentifier] || {};\n    return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----resolveEndpointDiscoveryConfig": "function resolveEndpointDiscoveryConfig(request) {\n    var service = request.service || {};\n    if (service.config.endpointDiscoveryEnabled !== undefined) {\n        return service.config.endpointDiscoveryEnabled;\n    }\n    if (util.isBrowser()) return undefined;\n    for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n        var env = endpointDiscoveryEnabledEnvs[i];\n        if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n            if (process.env[env] === \"\" || process.env[env] === undefined) {\n                throw util.error(new Error(), {\n                    code: \"ConfigurationException\",\n                    message: \"environmental variable \" + env + \" cannot be set to nothing\"\n                });\n            }\n            return !isFalsy(process.env[env]);\n        }\n    }\n    var configFile = {};\n    try {\n        configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n            isConfig: true,\n            filename: process.env[AWS.util.sharedConfigFileEnv]\n        }) : {};\n    } catch (e) {}\n    var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};\n    if (Object.prototype.hasOwnProperty.call(sharedFileConfig, \"endpoint_discovery_enabled\")) {\n        if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n            throw util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"config file entry 'endpoint_discovery_enabled' cannot be set to nothing\"\n            });\n        }\n        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);\n    }\n    return undefined;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----discoverEndpoint": "function discoverEndpoint(request, done) {\n    var service = request.service || {};\n    if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n    var operations = service.api.operations || {};\n    var operationModel = operations[request.operation];\n    var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : \"NULL\";\n    var isEnabled = resolveEndpointDiscoveryConfig(request);\n    var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;\n    if (isEnabled || hasRequiredEndpointDiscovery) {\n        request.httpRequest.appendToUserAgent(\"endpoint-discovery\");\n    }\n    switch (isEndpointDiscoveryRequired) {\n      case \"OPTIONAL\":\n        if (isEnabled || hasRequiredEndpointDiscovery) {\n            optionalDiscoverEndpoint(request);\n            request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        }\n        done();\n        break;\n\n      case \"REQUIRED\":\n        if (isEnabled === false) {\n            request.response.error = util.error(new Error(), {\n                code: \"ConfigurationException\",\n                message: \"Endpoint Discovery is disabled but \" + service.api.className + \".\" + request.operation + \"() requires it. Please check your configurations.\"\n            });\n            done();\n            break;\n        }\n        request.addNamedListener(\"INVALIDATE_CACHED_ENDPOINTS\", \"extractError\", invalidateCachedEndpoints);\n        requiredDiscoverEndpoint(request, done);\n        break;\n\n      case \"NULL\":\n      default:\n        done();\n        break;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----formatSet": "function formatSet(data, options) {\n    options = options || {};\n    var values = data.values;\n    if (options.convertEmptyValues) {\n        values = filterEmptySetValues(data);\n        if (values.length === 0) {\n            return AWS.DynamoDB.Converter.input(null);\n        }\n    }\n    var map = {};\n    switch (data.type) {\n      case \"String\":\n        map[\"SS\"] = values;\n        break;\n\n      case \"Binary\":\n        map[\"BS\"] = values;\n        break;\n\n      case \"Number\":\n        map[\"NS\"] = values.map(function(value) {\n            return value.toString();\n        });\n    }\n    return map;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----filterEmptySetValues": "function filterEmptySetValues(set) {\n    var nonEmptyValues = [];\n    var potentiallyEmptyTypes = {\n        String: true,\n        Binary: true,\n        Number: false\n    };\n    if (potentiallyEmptyTypes[set.type]) {\n        for (var i = 0; i < set.values.length; i++) {\n            if (set.values[i].length === 0) {\n                continue;\n            }\n            nonEmptyValues.push(set.values[i]);\n        }\n        return nonEmptyValues;\n    }\n    return set.values;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----isBinary": "function isBinary(data) {\n    var types = [ \"Buffer\", \"File\", \"Blob\", \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\" ];\n    if (util.isNode()) {\n        var Stream = util.stream.Stream;\n        if (util.Buffer.isBuffer(data) || data instanceof Stream) {\n            return true;\n        }\n    }\n    for (var i = 0; i < types.length; i++) {\n        if (data !== undefined && data.constructor) {\n            if (util.isType(data, types[i])) return true;\n            if (util.typeName(data.constructor) === types[i]) return true;\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----createEventStream": "function createEventStream(body, parser, model) {\n    var eventMessages = eventMessageChunker(body);\n    var events = [];\n    for (var i = 0; i < eventMessages.length; i++) {\n        events.push(parseEvent(parser, eventMessages[i], model));\n    }\n    return events;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----eventMessageChunker": "function eventMessageChunker(buffer) {\n    var messages = [];\n    var offset = 0;\n    while (offset < buffer.length) {\n        var totalLength = buffer.readInt32BE(offset);\n        var message = buffer.slice(offset, totalLength + offset);\n        offset += totalLength;\n        messages.push(message);\n    }\n    return messages;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseEvent": "function parseEvent(parser, message, shape) {\n    var parsedMessage = parseMessage(message);\n    var messageType = parsedMessage.headers[\":message-type\"];\n    if (messageType) {\n        if (messageType.value === \"error\") {\n            throw parseError(parsedMessage);\n        } else if (messageType.value !== \"event\") {\n            return;\n        }\n    }\n    var eventType = parsedMessage.headers[\":event-type\"];\n    var eventModel = shape.members[eventType.value];\n    if (!eventModel) {\n        return;\n    }\n    var result = {};\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n    if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName];\n        if (payloadShape.type === \"binary\") {\n            result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n    }\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\n    for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n        if (parsedMessage.headers[name]) {\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n    }\n    var output = {};\n    output[eventType.value] = result;\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseError": "function parseError(message) {\n    var errorCode = message.headers[\":error-code\"];\n    var errorMessage = message.headers[\":error-message\"];\n    var error = new Error(errorMessage.value || errorMessage);\n    error.code = error.name = errorCode.value || errorCode;\n    return error;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseHeaders": "function parseHeaders(headers) {\n    var out = {};\n    var position = 0;\n    while (position < headers.length) {\n        var nameLength = headers.readUInt8(position++);\n        var name = headers.slice(position, position + nameLength).toString();\n        position += nameLength;\n        switch (headers.readUInt8(position++)) {\n          case 0:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: true\n            };\n            break;\n\n          case 1:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: false\n            };\n            break;\n\n          case 2:\n            out[name] = {\n                type: BYTE_TAG,\n                value: headers.readInt8(position++)\n            };\n            break;\n\n          case 3:\n            out[name] = {\n                type: SHORT_TAG,\n                value: headers.readInt16BE(position)\n            };\n            position += 2;\n            break;\n\n          case 4:\n            out[name] = {\n                type: INT_TAG,\n                value: headers.readInt32BE(position)\n            };\n            position += 4;\n            break;\n\n          case 5:\n            out[name] = {\n                type: LONG_TAG,\n                value: new Int64(headers.slice(position, position + 8))\n            };\n            position += 8;\n            break;\n\n          case 6:\n            var binaryLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: BINARY_TAG,\n                value: headers.slice(position, position + binaryLength)\n            };\n            position += binaryLength;\n            break;\n\n          case 7:\n            var stringLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: STRING_TAG,\n                value: headers.slice(position, position + stringLength).toString()\n            };\n            position += stringLength;\n            break;\n\n          case 8:\n            out[name] = {\n                type: TIMESTAMP_TAG,\n                value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())\n            };\n            position += 8;\n            break;\n\n          case 9:\n            var uuidChars = headers.slice(position, position + 16).toString(\"hex\");\n            position += 16;\n            out[name] = {\n                type: UUID_TAG,\n                value: uuidChars.substr(0, 8) + \"-\" + uuidChars.substr(8, 4) + \"-\" + uuidChars.substr(12, 4) + \"-\" + uuidChars.substr(16, 4) + \"-\" + uuidChars.substr(20)\n            };\n            break;\n\n          default:\n            throw new Error(\"Unrecognized header type tag\");\n        }\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----splitMessage": "function splitMessage(message) {\n    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\n    if (message.length < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    if (message.length !== message.readUInt32BE(0)) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\n    if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {\n        throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum.\");\n    }\n    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\n    if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {\n        throw new Error(\"The message checksum did not match the expected value of \" + expectedMessageChecksum);\n    }\n    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\n    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\n    return {\n        headers: message.slice(headersStart, headersEnd),\n        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk----callback": "function callback(httpResp) {\n    resp.httpResponse.stream = httpResp;\n    var stream = resp.request.httpRequest.stream;\n    var service = resp.request.service;\n    var api = service.api;\n    var operationName = resp.request.operation;\n    var operation = api.operations[operationName] || {};\n    httpResp.on(\"headers\", function onHeaders(statusCode, headers, statusMessage) {\n        resp.request.emit(\"httpHeaders\", [ statusCode, headers, resp, statusMessage ]);\n        if (!resp.httpResponse.streaming) {\n            if (AWS.HttpClient.streamsApiVersion === 2) {\n                if (operation.hasEventOutput && service.successfulResponse(resp)) {\n                    resp.request.emit(\"httpDone\");\n                    done();\n                    return;\n                }\n                httpResp.on(\"readable\", function onReadable() {\n                    var data = httpResp.read();\n                    if (data !== null) {\n                        resp.request.emit(\"httpData\", [ data, resp ]);\n                    }\n                });\n            } else {\n                httpResp.on(\"data\", function onData(data) {\n                    resp.request.emit(\"httpData\", [ data, resp ]);\n                });\n            }\n        }\n    });\n    httpResp.on(\"end\", function onEnd() {\n        if (!stream || !stream.didCallback) {\n            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {\n                return;\n            }\n            resp.request.emit(\"httpDone\");\n            done();\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk----buildMessage": "function buildMessage() {\n    var time = resp.request.service.getSkewCorrectedDate().getTime();\n    var delta = (time - req.startTime.getTime()) / 1e3;\n    var ansi = logger.isTTY ? true : false;\n    var status = resp.httpResponse.statusCode;\n    var censoredParams = req.params;\n    if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {\n        var inputShape = req.service.api.operations[req.operation].input;\n        censoredParams = filterSensitiveLog(inputShape, req.params);\n    }\n    var params = require(\"util\").inspect(censoredParams, true, null);\n    var message = \"\";\n    if (ansi) message += \"\u001b[33m\";\n    message += \"[AWS \" + req.service.serviceIdentifier + \" \" + status;\n    message += \" \" + delta.toString() + \"s \" + resp.retryCount + \" retries]\";\n    if (ansi) message += \"\u001b[0;1m\";\n    message += \" \" + AWS.util.string.lowerFirst(req.operation);\n    message += \"(\" + params + \")\";\n    if (ansi) message += \"\u001b[0m\";\n    return message;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----translateStructure": "function translateStructure(structure, shape) {\n    if (structure == null) return undefined;\n    if (shape.isDocument) return structure;\n    var struct = {};\n    var shapeMembers = shape.members;\n    util.each(shapeMembers, function(name, memberShape) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n            var value = structure[locationName];\n            var result = translate(value, memberShape);\n            if (result !== undefined) struct[name] = result;\n        }\n    });\n    return struct;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----translateList": "function translateList(list, shape) {\n    if (list == null) return undefined;\n    var out = [];\n    util.arrayEach(list, function(value) {\n        var result = translate(value, shape.member);\n        if (result === undefined) out.push(null); else out.push(result);\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----translateMap": "function translateMap(map, shape) {\n    if (map == null) return undefined;\n    var out = {};\n    util.each(map, function(key, value) {\n        var result = translate(value, shape.value);\n        if (result === undefined) out[key] = null; else out[key] = result;\n    });\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Api": "function Api(api, options) {\n    var self = this;\n    api = api || {};\n    options = options || {};\n    options.api = this;\n    api.metadata = api.metadata || {};\n    var serviceIdentifier = options.serviceIdentifier;\n    delete options.serviceIdentifier;\n    property(this, \"isApi\", true, false);\n    property(this, \"apiVersion\", api.metadata.apiVersion);\n    property(this, \"endpointPrefix\", api.metadata.endpointPrefix);\n    property(this, \"signingName\", api.metadata.signingName);\n    property(this, \"globalEndpoint\", api.metadata.globalEndpoint);\n    property(this, \"signatureVersion\", api.metadata.signatureVersion);\n    property(this, \"jsonVersion\", api.metadata.jsonVersion);\n    property(this, \"targetPrefix\", api.metadata.targetPrefix);\n    property(this, \"protocol\", api.metadata.protocol);\n    property(this, \"timestampFormat\", api.metadata.timestampFormat);\n    property(this, \"xmlNamespaceUri\", api.metadata.xmlNamespace);\n    property(this, \"abbreviation\", api.metadata.serviceAbbreviation);\n    property(this, \"fullName\", api.metadata.serviceFullName);\n    property(this, \"serviceId\", api.metadata.serviceId);\n    if (serviceIdentifier && metadata[serviceIdentifier]) {\n        property(this, \"xmlNoDefaultLists\", metadata[serviceIdentifier].xmlNoDefaultLists, false);\n    }\n    memoizedProperty(this, \"className\", function() {\n        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;\n        if (!name) return null;\n        name = name.replace(/^Amazon|AWS\\s*|\\(.*|\\s+|\\W+/g, \"\");\n        if (name === \"ElasticLoadBalancing\") name = \"ELB\";\n        return name;\n    });\n    function addEndpointOperation(name, operation) {\n        if (operation.endpointoperation === true) {\n            property(self, \"endpointOperation\", util.string.lowerFirst(name));\n        }\n        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {\n            property(self, \"hasRequiredEndpointDiscovery\", operation.endpointdiscovery.required === true);\n        }\n    }\n    property(this, \"operations\", new Collection(api.operations, options, function(name, operation) {\n        return new Operation(name, operation, options);\n    }, util.string.lowerFirst, addEndpointOperation));\n    property(this, \"shapes\", new Collection(api.shapes, options, function(name, shape) {\n        return Shape.create(shape, options);\n    }));\n    property(this, \"paginators\", new Collection(api.paginators, options, function(name, paginator) {\n        return new Paginator(name, paginator, options);\n    }));\n    property(this, \"waiters\", new Collection(api.waiters, options, function(name, waiter) {\n        return new ResourceWaiter(name, waiter, options);\n    }, util.string.lowerFirst));\n    if (options.documentation) {\n        property(this, \"documentation\", api.documentation);\n        property(this, \"documentationUrl\", api.documentationUrl);\n    }\n    property(this, \"errorCodeMapping\", api.awsQueryCompatible);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Operation": "function Operation(name, operation, options) {\n    var self = this;\n    options = options || {};\n    property(this, \"name\", operation.name || name);\n    property(this, \"api\", options.api, false);\n    operation.http = operation.http || {};\n    property(this, \"endpoint\", operation.endpoint);\n    property(this, \"httpMethod\", operation.http.method || \"POST\");\n    property(this, \"httpPath\", operation.http.requestUri || \"/\");\n    property(this, \"authtype\", operation.authtype || \"\");\n    property(this, \"endpointDiscoveryRequired\", operation.endpointdiscovery ? operation.endpointdiscovery.required ? \"REQUIRED\" : \"OPTIONAL\" : \"NULL\");\n    var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;\n    property(this, \"httpChecksumRequired\", httpChecksumRequired, false);\n    memoizedProperty(this, \"input\", function() {\n        if (!operation.input) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.input, options);\n    });\n    memoizedProperty(this, \"output\", function() {\n        if (!operation.output) {\n            return new Shape.create({\n                type: \"structure\"\n            }, options);\n        }\n        return Shape.create(operation.output, options);\n    });\n    memoizedProperty(this, \"errors\", function() {\n        var list = [];\n        if (!operation.errors) return null;\n        for (var i = 0; i < operation.errors.length; i++) {\n            list.push(Shape.create(operation.errors[i], options));\n        }\n        return list;\n    });\n    memoizedProperty(this, \"paginator\", function() {\n        return options.api.paginators[name];\n    });\n    if (options.documentation) {\n        property(this, \"documentation\", operation.documentation);\n        property(this, \"documentationUrl\", operation.documentationUrl);\n    }\n    memoizedProperty(this, \"idempotentMembers\", function() {\n        var idempotentMembers = [];\n        var input = self.input;\n        var members = input.members;\n        if (!input.members) {\n            return idempotentMembers;\n        }\n        for (var name in members) {\n            if (!members.hasOwnProperty(name)) {\n                continue;\n            }\n            if (members[name].isIdempotent === true) {\n                idempotentMembers.push(name);\n            }\n        }\n        return idempotentMembers;\n    });\n    memoizedProperty(this, \"hasEventOutput\", function() {\n        var output = self.output;\n        return hasEventStream(output);\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk----hasEventStream": "function hasEventStream(topLevelShape) {\n    var members = topLevelShape.members;\n    var payload = topLevelShape.payload;\n    if (!topLevelShape.members) {\n        return false;\n    }\n    if (payload) {\n        var payloadMember = members[payload];\n        return payloadMember.isEventStream;\n    }\n    for (var name in members) {\n        if (!members.hasOwnProperty(name)) {\n            if (members[name].isEventStream === true) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Paginator": "function Paginator(name, paginator) {\n    property(this, \"inputToken\", paginator.input_token);\n    property(this, \"limitKey\", paginator.limit_key);\n    property(this, \"moreResults\", paginator.more_results);\n    property(this, \"outputToken\", paginator.output_token);\n    property(this, \"resultKey\", paginator.result_key);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----ResourceWaiter": "function ResourceWaiter(name, waiter, options) {\n    options = options || {};\n    property(this, \"name\", name);\n    property(this, \"api\", options.api, false);\n    if (waiter.operation) {\n        property(this, \"operation\", util.string.lowerFirst(waiter.operation));\n    }\n    var self = this;\n    var keys = [ \"type\", \"description\", \"delay\", \"maxAttempts\", \"acceptors\" ];\n    keys.forEach(function(key) {\n        var value = waiter[key];\n        if (value) {\n            property(self, key, value);\n        }\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Shape": "function Shape(shape, options, memberName) {\n    options = options || {};\n    property(this, \"shape\", shape.shape);\n    property(this, \"api\", options.api, false);\n    property(this, \"type\", shape.type);\n    property(this, \"enum\", shape.enum);\n    property(this, \"min\", shape.min);\n    property(this, \"max\", shape.max);\n    property(this, \"pattern\", shape.pattern);\n    property(this, \"location\", shape.location || this.location || \"body\");\n    property(this, \"name\", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);\n    property(this, \"isStreaming\", shape.streaming || this.isStreaming || false);\n    property(this, \"requiresLength\", shape.requiresLength, false);\n    property(this, \"isComposite\", shape.isComposite || false);\n    property(this, \"isShape\", true, false);\n    property(this, \"isQueryName\", Boolean(shape.queryName), false);\n    property(this, \"isLocationName\", Boolean(shape.locationName), false);\n    property(this, \"isIdempotent\", shape.idempotencyToken === true);\n    property(this, \"isJsonValue\", shape.jsonvalue === true);\n    property(this, \"isSensitive\", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);\n    property(this, \"isEventStream\", Boolean(shape.eventstream), false);\n    property(this, \"isEvent\", Boolean(shape.event), false);\n    property(this, \"isEventPayload\", Boolean(shape.eventpayload), false);\n    property(this, \"isEventHeader\", Boolean(shape.eventheader), false);\n    property(this, \"isTimestampFormatSet\", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);\n    property(this, \"endpointDiscoveryId\", Boolean(shape.endpointdiscoveryid), false);\n    property(this, \"hostLabel\", Boolean(shape.hostLabel), false);\n    if (options.documentation) {\n        property(this, \"documentation\", shape.documentation);\n        property(this, \"documentationUrl\", shape.documentationUrl);\n    }\n    if (shape.xmlAttribute) {\n        property(this, \"isXmlAttribute\", shape.xmlAttribute || false);\n    }\n    property(this, \"defaultValue\", null);\n    this.toWireFormat = function(value) {\n        if (value === null || value === undefined) return \"\";\n        return value;\n    };\n    this.toType = function(value) {\n        return value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk----StructureShape": "function StructureShape(shape, options) {\n    var self = this;\n    var requiredMap = null, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"members\", {});\n        property(this, \"memberNames\", []);\n        property(this, \"required\", []);\n        property(this, \"isRequired\", function() {\n            return false;\n        });\n        property(this, \"isDocument\", Boolean(shape.document));\n    }\n    if (shape.members) {\n        property(this, \"members\", new Collection(shape.members, options, function(name, member) {\n            return Shape.create(member, options, name);\n        }));\n        memoizedProperty(this, \"memberNames\", function() {\n            return shape.xmlOrder || Object.keys(shape.members);\n        });\n        if (shape.event) {\n            memoizedProperty(this, \"eventPayloadMemberName\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventPayload) {\n                        return memberNames[i];\n                    }\n                }\n            });\n            memoizedProperty(this, \"eventHeaderMemberNames\", function() {\n                var members = self.members;\n                var memberNames = self.memberNames;\n                var eventHeaderMemberNames = [];\n                for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n                    if (members[memberNames[i]].isEventHeader) {\n                        eventHeaderMemberNames.push(memberNames[i]);\n                    }\n                }\n                return eventHeaderMemberNames;\n            });\n        }\n    }\n    if (shape.required) {\n        property(this, \"required\", shape.required);\n        property(this, \"isRequired\", function(name) {\n            if (!requiredMap) {\n                requiredMap = {};\n                for (var i = 0; i < shape.required.length; i++) {\n                    requiredMap[shape.required[i]] = true;\n                }\n            }\n            return requiredMap[name];\n        }, false, true);\n    }\n    property(this, \"resultWrapper\", shape.resultWrapper || null);\n    if (shape.payload) {\n        property(this, \"payload\", shape.payload);\n    }\n    if (typeof shape.xmlNamespace === \"string\") {\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace);\n    } else if (typeof shape.xmlNamespace === \"object\") {\n        property(this, \"xmlNamespacePrefix\", shape.xmlNamespace.prefix);\n        property(this, \"xmlNamespaceUri\", shape.xmlNamespace.uri);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----ListShape": "function ListShape(shape, options) {\n    var self = this, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return [];\n        });\n    }\n    if (shape.member) {\n        memoizedProperty(this, \"member\", function() {\n            return Shape.create(shape.member, options);\n        });\n    }\n    if (this.flattened) {\n        var oldName = this.name;\n        memoizedProperty(this, \"name\", function() {\n            return self.member.name || oldName;\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----MapShape": "function MapShape(shape, options) {\n    var firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return {};\n        });\n        property(this, \"key\", Shape.create({\n            type: \"string\"\n        }, options));\n        property(this, \"value\", Shape.create({\n            type: \"string\"\n        }, options));\n    }\n    if (shape.key) {\n        memoizedProperty(this, \"key\", function() {\n            return Shape.create(shape.key, options);\n        });\n    }\n    if (shape.value) {\n        memoizedProperty(this, \"value\", function() {\n            return Shape.create(shape.value, options);\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----TimestampShape": "function TimestampShape(shape) {\n    var self = this;\n    Shape.apply(this, arguments);\n    if (shape.timestampFormat) {\n        property(this, \"timestampFormat\", shape.timestampFormat);\n    } else if (self.isTimestampFormatSet && this.timestampFormat) {\n        property(this, \"timestampFormat\", this.timestampFormat);\n    } else if (this.location === \"header\") {\n        property(this, \"timestampFormat\", \"rfc822\");\n    } else if (this.location === \"querystring\") {\n        property(this, \"timestampFormat\", \"iso8601\");\n    } else if (this.api) {\n        switch (this.api.protocol) {\n          case \"json\":\n          case \"rest-json\":\n            property(this, \"timestampFormat\", \"unixTimestamp\");\n            break;\n\n          case \"rest-xml\":\n          case \"query\":\n          case \"ec2\":\n            property(this, \"timestampFormat\", \"iso8601\");\n            break;\n        }\n    }\n    this.toType = function(value) {\n        if (value === null || value === undefined) return null;\n        if (typeof value.toUTCString === \"function\") return value;\n        return typeof value === \"string\" || typeof value === \"number\" ? util.date.parseTimestamp(value) : null;\n    };\n    this.toWireFormat = function(value) {\n        return util.date.format(value, self.timestampFormat);\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk----StringShape": "function StringShape() {\n    Shape.apply(this, arguments);\n    var nullLessProtocols = [ \"rest-xml\", \"query\", \"ec2\" ];\n    this.toType = function(value) {\n        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || \"\" : value;\n        if (this.isJsonValue) {\n            return JSON.parse(value);\n        }\n        return value && typeof value.toString === \"function\" ? value.toString() : value;\n    };\n    this.toWireFormat = function(value) {\n        return this.isJsonValue ? JSON.stringify(value) : value;\n    };\n}",
	"node_modules/aws-sdk/dist/aws-sdk----populateHostPrefix": "function populateHostPrefix(request) {\n    var enabled = request.service.config.hostPrefixEnabled;\n    if (!enabled) return request;\n    var operationModel = request.service.api.operations[request.operation];\n    if (hasEndpointDiscover(request)) return request;\n    if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {\n        var hostPrefixNotation = operationModel.endpoint.hostPrefix;\n        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);\n        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);\n        validateHostname(request.httpRequest.endpoint.hostname);\n    }\n    return request;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----hasEndpointDiscover": "function hasEndpointDiscover(request) {\n    var api = request.service.api;\n    var operationModel = api.operations[request.operation];\n    var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);\n    return operationModel.endpointDiscoveryRequired !== \"NULL\" || isEndpointOperation === true;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----buildRequest": "function buildRequest(req) {\n    populateMethod(req);\n    populateURI(req);\n    populateHeaders(req);\n    populateHostPrefix(req);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----extractError": "function extractError(resp) {\n    Rest.extractError(resp);\n    var data;\n    try {\n        data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());\n    } catch (e) {\n        data = {\n            Code: resp.httpResponse.statusCode,\n            Message: resp.httpResponse.statusMessage\n        };\n    }\n    if (data.Errors) data = data.Errors;\n    if (data.Error) data = data.Error;\n    if (data.Code) {\n        resp.error = util.error(new Error(), {\n            code: data.Code,\n            message: data.Message\n        });\n    } else {\n        resp.error = util.error(new Error(), {\n            code: resp.httpResponse.statusCode,\n            message: null\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----extractData": "function extractData(resp) {\n    Rest.extractData(resp);\n    var parser;\n    var req = resp.request;\n    var body = resp.httpResponse.body;\n    var operation = req.service.api.operations[req.operation];\n    var output = operation.output;\n    var hasEventOutput = operation.hasEventOutput;\n    var payload = output.payload;\n    if (payload) {\n        var payloadMember = output.members[payload];\n        if (payloadMember.isEventStream) {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);\n        } else if (payloadMember.type === \"structure\") {\n            parser = new AWS.XML.Parser();\n            resp.data[payload] = parser.parse(body.toString(), payloadMember);\n        } else if (payloadMember.type === \"binary\" || payloadMember.isStreaming) {\n            resp.data[payload] = body;\n        } else {\n            resp.data[payload] = payloadMember.toType(body);\n        }\n    } else if (body.length > 0) {\n        parser = new AWS.XML.Parser();\n        var data = parser.parse(body.toString(), output);\n        util.update(resp.data, data);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----generateURI": "function generateURI(endpointPath, operationPath, input, params) {\n    var uri = [ endpointPath, operationPath ].join(\"/\");\n    uri = uri.replace(/\\/+/g, \"/\");\n    var queryString = {}, queryStringSet = false;\n    util.each(input.members, function(name, member) {\n        var paramValue = params[name];\n        if (paramValue === null || paramValue === undefined) return;\n        if (member.location === \"uri\") {\n            var regex = new RegExp(\"\\\\{\" + member.name + \"(\\\\+)?\\\\}\");\n            uri = uri.replace(regex, function(_, plus) {\n                var fn = plus ? util.uriEscapePath : util.uriEscape;\n                return fn(String(paramValue));\n            });\n        } else if (member.location === \"querystring\") {\n            queryStringSet = true;\n            if (member.type === \"list\") {\n                queryString[member.name] = paramValue.map(function(val) {\n                    return util.uriEscape(member.member.toWireFormat(val).toString());\n                });\n            } else if (member.type === \"map\") {\n                util.each(paramValue, function(key, value) {\n                    if (Array.isArray(value)) {\n                        queryString[key] = value.map(function(val) {\n                            return util.uriEscape(String(val));\n                        });\n                    } else {\n                        queryString[key] = util.uriEscape(String(value));\n                    }\n                });\n            } else {\n                queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());\n            }\n        }\n    });\n    if (queryStringSet) {\n        uri += uri.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n        var parts = [];\n        util.arrayEach(Object.keys(queryString).sort(), function(key) {\n            if (!Array.isArray(queryString[key])) {\n                queryString[key] = [ queryString[key] ];\n            }\n            for (var i = 0; i < queryString[key].length; i++) {\n                parts.push(util.uriEscape(String(key)) + \"=\" + queryString[key][i]);\n            }\n        });\n        uri += parts.join(\"&\");\n    }\n    return uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----populateURI": "function populateURI(req) {\n    var operation = req.service.api.operations[req.operation];\n    var input = operation.input;\n    var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);\n    req.httpRequest.path = uri;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----populateBody": "function populateBody(req) {\n    var input = req.service.api.operations[req.operation].input;\n    var builder = new AWS.XML.Builder();\n    var params = req.params;\n    var payload = input.payload;\n    if (payload) {\n        var payloadMember = input.members[payload];\n        params = params[payload];\n        if (params === undefined) return;\n        if (payloadMember.type === \"structure\") {\n            var rootElement = payloadMember.name;\n            req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n        } else {\n            req.httpRequest.body = params;\n        }\n    } else {\n        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + \"Request\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----generateRegionPrefix": "function generateRegionPrefix(region) {\n    if (!region) return null;\n    var parts = region.split(\"-\");\n    if (parts.length < 3) return null;\n    return parts.slice(0, parts.length - 2).join(\"-\") + \"-*\";\n}",
	"node_modules/aws-sdk/dist/aws-sdk----derivedKeys": "function derivedKeys(service) {\n    var region = service.config.region;\n    var regionPrefix = generateRegionPrefix(region);\n    var endpointPrefix = service.api.endpointPrefix;\n    return [ [ region, endpointPrefix ], [ regionPrefix, endpointPrefix ], [ region, \"*\" ], [ regionPrefix, \"*\" ], [ \"*\", endpointPrefix ], [ \"*\", \"*\" ] ].map(function(item) {\n        return item[0] && item[1] ? item.join(\"/\") : null;\n    });\n}",
	"node_modules/aws-sdk/dist/aws-sdk----configureEndpoint": "function configureEndpoint(service) {\n    var keys = derivedKeys(service);\n    var useFipsEndpoint = service.config.useFipsEndpoint;\n    var useDualstackEndpoint = service.config.useDualstackEndpoint;\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!key) continue;\n        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;\n        if (Object.prototype.hasOwnProperty.call(rules, key)) {\n            var config = rules[key];\n            if (typeof config === \"string\") {\n                config = regionConfig.patterns[config];\n            }\n            service.isGlobalEndpoint = !!config.globalEndpoint;\n            if (config.signingRegion) {\n                service.signingRegion = config.signingRegion;\n            }\n            if (!config.signatureVersion) config.signatureVersion = \"v4\";\n            applyConfig(service, config);\n            return;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----getEndpointSuffix": "function getEndpointSuffix(region) {\n    var regionRegexes = {\n        \"^(us|eu|ap|sa|ca|me)\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^cn\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com.cn\",\n        \"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\": \"c2s.ic.gov\",\n        \"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\": \"sc2s.sgov.gov\"\n    };\n    var defaultSuffix = \"amazonaws.com\";\n    var regexes = Object.keys(regionRegexes);\n    for (var i = 0; i < regexes.length; i++) {\n        var regionPattern = RegExp(regexes[i]);\n        var dnsSuffix = regionRegexes[regexes[i]];\n        if (regionPattern.test(region)) return dnsSuffix;\n    }\n    return defaultSuffix;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----wrappedCallback": "function wrappedCallback(err, data) {\n    if (err) return callback(err, null);\n    if (data === null) return callback(null, null);\n    var config = self.service.paginationConfig(self.operation);\n    var resultKey = config.resultKey;\n    if (Array.isArray(resultKey)) resultKey = resultKey[0];\n    var items = jmespath.search(data, resultKey);\n    var continueIteration = true;\n    AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n            return AWS.util.abort;\n        }\n    });\n    return continueIteration;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----CHECK_ACCEPTORS": "function CHECK_ACCEPTORS(resp) {\n    var waiter = resp.request._waiter;\n    var acceptors = waiter.config.acceptors;\n    var acceptorMatched = false;\n    var state = \"retry\";\n    acceptors.forEach(function(acceptor) {\n        if (!acceptorMatched) {\n            var matcher = waiter.matchers[acceptor.matcher];\n            if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n                acceptorMatched = true;\n                state = acceptor.state;\n            }\n        }\n    });\n    if (!acceptorMatched && resp.error) state = \"failure\";\n    if (state === \"success\") {\n        waiter.setSuccess(resp);\n    } else {\n        waiter.setError(resp, state === \"retry\");\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----signedUrlBuilder": "function signedUrlBuilder(request) {\n    var expires = request.httpRequest.headers[expiresHeader];\n    var signerClass = request.service.getSignerClass(request);\n    delete request.httpRequest.headers[\"User-Agent\"];\n    delete request.httpRequest.headers[\"X-Amz-User-Agent\"];\n    if (signerClass === AWS.Signers.V4) {\n        if (expires > 604800) {\n            var message = \"Presigning does not support expiry time greater \" + \"than a week with SigV4 signing.\";\n            throw AWS.util.error(new Error(), {\n                code: \"InvalidExpiryTime\",\n                message: message,\n                retryable: false\n            });\n        }\n        request.httpRequest.headers[expiresHeader] = expires;\n    } else if (signerClass === AWS.Signers.S3) {\n        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();\n        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();\n    } else {\n        throw AWS.util.error(new Error(), {\n            message: \"Presigning only supports S3 or SigV4 signing.\",\n            code: \"UnsupportedSigner\",\n            retryable: false\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----signedUrlSigner": "function signedUrlSigner(request) {\n    var endpoint = request.httpRequest.endpoint;\n    var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n    var queryParams = {};\n    if (parsedUrl.search) {\n        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n    }\n    var auth = request.httpRequest.headers[\"Authorization\"].split(\" \");\n    if (auth[0] === \"AWS\") {\n        auth = auth[1].split(\":\");\n        queryParams[\"Signature\"] = auth.pop();\n        queryParams[\"AWSAccessKeyId\"] = auth.join(\":\");\n        AWS.util.each(request.httpRequest.headers, function(key, value) {\n            if (key === expiresHeader) key = \"Expires\";\n            if (key.indexOf(\"x-amz-meta-\") === 0) {\n                delete queryParams[key];\n                key = key.toLowerCase();\n            }\n            queryParams[key] = value;\n        });\n        delete request.httpRequest.headers[expiresHeader];\n        delete queryParams[\"Authorization\"];\n        delete queryParams[\"Host\"];\n    } else if (auth[0] === \"AWS4-HMAC-SHA256\") {\n        auth.shift();\n        var rest = auth.join(\" \");\n        var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n        queryParams[\"X-Amz-Signature\"] = signature;\n        delete queryParams[\"Expires\"];\n    }\n    endpoint.pathname = parsedUrl.pathname;\n    endpoint.search = AWS.util.queryParamsToString(queryParams);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseStructure": "function parseStructure(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    util.each(shape.members, function(memberName, memberShape) {\n        if (memberShape.isXmlAttribute) {\n            if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n                var value = xml.attributes[memberShape.name].value;\n                data[memberName] = parseXml({\n                    textContent: value\n                }, memberShape);\n            }\n        } else {\n            var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);\n            if (xmlChild) {\n                data[memberName] = parseXml(xmlChild, memberShape);\n            } else if (!memberShape.flattened && memberShape.type === \"list\" && !shape.api.xmlNoDefaultLists) {\n                data[memberName] = memberShape.defaultValue;\n            }\n        }\n    });\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseMap": "function parseMap(xml, shape) {\n    var data = {};\n    var xmlKey = shape.key.name || \"key\";\n    var xmlValue = shape.value.name || \"value\";\n    var tagName = shape.flattened ? shape.name : \"entry\";\n    var child = xml.firstElementChild;\n    while (child) {\n        if (child.nodeName === tagName) {\n            var key = getElementByTagName(child, xmlKey).textContent;\n            var value = getElementByTagName(child, xmlValue);\n            data[key] = parseXml(value, shape.value);\n        }\n        child = child.nextElementSibling;\n    }\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseList": "function parseList(xml, shape) {\n    var data = [];\n    var tagName = shape.flattened ? shape.name : shape.member.name || \"member\";\n    var child = xml.firstElementChild;\n    while (child) {\n        if (child.nodeName === tagName) {\n            data.push(parseXml(child, shape.member));\n        }\n        child = child.nextElementSibling;\n    }\n    return data;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseScalar": "function parseScalar(xml, shape) {\n    if (xml.getAttribute) {\n        var encoding = xml.getAttribute(\"encoding\");\n        if (encoding === \"base64\") {\n            shape = new Shape.create({\n                type: encoding\n            });\n        }\n    }\n    var text = xml.textContent;\n    if (text === \"\") text = null;\n    if (typeof shape.toType === \"function\") {\n        return shape.toType(text);\n    } else {\n        return text;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----parseUnknown": "function parseUnknown(xml) {\n    if (xml === undefined || xml === null) return \"\";\n    if (!xml.firstElementChild) {\n        if (xml.parentNode.parentNode === null) return {};\n        if (xml.childNodes.length === 0) return \"\"; else return xml.textContent;\n    }\n    var shape = {\n        type: \"structure\",\n        members: {}\n    };\n    var child = xml.firstElementChild;\n    while (child) {\n        var tag = child.nodeName;\n        if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n            shape.members[tag].type = \"list\";\n        } else {\n            shape.members[tag] = {\n                name: tag\n            };\n        }\n        child = child.nextElementSibling;\n    }\n    return parseStructure(xml, shape);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----XmlNode": "function XmlNode(name, children) {\n    if (children === void 0) {\n        children = [];\n    }\n    this.name = name;\n    this.children = children;\n    this.attributes = {};\n}",
	"node_modules/aws-sdk/dist/aws-sdk----getLens": "function getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [ validLen, placeHoldersLen ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk----byteLength": "function byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n\n          case \"utf8\":\n          case \"utf-8\":\n          case undefined:\n            return utf8ToBytes(string).length;\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n\n          case \"hex\":\n            return len >>> 1;\n\n          case \"base64\":\n            return base64ToBytes(string).length;\n\n          default:\n            if (loweredCase) return utf8ToBytes(string).length;\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----toByteArray": "function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    return arr;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----encodeChunk": "function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk----fromByteArray": "function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n    return parts.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk----inspect": "function inspect(obj, opts) {\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n    } else if (opts) {\n        exports._extend(ctx, opts);\n    }\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----formatValue": "function formatValue(ctx, value, recurseTimes) {\n    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n    if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n    }\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? \": \" + value.name : \"\";\n            return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n    }\n    var base = \"\", array = false, braces = [ \"{\", \"}\" ];\n    if (isArray(value)) {\n        array = true;\n        braces = [ \"[\", \"]\" ];\n    }\n    if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n    }\n    if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n    }\n    if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n    }\n    if (isError(value)) {\n        base = \" \" + formatError(value);\n    }\n    if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n    }\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n            return ctx.stylize(\"[Object]\", \"special\");\n        }\n    }\n    ctx.seen.push(value);\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function(key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----formatPrimitive": "function formatPrimitive(ctx, value) {\n    if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n    if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n    }\n    if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n    if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n    if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk----formatArray": "function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n            output.push(\"\");\n        }\n    }\n    keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n    });\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----formatProperty": "function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {\n        value: value[key]\n    };\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n            str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf(\"\\n\") > -1) {\n                if (array) {\n                    str = str.split(\"\\n\").map(function(line) {\n                        return \"  \" + line;\n                    }).join(\"\\n\").substr(2);\n                } else {\n                    str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                        return \"   \" + line;\n                    }).join(\"\\n\");\n                }\n            }\n        } else {\n            str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, \"name\");\n        } else {\n            name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, \"string\");\n        }\n    }\n    return name + \": \" + str;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----reduceToSingleString": "function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n    }, 0);\n    if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n    }\n    return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}",
	"node_modules/aws-sdk/dist/aws-sdk----from": "function from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----alloc": "function alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----allocUnsafe": "function allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----fromString": "function fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        that = that.slice(0, actual);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----fromArrayLike": "function fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----fromArrayBuffer": "function fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength;\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----slowToString": "function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n\n          case \"base64\":\n            return base64Slice(this, start, end);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----bidirectionalIndexOf": "function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    if (buffer.length === 0) return -1;\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (isNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1; else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0; else return -1;\n    }\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk----arrayIndexOf": "function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----hexWrite": "function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----utf8Slice": "function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                    codePoint = firstByte;\n                }\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n            }\n        }\n        if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----decodeCodePointsArray": "function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----asciiSlice": "function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----latin1Slice": "function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----hexSlice": "function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----utf16leSlice": "function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----base64clean": "function base64clean(str) {\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2) return \"\";\n    while (str.length % 4 !== 0) {\n        str = str + \"=\";\n    }\n    return str;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----utf8ToBytes": "function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n                if (codePoint > 56319) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                } else if (i + 1 === length) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                }\n                leadSurrogate = codePoint;\n                continue;\n            }\n            if (codePoint < 56320) {\n                if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----utf16leToBytes": "function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----strictDeepEqual": "function strictDeepEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n        return false;\n    }\n    if (isArray(first) === true) {\n        if (first.length !== second.length) {\n            return false;\n        }\n        for (var i = 0; i < first.length; i++) {\n            if (strictDeepEqual(first[i], second[i]) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (isObject(first) === true) {\n        var keysSeen = {};\n        for (var key in first) {\n            if (hasOwnProperty.call(first, key)) {\n                if (strictDeepEqual(first[key], second[key]) === false) {\n                    return false;\n                }\n                keysSeen[key] = true;\n            }\n        }\n        for (var key2 in second) {\n            if (hasOwnProperty.call(second, key2)) {\n                if (keysSeen[key2] !== true) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----objValues": "function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n    }\n    return values;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----merge": "function merge(a, b) {\n    var merged = {};\n    for (var key in a) {\n        merged[key] = a[key];\n    }\n    for (var key2 in b) {\n        merged[key2] = b[key2];\n    }\n    return merged;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----search": "function search(data, expression) {\n    var parser = new Parser();\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----cleanUpNextTick": "function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk----drainQueue": "function drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----map": "function map(xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        res.push(f(xs[i], i));\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----mapDomain": "function mapDomain(string, fn) {\n    var parts = string.split(\"@\");\n    var result = \"\";\n    if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n    }\n    string = string.replace(regexSeparators, \".\");\n    var labels = string.split(\".\");\n    var encoded = map(labels, fn).join(\".\");\n    return result + encoded;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----basicToDigit": "function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n        return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n        return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n        return codePoint - 97;\n    }\n    return base;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----adapt": "function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (;delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}",
	"node_modules/aws-sdk/dist/aws-sdk----decode": "function decode(input) {\n    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n            error(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n    }\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        for (oldi = i, w = 1, k = base; ;k += base) {\n            if (index >= inputLength) {\n                error(\"invalid-input\");\n            }\n            digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > floor((maxInt - i) / w)) {\n                error(\"overflow\");\n            }\n            i += digit * w;\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n                break;\n            }\n            baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n                error(\"overflow\");\n            }\n            w *= baseMinusT;\n        }\n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n            error(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----encode": "function encode(input) {\n    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;\n    input = ucs2decode(input);\n    inputLength = input.length;\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n    for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < 128) {\n            output.push(stringFromCharCode(currentValue));\n        }\n    }\n    handledCPCount = basicLength = output.length;\n    if (basicLength) {\n        output.push(delimiter);\n    }\n    while (handledCPCount < inputLength) {\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n            if (currentValue < n && ++delta > maxInt) {\n                error(\"overflow\");\n            }\n            if (currentValue == n) {\n                for (q = delta, k = base; ;k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                    q = floor(qMinusT / baseMinusT);\n                }\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n        ++delta;\n        ++n;\n    }\n    return output.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk----Url": "function Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----urlParse": "function urlParse(url, parseQueryString, slashesDenoteHost) {\n    if (url && isObject(url) && url instanceof Url) return url;\n    var u = new Url();\n    u.parse(url, parseQueryString, slashesDenoteHost);\n    return u;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----md5ToHexEncodedArray": "function md5ToHexEncodedArray(input) {\n    var i;\n    var x;\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    var hex;\n    for (i = 0; i < length32; i += 8) {\n        x = input[i >> 5] >>> i % 32 & 255;\n        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n        output.push(hex);\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----wordsToMd5": "function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var i;\n    var olda;\n    var oldb;\n    var oldc;\n    var oldd;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [ a, b, c, d ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk----bytesToWords": "function bytesToWords(input) {\n    var i;\n    var output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    var length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----sha1": "function sha1(bytes) {\n    var K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof bytes == \"string\") {\n        var msg = unescape(encodeURIComponent(bytes));\n        bytes = new Array(msg.length);\n        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {\n            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n        }\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var i = 0; i < N; i++) {\n        var W = new Array(80);\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 80; t++) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        var a = H[0];\n        var b = H[1];\n        var c = H[2];\n        var d = H[3];\n        var e = H[4];\n        for (var t = 0; t < 80; t++) {\n            var s = Math.floor(t / 20);\n            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = H[0] + a >>> 0;\n        H[1] = H[1] + b >>> 0;\n        H[2] = H[2] + c >>> 0;\n        H[3] = H[3] + d >>> 0;\n        H[4] = H[4] + e >>> 0;\n    }\n    return [ H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255 ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || _rng.default)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : (0, _bytesToUuid.default)(b);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----_default": "function _default(name, version, hashfunc) {\n    var generateUUID = function(value, namespace, buf, offset) {\n        var off = buf && offset || 0;\n        if (typeof value == \"string\") value = stringToBytes(value);\n        if (typeof namespace == \"string\") namespace = uuidToBytes(namespace);\n        if (!Array.isArray(value)) throw TypeError(\"value must be an array of bytes\");\n        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError(\"namespace must be uuid string or an Array of 16 byte values\");\n        var bytes = hashfunc(namespace.concat(value));\n        bytes[6] = bytes[6] & 15 | version;\n        bytes[8] = bytes[8] & 63 | 128;\n        if (buf) {\n            for (var idx = 0; idx < 16; ++idx) {\n                buf[off + idx] = bytes[idx];\n            }\n        }\n        return buf || (0, _bytesToUuid.default)(bytes);\n    };\n    try {\n        generateUUID.name = name;\n    } catch (err) {}\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n}",
	"node_modules/aws-sdk/dist/aws-sdk----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || _rng.default)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || (0, _bytesToUuid.default)(rnds);\n}",
	"node_modules/aws-sdk/dist/aws-sdk----LRUCache": "function LRUCache(size) {\n    this.nodeMap = {};\n    this.size = 0;\n    if (typeof size !== \"number\" || size < 1) {\n        throw new Error(\"Cache size can only be positive number\");\n    }\n    this.sizeLimit = size;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----a": "function a(e, i) {\n    if (e === i) return !0;\n    if (Object.prototype.toString.call(e) !== Object.prototype.toString.call(i)) return !1;\n    if (!0 === t(e)) {\n        if (e.length !== i.length) return !1;\n        for (var s = 0; s < e.length; s++) if (!1 === a(e[s], i[s])) return !1;\n        return !0;\n    }\n    if (!0 === r(e)) {\n        var o = {};\n        for (var n in e) if (hasOwnProperty.call(e, n)) {\n            if (!1 === a(e[n], i[n])) return !1;\n            o[n] = !0;\n        }\n        for (var u in i) if (hasOwnProperty.call(i, u) && !0 !== o[u]) return !1;\n        return !0;\n    }\n    return !1;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----i": "function i(e, t, r) {\n    var a = t && r || 0;\n    \"string\" == typeof e && (t = \"binary\" === e ? new Array(16) : null, e = null), \n    e = e || {};\n    var i = e.random || (e.rng || s.default)();\n    if (i[6] = 15 & i[6] | 64, i[8] = 63 & i[8] | 128, t) for (var n = 0; n < 16; ++n) t[a + n] = i[n];\n    return t || (0, o.default)(i);\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----o": "function o(e) {\n    var t, r = [];\n    for (r[(e.length >> 2) - 1] = void 0, t = 0; t < r.length; t += 1) r[t] = 0;\n    var a = 8 * e.length;\n    for (t = 0; t < a; t += 8) r[t >> 5] |= (255 & e[t / 8]) << t % 32;\n    return r;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----n": "function n(e) {\n    p.extractData(e);\n    var t, r = e.request, a = r.service.api.operations[r.operation], i = r.service.api.operations[r.operation].output || {};\n    a.hasEventOutput;\n    if (i.payload) {\n        var s = i.members[i.payload], o = e.httpResponse.body;\n        if (s.isEventStream) t = new l(), e.data[payload] = u.createEventStream(2 === AWS.HttpClient.streamsApiVersion ? e.httpResponse.stream : o, t, s); else if (\"structure\" === s.type || \"list\" === s.type) {\n            var t = new l();\n            e.data[i.payload] = t.parse(o, s);\n        } else \"binary\" === s.type || s.isStreaming ? e.data[i.payload] = o : e.data[i.payload] = s.toType(o);\n    } else {\n        var n = e.data;\n        m.extractData(e), e.data = u.merge(n, e.data);\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----d": "function d(e) {\n    var t, r, a, s, o, u, p, l, d, y, b, S, g, h, N, I = [];\n    for (e = n(e), S = e.length, t = D, r = 0, o = v, u = 0; u < S; ++u) (b = e[u]) < 128 && I.push(w(b));\n    for (a = s = I.length, s && I.push(P); a < S; ) {\n        for (p = f, u = 0; u < S; ++u) (b = e[u]) >= t && b < p && (p = b);\n        for (g = a + 1, p - t > G((f - r) / g) && i(\"overflow\"), r += (p - t) * g, \n        t = p, u = 0; u < S; ++u) if (b = e[u], b < t && ++r > f && i(\"overflow\"), \n        b == t) {\n            for (l = r, d = T; y = d <= o ? C : d >= o + k ? k : d - o, !(l < y); d += T) N = l - y, \n            h = T - y, I.push(w(m(y + N % h, 0))), l = G(N / h);\n            I.push(w(m(l, 0))), o = c(r, g, a == s), r = 0, ++a;\n        }\n        ++r, ++t;\n    }\n    return I.join(\"\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----s": "function s(e) {\n    var t = [ 1518500249, 1859775393, 2400959708, 3395469782 ], r = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (\"string\" == typeof e) {\n        var s = unescape(encodeURIComponent(e));\n        e = new Array(s.length);\n        for (var o = 0; o < s.length; o++) e[o] = s.charCodeAt(o);\n    }\n    e.push(128);\n    for (var n = e.length / 4 + 2, u = Math.ceil(n / 16), p = new Array(u), o = 0; o < u; o++) {\n        p[o] = new Array(16);\n        for (var m = 0; m < 16; m++) p[o][m] = e[64 * o + 4 * m] << 24 | e[64 * o + 4 * m + 1] << 16 | e[64 * o + 4 * m + 2] << 8 | e[64 * o + 4 * m + 3];\n    }\n    p[u - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), p[u - 1][14] = Math.floor(p[u - 1][14]), \n    p[u - 1][15] = 8 * (e.length - 1) & 4294967295;\n    for (var o = 0; o < u; o++) {\n        for (var c = new Array(80), l = 0; l < 16; l++) c[l] = p[o][l];\n        for (var l = 16; l < 80; l++) c[l] = i(c[l - 3] ^ c[l - 8] ^ c[l - 14] ^ c[l - 16], 1);\n        for (var d = r[0], y = r[1], b = r[2], S = r[3], g = r[4], l = 0; l < 80; l++) {\n            var h = Math.floor(l / 20), N = i(d, 5) + a(h, y, b, S) + g + t[h] + c[l] >>> 0;\n            g = S, S = b, b = i(y, 30) >>> 0, y = d, d = N;\n        }\n        r[0] = r[0] + d >>> 0, r[1] = r[1] + y >>> 0, r[2] = r[2] + b >>> 0, r[3] = r[3] + S >>> 0, \n        r[4] = r[4] + g >>> 0;\n    }\n    return [ r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4] ];\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----t": "function t(t, i) {\n    if (t) return e(t, null);\n    if (null === i) return e(null, null);\n    var s = r.service.paginationConfig(r.operation), o = s.resultKey;\n    Array.isArray(o) && (o = o[0]);\n    var u = n.search(i, o), p = !0;\n    return a.util.arrayEach(u, function(t) {\n        if (!1 === (p = e(null, t))) return a.util.abort;\n    }), p;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----m": "function m(e, t, r) {\n    if (\"string\" == typeof r && \"\" !== r || (r = \"utf8\"), !s.isEncoding(r)) throw new TypeError('\"encoding\" must be a valid string encoding');\n    var a = 0 | S(t, r);\n    e = i(e, a);\n    var o = e.write(t, r);\n    return o !== a && (e = e.slice(0, o)), e;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----u": "function u(e, t, a) {\n    if (e.customInspect && t && R(t.inspect) && t.inspect !== r.inspect && (!t.constructor || t.constructor.prototype !== t)) {\n        var i = t.inspect(a, e);\n        return N(i) || (i = u(e, i, a)), i;\n    }\n    var s = p(e, t);\n    if (s) return s;\n    var o = Object.keys(t), b = n(o);\n    if (e.showHidden && (o = Object.getOwnPropertyNames(t)), A(t) && (o.indexOf(\"message\") >= 0 || o.indexOf(\"description\") >= 0)) return m(t);\n    if (0 === o.length) {\n        if (R(t)) {\n            var S = t.name ? \": \" + t.name : \"\";\n            return e.stylize(\"[Function\" + S + \"]\", \"special\");\n        }\n        if (T(t)) return e.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n        if (k(t)) return e.stylize(Date.prototype.toString.call(t), \"date\");\n        if (A(t)) return m(t);\n    }\n    var g = \"\", h = !1, I = [ \"{\", \"}\" ];\n    if (y(t) && (h = !0, I = [ \"[\", \"]\" ]), R(t)) {\n        g = \" [Function\" + (t.name ? \": \" + t.name : \"\") + \"]\";\n    }\n    if (T(t) && (g = \" \" + RegExp.prototype.toString.call(t)), k(t) && (g = \" \" + Date.prototype.toUTCString.call(t)), \n    A(t) && (g = \" \" + m(t)), 0 === o.length && (!h || 0 == t.length)) return I[0] + g + I[1];\n    if (a < 0) return T(t) ? e.stylize(RegExp.prototype.toString.call(t), \"regexp\") : e.stylize(\"[Object]\", \"special\");\n    e.seen.push(t);\n    var f;\n    return f = h ? c(e, t, a, b, o) : o.map(function(r) {\n        return l(e, t, a, b, r, h);\n    }), e.seen.pop(), d(f, g, I);\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----c": "function c(e, t) {\n    var r = t.length < 0 ? 0 : 0 | y(t.length);\n    e = i(e, r);\n    for (var a = 0; a < r; a += 1) e[a] = 255 & t[a];\n    return e;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----S": "function S(e, t) {\n    if (s.isBuffer(e)) return e.length;\n    if (\"undefined\" != typeof ArrayBuffer && \"function\" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;\n    \"string\" != typeof e && (e = \"\" + e);\n    var r = e.length;\n    if (0 === r) return 0;\n    for (var a = !1; ;) switch (t) {\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n        return r;\n\n      case \"utf8\":\n      case \"utf-8\":\n      case void 0:\n        return K(e).length;\n\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return 2 * r;\n\n      case \"hex\":\n        return r >>> 1;\n\n      case \"base64\":\n        return H(e).length;\n\n      default:\n        if (a) return K(e).length;\n        t = (\"\" + t).toLowerCase(), a = !0;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----g": "function g(e, t, r) {\n    var a = !1;\n    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return \"\";\n    if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return \"\";\n    if (r >>>= 0, t >>>= 0, r <= t) return \"\";\n    for (e || (e = \"utf8\"); ;) switch (e) {\n      case \"hex\":\n        return E(this, t, r);\n\n      case \"utf8\":\n      case \"utf-8\":\n        return D(this, t, r);\n\n      case \"ascii\":\n        return x(this, t, r);\n\n      case \"latin1\":\n      case \"binary\":\n        return q(this, t, r);\n\n      case \"base64\":\n        return v(this, t, r);\n\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return M(this, t, r);\n\n      default:\n        if (a) throw new TypeError(\"Unknown encoding: \" + e);\n        e = (e + \"\").toLowerCase(), a = !0;\n    }\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----N": "function N(e, t, r, a, i) {\n    if (0 === e.length) return -1;\n    if (\"string\" == typeof r ? (a = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), \n    r = +r, isNaN(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), \n    r >= e.length) {\n        if (i) return -1;\n        r = e.length - 1;\n    } else if (r < 0) {\n        if (!i) return -1;\n        r = 0;\n    }\n    if (\"string\" == typeof t && (t = s.from(t, a)), s.isBuffer(t)) return 0 === t.length ? -1 : I(e, t, r, a, i);\n    if (\"number\" == typeof t) return t &= 255, s.TYPED_ARRAY_SUPPORT && \"function\" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : I(e, [ t ], r, a, i);\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----I": "function I(e, t, r, a, i) {\n    function s(e, t) {\n        return 1 === o ? e[t] : e.readUInt16BE(t * o);\n    }\n    var o = 1, n = e.length, u = t.length;\n    if (void 0 !== a && (\"ucs2\" === (a = String(a).toLowerCase()) || \"ucs-2\" === a || \"utf16le\" === a || \"utf-16le\" === a)) {\n        if (e.length < 2 || t.length < 2) return -1;\n        o = 2, n /= 2, u /= 2, r /= 2;\n    }\n    var p;\n    if (i) {\n        var m = -1;\n        for (p = r; p < n; p++) if (s(e, p) === s(t, -1 === m ? 0 : p - m)) {\n            if (-1 === m && (m = p), p - m + 1 === u) return m * o;\n        } else -1 !== m && (p -= p - m), m = -1;\n    } else for (r + u > n && (r = n - u), p = r; p >= 0; p--) {\n        for (var c = !0, l = 0; l < u; l++) if (s(e, p + l) !== s(t, l)) {\n            c = !1;\n            break;\n        }\n        if (c) return p;\n    }\n    return -1;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----f": "function f(e, t, r, a) {\n    r = Number(r) || 0;\n    var i = e.length - r;\n    a ? (a = Number(a)) > i && (a = i) : a = i;\n    var s = t.length;\n    if (s % 2 != 0) throw new TypeError(\"Invalid hex string\");\n    a > s / 2 && (a = s / 2);\n    for (var o = 0; o < a; ++o) {\n        var n = parseInt(t.substr(2 * o, 2), 16);\n        if (isNaN(n)) return o;\n        e[r + o] = n;\n    }\n    return o;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----P": "function P(e) {\n    var t = e.length;\n    if (t <= $) return String.fromCharCode.apply(String, e);\n    for (var r = \"\", a = 0; a < t; ) r += String.fromCharCode.apply(String, e.slice(a, a += $));\n    return r;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----x": "function x(e, t, r) {\n    var a = \"\";\n    r = Math.min(e.length, r);\n    for (var i = t; i < r; ++i) a += String.fromCharCode(127 & e[i]);\n    return a;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----q": "function q(e, t, r) {\n    var a = \"\";\n    r = Math.min(e.length, r);\n    for (var i = t; i < r; ++i) a += String.fromCharCode(e[i]);\n    return a;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----E": "function E(e, t, r) {\n    var a = e.length;\n    (!t || t < 0) && (t = 0), (!r || r < 0 || r > a) && (r = a);\n    for (var i = \"\", s = t; s < r; ++s) i += z(e[s]);\n    return i;\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----b": "function b(e, t) {\n    var r = new m(), a = new l(), i = new c(a);\n    a._interpreter = i;\n    var s = r.parse(t);\n    return i.search(s, e);\n}",
	"node_modules/aws-sdk/dist/aws-sdk.min----l": "function l(e) {\n    var t, r, a, s, o, n, m, l, d, y, b = [], S = e.length, g = 0, h = D, N = v;\n    for (r = e.lastIndexOf(P), r < 0 && (r = 0), a = 0; a < r; ++a) e.charCodeAt(a) >= 128 && i(\"not-basic\"), \n    b.push(e.charCodeAt(a));\n    for (s = r > 0 ? r + 1 : 0; s < S; ) {\n        for (o = g, n = 1, m = T; s >= S && i(\"invalid-input\"), l = p(e.charCodeAt(s++)), \n        (l >= T || l > G((f - g) / n)) && i(\"overflow\"), g += l * n, d = m <= N ? C : m >= N + k ? k : m - N, \n        !(l < d); m += T) y = T - d, n > G(f / y) && i(\"overflow\"), n *= y;\n        t = b.length + 1, N = c(g - o, t, 0 == o), G(g / t) > f - h && i(\"overflow\"), \n        h += G(g / t), g %= t, b.splice(g++, 0, h);\n    }\n    return u(b);\n}",
	"node_modules/aws-sdk/dist/xml2js----__webpack_require__": "function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = installedModules[moduleId] = {\n        exports: {},\n        id: moduleId,\n        loaded: false\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    module.loaded = true;\n    return module.exports;\n}",
	"node_modules/aws-sdk/dist/xml2js----Builder": "function Builder(opts) {\n    var key, ref, value;\n    this.options = {};\n    ref = defaults[\"0.2\"];\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n    }\n    for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDocument": "function XMLDocument(options) {\n    XMLDocument.__super__.constructor.call(this, null);\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter();\n    }\n    this.options = options;\n    this.stringify = new XMLStringifier(options);\n    this.isDocument = true;\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLNode": "function XMLNode(parent) {\n    this.parent = parent;\n    if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n    }\n    this.children = [];\n    if (!XMLElement) {\n        XMLElement = __webpack_require__(8);\n        XMLCData = __webpack_require__(10);\n        XMLComment = __webpack_require__(11);\n        XMLDeclaration = __webpack_require__(12);\n        XMLDocType = __webpack_require__(13);\n        XMLRaw = __webpack_require__(18);\n        XMLText = __webpack_require__(19);\n        XMLProcessingInstruction = __webpack_require__(20);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLElement": "function XMLElement(parent, name, attributes) {\n    XMLElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing element name\");\n    }\n    this.name = this.stringify.eleName(name);\n    this.attributes = {};\n    if (attributes != null) {\n        this.attribute(attributes);\n    }\n    if (parent.isDocument) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLAttribute": "function XMLAttribute(parent, name, value) {\n    this.options = parent.options;\n    this.stringify = parent.stringify;\n    if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n    }\n    if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n    }\n    this.name = this.stringify.attName(name);\n    this.value = this.stringify.attValue(value);\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDeclaration": "function XMLDeclaration(parent, version, encoding, standalone) {\n    var ref;\n    XMLDeclaration.__super__.constructor.call(this, parent);\n    if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n    }\n    if (!version) {\n        version = \"1.0\";\n    }\n    this.version = this.stringify.xmlVersion(version);\n    if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n    }\n    if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDocType": "function XMLDocType(parent, pubID, sysID) {\n    var ref, ref1;\n    XMLDocType.__super__.constructor.call(this, parent);\n    this.documentObject = parent;\n    if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n    }\n    if (sysID == null) {\n        ref1 = [ pubID, sysID ], sysID = ref1[0], pubID = ref1[1];\n    }\n    if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n    }\n    if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDTDAttList": "function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n    XMLDTDAttList.__super__.constructor.call(this, parent);\n    if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n    }\n    if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n    }\n    if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n    }\n    if (defaultValueType.indexOf(\"#\") !== 0) {\n        defaultValueType = \"#\" + defaultValueType;\n    }\n    if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n    }\n    if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n    }\n    this.elementName = this.stringify.eleName(elementName);\n    this.attributeName = this.stringify.attName(attributeName);\n    this.attributeType = this.stringify.dtdAttType(attributeType);\n    this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n    this.defaultValueType = defaultValueType;\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDTDEntity": "function XMLDTDEntity(parent, pe, name, value) {\n    XMLDTDEntity.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing entity name\");\n    }\n    if (value == null) {\n        throw new Error(\"Missing entity value\");\n    }\n    this.pe = !!pe;\n    this.name = this.stringify.eleName(name);\n    if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n    } else {\n        if (!value.pubID && !value.sysID) {\n            throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n            throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n            this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n            this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n            this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n            throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDTDElement": "function XMLDTDElement(parent, name, value) {\n    XMLDTDElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (!value) {\n        value = \"(#PCDATA)\";\n    }\n    if (Array.isArray(value)) {\n        value = \"(\" + value.join(\",\") + \")\";\n    }\n    this.name = this.stringify.eleName(name);\n    this.value = this.stringify.dtdElementValue(value);\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDTDNotation": "function XMLDTDNotation(parent, name, value) {\n    XMLDTDNotation.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing notation name\");\n    }\n    if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n    }\n    this.name = this.stringify.eleName(name);\n    if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n    }\n    if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLProcessingInstruction": "function XMLProcessingInstruction(parent, target, value) {\n    XMLProcessingInstruction.__super__.constructor.call(this, parent);\n    if (target == null) {\n        throw new Error(\"Missing instruction target\");\n    }\n    this.target = this.stringify.insTarget(target);\n    if (value) {\n        this.value = this.stringify.insValue(value);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLStringifier": "function XMLStringifier(options) {\n    this.assertLegalChar = bind(this.assertLegalChar, this);\n    var key, ref, value;\n    options || (options = {});\n    this.noDoubleEncoding = options.noDoubleEncoding;\n    ref = options.stringify || {};\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLWriterBase": "function XMLWriterBase(options) {\n    var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;\n    options || (options = {});\n    this.pretty = options.pretty || false;\n    this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;\n    if (this.pretty) {\n        this.indent = (ref1 = options.indent) != null ? ref1 : \"  \";\n        this.newline = (ref2 = options.newline) != null ? ref2 : \"\\n\";\n        this.offset = (ref3 = options.offset) != null ? ref3 : 0;\n        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;\n    } else {\n        this.indent = \"\";\n        this.newline = \"\";\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n    }\n    this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : \"\";\n    if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = \" \";\n    }\n    this.newlinedefault = this.newline;\n    this.prettydefault = this.pretty;\n    ref6 = options.writer || {};\n    for (key in ref6) {\n        if (!hasProp.call(ref6, key)) continue;\n        value = ref6[key];\n        this[key] = value;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----XMLDocumentCB": "function XMLDocumentCB(options, onData, onEnd) {\n    var writerOptions;\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter(options);\n    } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter(writerOptions);\n    }\n    this.options = options;\n    this.writer = options.writer;\n    this.stringify = new XMLStringifier(options);\n    this.onDataCallback = onData || function() {};\n    this.onEndCallback = onEnd || function() {};\n    this.currentNode = null;\n    this.currentLevel = -1;\n    this.openTags = {};\n    this.documentStarted = false;\n    this.documentCompleted = false;\n    this.root = null;\n}",
	"node_modules/aws-sdk/dist/xml2js----Parser": "function Parser(opts) {\n    this.parseString = bind(this.parseString, this);\n    this.reset = bind(this.reset, this);\n    this.assignOrPush = bind(this.assignOrPush, this);\n    this.processAsync = bind(this.processAsync, this);\n    var key, ref, value;\n    if (!(this instanceof exports.Parser)) {\n        return new exports.Parser(opts);\n    }\n    this.options = {};\n    ref = defaults[\"0.2\"];\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n    }\n    for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n    }\n    if (this.options.xmlns) {\n        this.options.xmlnskey = this.options.attrkey + \"ns\";\n    }\n    if (this.options.normalizeTags) {\n        if (!this.options.tagNameProcessors) {\n            this.options.tagNameProcessors = [];\n        }\n        this.options.tagNameProcessors.unshift(processors.normalize);\n    }\n    this.reset();\n}",
	"node_modules/aws-sdk/dist/xml2js----SAXParser": "function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n        return new SAXParser(strict, opt);\n    }\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n    if (parser.opt.xmlns) {\n        parser.ns = Object.create(rootNS);\n    }\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n        parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n}",
	"node_modules/aws-sdk/dist/xml2js----checkBufferLength": "function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n        var len = parser[buffers[i]].length;\n        if (len > maxAllowed) {\n            switch (buffers[i]) {\n              case \"textNode\":\n                closeText(parser);\n                break;\n\n              case \"cdata\":\n                emitNode(parser, \"oncdata\", parser.cdata);\n                parser.cdata = \"\";\n                break;\n\n              case \"script\":\n                emitNode(parser, \"onscript\", parser.script);\n                parser.script = \"\";\n                break;\n\n              default:\n                error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n            }\n        }\n        maxActual = Math.max(maxActual, len);\n    }\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n}",
	"node_modules/aws-sdk/dist/xml2js----SAXStream": "function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n        return new SAXStream(strict, opt);\n    }\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n    this._parser.onend = function() {\n        me.emit(\"end\");\n    };\n    this._parser.onerror = function(er) {\n        me.emit(\"error\", er);\n        me._parser.error = null;\n    };\n    this._decoder = null;\n    streamWraps.forEach(function(ev) {\n        Object.defineProperty(me, \"on\" + ev, {\n            get: function() {\n                return me._parser[\"on\" + ev];\n            },\n            set: function(h) {\n                if (!h) {\n                    me.removeAllListeners(ev);\n                    me._parser[\"on\" + ev] = h;\n                    return h;\n                }\n                me.on(ev, h);\n            },\n            enumerable: true,\n            configurable: false\n        });\n    });\n}",
	"node_modules/aws-sdk/dist/xml2js----error": "function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n        er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n}",
	"node_modules/aws-sdk/dist/xml2js----end": "function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n        error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n}",
	"node_modules/aws-sdk/dist/xml2js----newTag": "function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n    };\n    if (parser.opt.xmlns) {\n        tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n}",
	"node_modules/aws-sdk/dist/xml2js----qname": "function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [ \"\", name ] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n    if (attribute && name === \"xmlns\") {\n        prefix = \"xmlns\";\n        local = \"\";\n    }\n    return {\n        prefix: prefix,\n        local: local\n    };\n}",
	"node_modules/aws-sdk/dist/xml2js----attrib": "function attrib(parser) {\n    if (!parser.strict) {\n        parser.attribName = parser.attribName[parser.looseCase]();\n    }\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n        parser.attribName = parser.attribValue = \"\";\n        return;\n    }\n    if (parser.opt.xmlns) {\n        var qn = qname(parser.attribName, true);\n        var prefix = qn.prefix;\n        var local = qn.local;\n        if (prefix === \"xmlns\") {\n            if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n                strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else {\n                var tag = parser.tag;\n                var parent = parser.tags[parser.tags.length - 1] || parser;\n                if (tag.ns === parent.ns) {\n                    tag.ns = Object.create(parent.ns);\n                }\n                tag.ns[local] = parser.attribValue;\n            }\n        }\n        parser.attribList.push([ parser.attribName, parser.attribValue ]);\n    } else {\n        parser.tag.attributes[parser.attribName] = parser.attribValue;\n        emitNode(parser, \"onattribute\", {\n            name: parser.attribName,\n            value: parser.attribValue\n        });\n    }\n    parser.attribName = parser.attribValue = \"\";\n}",
	"node_modules/aws-sdk/dist/xml2js----openTag": "function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n        var tag = parser.tag;\n        var qn = qname(parser.tagName);\n        tag.prefix = qn.prefix;\n        tag.local = qn.local;\n        tag.uri = tag.ns[qn.prefix] || \"\";\n        if (tag.prefix && !tag.uri) {\n            strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n            tag.uri = qn.prefix;\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (tag.ns && parent.ns !== tag.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                emitNode(parser, \"onopennamespace\", {\n                    prefix: p,\n                    uri: tag.ns[p]\n                });\n            });\n        }\n        for (var i = 0, l = parser.attribList.length; i < l; i++) {\n            var nv = parser.attribList[i];\n            var name = nv[0];\n            var value = nv[1];\n            var qualName = qname(name, true);\n            var prefix = qualName.prefix;\n            var local = qualName.local;\n            var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n            var a = {\n                name: name,\n                value: value,\n                prefix: prefix,\n                local: local,\n                uri: uri\n            };\n            if (prefix && prefix !== \"xmlns\" && !uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                a.uri = prefix;\n            }\n            parser.tag.attributes[name] = a;\n            emitNode(parser, \"onattribute\", a);\n        }\n        parser.attribList.length = 0;\n    }\n    parser.tag.isSelfClosing = !!selfClosing;\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n        if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n            parser.state = S.SCRIPT;\n        } else {\n            parser.state = S.TEXT;\n        }\n        parser.tag = null;\n        parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n}",
	"node_modules/aws-sdk/dist/xml2js----closeTag": "function closeTag(parser) {\n    if (!parser.tagName) {\n        strictFail(parser, \"Weird empty close tag.\");\n        parser.textNode += \"</>\";\n        parser.state = S.TEXT;\n        return;\n    }\n    if (parser.script) {\n        if (parser.tagName !== \"script\") {\n            parser.script += \"</\" + parser.tagName + \">\";\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n            return;\n        }\n        emitNode(parser, \"onscript\", parser.script);\n        parser.script = \"\";\n    }\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n        tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n        var close = parser.tags[t];\n        if (close.name !== closeTo) {\n            strictFail(parser, \"Unexpected close tag\");\n        } else {\n            break;\n        }\n    }\n    if (t < 0) {\n        strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n        parser.textNode += \"</\" + parser.tagName + \">\";\n        parser.state = S.TEXT;\n        return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n        var tag = parser.tag = parser.tags.pop();\n        parser.tagName = parser.tag.name;\n        emitNode(parser, \"onclosetag\", parser.tagName);\n        var x = {};\n        for (var i in tag.ns) {\n            x[i] = tag.ns[i];\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (parser.opt.xmlns && tag.ns !== parent.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                var n = tag.ns[p];\n                emitNode(parser, \"onclosenamespace\", {\n                    prefix: p,\n                    uri: n\n                });\n            });\n        }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n}",
	"node_modules/aws-sdk/dist/xml2js----parseEntity": "function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n    if (parser.ENTITIES[entity]) {\n        return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n        return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n        if (entity.charAt(1) === \"x\") {\n            entity = entity.slice(2);\n            num = parseInt(entity, 16);\n            numStr = num.toString(16);\n        } else {\n            entity = entity.slice(1);\n            num = parseInt(entity, 10);\n            numStr = num.toString(10);\n        }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (numStr.toLowerCase() !== entity) {\n        strictFail(parser, \"Invalid character entity\");\n        return \"&\" + parser.entity + \";\";\n    }\n    return String.fromCodePoint(num);\n}",
	"node_modules/aws-sdk/dist/xml2js----write": "function write(chunk) {\n    var parser = this;\n    if (this.error) {\n        throw this.error;\n    }\n    if (parser.closed) {\n        return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    }\n    if (chunk === null) {\n        return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n        chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n        c = charAt(chunk, i++);\n        parser.c = c;\n        if (!c) {\n            break;\n        }\n        if (parser.trackPosition) {\n            parser.position++;\n            if (c === \"\\n\") {\n                parser.line++;\n                parser.column = 0;\n            } else {\n                parser.column++;\n            }\n        }\n        switch (parser.state) {\n          case S.BEGIN:\n            parser.state = S.BEGIN_WHITESPACE;\n            if (c === \"\\ufeff\") {\n                continue;\n            }\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.BEGIN_WHITESPACE:\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.TEXT:\n            if (parser.sawRoot && !parser.closedRoot) {\n                var starti = i - 1;\n                while (c && c !== \"<\" && c !== \"&\") {\n                    c = charAt(chunk, i++);\n                    if (c && parser.trackPosition) {\n                        parser.position++;\n                        if (c === \"\\n\") {\n                            parser.line++;\n                            parser.column = 0;\n                        } else {\n                            parser.column++;\n                        }\n                    }\n                }\n                parser.textNode += chunk.substring(starti, i - 1);\n            }\n            if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n            } else {\n                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n                    strictFail(parser, \"Text data outside of root node.\");\n                }\n                if (c === \"&\") {\n                    parser.state = S.TEXT_ENTITY;\n                } else {\n                    parser.textNode += c;\n                }\n            }\n            continue;\n\n          case S.SCRIPT:\n            if (c === \"<\") {\n                parser.state = S.SCRIPT_ENDING;\n            } else {\n                parser.script += c;\n            }\n            continue;\n\n          case S.SCRIPT_ENDING:\n            if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n            } else {\n                parser.script += \"<\" + c;\n                parser.state = S.SCRIPT;\n            }\n            continue;\n\n          case S.OPEN_WAKA:\n            if (c === \"!\") {\n                parser.state = S.SGML_DECL;\n                parser.sgmlDecl = \"\";\n            } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {\n                parser.state = S.OPEN_TAG;\n                parser.tagName = c;\n            } else if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n                parser.tagName = \"\";\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST;\n                parser.procInstName = parser.procInstBody = \"\";\n            } else {\n                strictFail(parser, \"Unencoded <\");\n                if (parser.startTagPosition + 1 < parser.position) {\n                    var pad = parser.position - parser.startTagPosition;\n                    c = new Array(pad).join(\" \") + c;\n                }\n                parser.textNode += \"<\" + c;\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.SGML_DECL:\n            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                emitNode(parser, \"onopencdata\");\n                parser.state = S.CDATA;\n                parser.sgmlDecl = \"\";\n                parser.cdata = \"\";\n            } else if (parser.sgmlDecl + c === \"--\") {\n                parser.state = S.COMMENT;\n                parser.comment = \"\";\n                parser.sgmlDecl = \"\";\n            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                parser.state = S.DOCTYPE;\n                if (parser.doctype || parser.sawRoot) {\n                    strictFail(parser, \"Inappropriately located doctype declaration\");\n                }\n                parser.doctype = \"\";\n                parser.sgmlDecl = \"\";\n            } else if (c === \">\") {\n                emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                parser.sgmlDecl = \"\";\n                parser.state = S.TEXT;\n            } else if (is(quote, c)) {\n                parser.state = S.SGML_DECL_QUOTED;\n                parser.sgmlDecl += c;\n            } else {\n                parser.sgmlDecl += c;\n            }\n            continue;\n\n          case S.SGML_DECL_QUOTED:\n            if (c === parser.q) {\n                parser.state = S.SGML_DECL;\n                parser.q = \"\";\n            }\n            parser.sgmlDecl += c;\n            continue;\n\n          case S.DOCTYPE:\n            if (c === \">\") {\n                parser.state = S.TEXT;\n                emitNode(parser, \"ondoctype\", parser.doctype);\n                parser.doctype = true;\n            } else {\n                parser.doctype += c;\n                if (c === \"[\") {\n                    parser.state = S.DOCTYPE_DTD;\n                } else if (is(quote, c)) {\n                    parser.state = S.DOCTYPE_QUOTED;\n                    parser.q = c;\n                }\n            }\n            continue;\n\n          case S.DOCTYPE_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.q = \"\";\n                parser.state = S.DOCTYPE;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD:\n            parser.doctype += c;\n            if (c === \"]\") {\n                parser.state = S.DOCTYPE;\n            } else if (is(quote, c)) {\n                parser.state = S.DOCTYPE_DTD_QUOTED;\n                parser.q = c;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.q = \"\";\n            }\n            continue;\n\n          case S.COMMENT:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDING;\n            } else {\n                parser.comment += c;\n            }\n            continue;\n\n          case S.COMMENT_ENDING:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDED;\n                parser.comment = textopts(parser.opt, parser.comment);\n                if (parser.comment) {\n                    emitNode(parser, \"oncomment\", parser.comment);\n                }\n                parser.comment = \"\";\n            } else {\n                parser.comment += \"-\" + c;\n                parser.state = S.COMMENT;\n            }\n            continue;\n\n          case S.COMMENT_ENDED:\n            if (c !== \">\") {\n                strictFail(parser, \"Malformed comment\");\n                parser.comment += \"--\" + c;\n                parser.state = S.COMMENT;\n            } else {\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.CDATA:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING;\n            } else {\n                parser.cdata += c;\n            }\n            continue;\n\n          case S.CDATA_ENDING:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING_2;\n            } else {\n                parser.cdata += \"]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.CDATA_ENDING_2:\n            if (c === \">\") {\n                if (parser.cdata) {\n                    emitNode(parser, \"oncdata\", parser.cdata);\n                }\n                emitNode(parser, \"onclosecdata\");\n                parser.cdata = \"\";\n                parser.state = S.TEXT;\n            } else if (c === \"]\") {\n                parser.cdata += \"]\";\n            } else {\n                parser.cdata += \"]]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.PROC_INST:\n            if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else if (is(whitespace, c)) {\n                parser.state = S.PROC_INST_BODY;\n            } else {\n                parser.procInstName += c;\n            }\n            continue;\n\n          case S.PROC_INST_BODY:\n            if (!parser.procInstBody && is(whitespace, c)) {\n                continue;\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else {\n                parser.procInstBody += c;\n            }\n            continue;\n\n          case S.PROC_INST_ENDING:\n            if (c === \">\") {\n                emitNode(parser, \"onprocessinginstruction\", {\n                    name: parser.procInstName,\n                    body: parser.procInstBody\n                });\n                parser.procInstName = parser.procInstBody = \"\";\n                parser.state = S.TEXT;\n            } else {\n                parser.procInstBody += \"?\" + c;\n                parser.state = S.PROC_INST_BODY;\n            }\n            continue;\n\n          case S.OPEN_TAG:\n            if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else {\n                newTag(parser);\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (c === \"/\") {\n                    parser.state = S.OPEN_TAG_SLASH;\n                } else {\n                    if (not(whitespace, c)) {\n                        strictFail(parser, \"Invalid character in tag name\");\n                    }\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.OPEN_TAG_SLASH:\n            if (c === \">\") {\n                openTag(parser, true);\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.ATTRIB:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (c === \">\") {\n                strictFail(parser, \"Attribute without value\");\n                parser.attribValue = parser.attribName;\n                attrib(parser);\n                openTag(parser);\n            } else if (is(whitespace, c)) {\n                parser.state = S.ATTRIB_NAME_SAW_WHITE;\n            } else if (is(nameBody, c)) {\n                parser.attribName += c;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME_SAW_WHITE:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (is(whitespace, c)) {\n                continue;\n            } else {\n                strictFail(parser, \"Attribute without value\");\n                parser.tag.attributes[parser.attribName] = \"\";\n                parser.attribValue = \"\";\n                emitNode(parser, \"onattribute\", {\n                    name: parser.attribName,\n                    value: \"\"\n                });\n                parser.attribName = \"\";\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (is(nameStart, c)) {\n                    parser.attribName = c;\n                    parser.state = S.ATTRIB_NAME;\n                } else {\n                    strictFail(parser, \"Invalid attribute name\");\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.ATTRIB_VALUE:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (is(quote, c)) {\n                parser.q = c;\n                parser.state = S.ATTRIB_VALUE_QUOTED;\n            } else {\n                strictFail(parser, \"Unquoted attribute value\");\n                parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                parser.attribValue = c;\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_QUOTED:\n            if (c !== parser.q) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            parser.q = \"\";\n            parser.state = S.ATTRIB_VALUE_CLOSED;\n            continue;\n\n          case S.ATTRIB_VALUE_CLOSED:\n            if (is(whitespace, c)) {\n                parser.state = S.ATTRIB;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                strictFail(parser, \"No whitespace between attributes\");\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_UNQUOTED:\n            if (not(attribEnd, c)) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            if (c === \">\") {\n                openTag(parser);\n            } else {\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.CLOSE_TAG:\n            if (!parser.tagName) {\n                if (is(whitespace, c)) {\n                    continue;\n                } else if (not(nameStart, c)) {\n                    if (parser.script) {\n                        parser.script += \"</\" + c;\n                        parser.state = S.SCRIPT;\n                    } else {\n                        strictFail(parser, \"Invalid tagname in closing tag.\");\n                    }\n                } else {\n                    parser.tagName = c;\n                }\n            } else if (c === \">\") {\n                closeTag(parser);\n            } else if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else if (parser.script) {\n                parser.script += \"</\" + parser.tagName;\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n            } else {\n                if (not(whitespace, c)) {\n                    strictFail(parser, \"Invalid tagname in closing tag\");\n                }\n                parser.state = S.CLOSE_TAG_SAW_WHITE;\n            }\n            continue;\n\n          case S.CLOSE_TAG_SAW_WHITE:\n            if (is(whitespace, c)) {\n                continue;\n            }\n            if (c === \">\") {\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Invalid characters in closing tag\");\n            }\n            continue;\n\n          case S.TEXT_ENTITY:\n          case S.ATTRIB_VALUE_ENTITY_Q:\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState;\n            var buffer;\n            switch (parser.state) {\n              case S.TEXT_ENTITY:\n                returnState = S.TEXT;\n                buffer = \"textNode\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_Q:\n                returnState = S.ATTRIB_VALUE_QUOTED;\n                buffer = \"attribValue\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_U:\n                returnState = S.ATTRIB_VALUE_UNQUOTED;\n                buffer = \"attribValue\";\n                break;\n            }\n            if (c === \";\") {\n                parser[buffer] += parseEntity(parser);\n                parser.entity = \"\";\n                parser.state = returnState;\n            } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n                parser.entity += c;\n            } else {\n                strictFail(parser, \"Invalid character in entity name\");\n                parser[buffer] += \"&\" + parser.entity + c;\n                parser.entity = \"\";\n                parser.state = returnState;\n            }\n            continue;\n\n          default:\n            throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n    }\n    if (parser.position >= parser.bufferCheckPosition) {\n        checkBufferLength(parser);\n    }\n    return parser;\n}",
	"node_modules/aws-sdk/dist/xml2js----from": "function from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}",
	"node_modules/aws-sdk/dist/xml2js----alloc": "function alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}",
	"node_modules/aws-sdk/dist/xml2js----allocUnsafe": "function allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/xml2js----fromString": "function fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        that = that.slice(0, actual);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/xml2js----fromArrayLike": "function fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/xml2js----fromArrayBuffer": "function fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength;\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/dist/xml2js----byteLength": "function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}",
	"node_modules/aws-sdk/dist/xml2js----slowToString": "function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n\n          case \"base64\":\n            return base64Slice(this, start, end);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----bidirectionalIndexOf": "function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    if (buffer.length === 0) return -1;\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (isNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1; else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0; else return -1;\n    }\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/aws-sdk/dist/xml2js----arrayIndexOf": "function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}",
	"node_modules/aws-sdk/dist/xml2js----hexWrite": "function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf8Slice": "function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                    codePoint = firstByte;\n                }\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n            }\n        }\n        if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}",
	"node_modules/aws-sdk/dist/xml2js----decodeCodePointsArray": "function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/xml2js----asciiSlice": "function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----latin1Slice": "function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----hexSlice": "function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf16leSlice": "function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}",
	"node_modules/aws-sdk/dist/xml2js----base64clean": "function base64clean(str) {\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2) return \"\";\n    while (str.length % 4 !== 0) {\n        str = str + \"=\";\n    }\n    return str;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf8ToBytes": "function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n                if (codePoint > 56319) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                } else if (i + 1 === length) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                }\n                leadSurrogate = codePoint;\n                continue;\n            }\n            if (codePoint < 56320) {\n                if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf16leToBytes": "function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}",
	"node_modules/aws-sdk/dist/xml2js----getLens": "function getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [ validLen, placeHoldersLen ];\n}",
	"node_modules/aws-sdk/dist/xml2js----toByteArray": "function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n    }\n    return arr;\n}",
	"node_modules/aws-sdk/dist/xml2js----encodeChunk": "function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}",
	"node_modules/aws-sdk/dist/xml2js----fromByteArray": "function fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n    }\n    return parts.join(\"\");\n}",
	"node_modules/aws-sdk/dist/xml2js----cleanup": "function cleanup() {\n    debug(\"cleanup\");\n    dest.removeListener(\"close\", onclose);\n    dest.removeListener(\"finish\", onfinish);\n    dest.removeListener(\"drain\", ondrain);\n    dest.removeListener(\"error\", onerror);\n    dest.removeListener(\"unpipe\", onunpipe);\n    src.removeListener(\"end\", onend);\n    src.removeListener(\"end\", unpipe);\n    src.removeListener(\"data\", ondata);\n    cleanedUp = true;\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n}",
	"node_modules/aws-sdk/dist/xml2js----ReadableState": "function ReadableState(options, stream) {\n    Duplex = Duplex || __webpack_require__(46);\n    options = options || {};\n    var isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    var hwm = options.highWaterMark;\n    var readableHwm = options.readableHighWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm;\n    this.highWaterMark = Math.floor(this.highWaterMark);\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    this.sync = true;\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n    this.destroyed = false;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.awaitDrain = 0;\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = __webpack_require__(51).StringDecoder;\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----Readable": "function Readable(options) {\n    Duplex = Duplex || __webpack_require__(46);\n    if (!(this instanceof Readable)) return new Readable(options);\n    this._readableState = new ReadableState(options, this);\n    this.readable = true;\n    if (options) {\n        if (typeof options.read === \"function\") this._read = options.read;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n    }\n    Stream.call(this);\n}",
	"node_modules/aws-sdk/dist/xml2js----howMuchToRead": "function howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return 1;\n    if (n !== n) {\n        if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;\n    }\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state.length) return n;\n    if (!state.ended) {\n        state.needReadable = true;\n        return 0;\n    }\n    return state.length;\n}",
	"node_modules/aws-sdk/dist/xml2js----onEofChunk": "function onEofChunk(stream, state) {\n    if (state.ended) return;\n    if (state.decoder) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    emitReadable(stream);\n}",
	"node_modules/aws-sdk/dist/xml2js----ondata": "function ondata(chunk) {\n    debug(\"ondata\");\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n            debug(\"false write response, pause\", src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            increasedAwaitDrain = true;\n        }\n        src.pause();\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----onerror": "function onerror(er) {\n    debug(\"onerror\", er);\n    unpipe();\n    dest.removeListener(\"error\", onerror);\n    if (EElistenerCount(dest, \"error\") === 0) dest.emit(\"error\", er);\n}",
	"node_modules/aws-sdk/dist/xml2js----resume_": "function resume_(stream, state) {\n    if (!state.reading) {\n        debug(\"resume read 0\");\n        stream.read(0);\n    }\n    state.resumeScheduled = false;\n    state.awaitDrain = 0;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}",
	"node_modules/aws-sdk/dist/xml2js----fromList": "function fromList(n, state) {\n    if (state.length === 0) return null;\n    var ret;\n    if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\"); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else {\n        ret = fromListPartial(n, state.buffer, state.decoder);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----copyFromBufferString": "function copyFromBufferString(n, list) {\n    var p = list.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n    while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str; else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n            if (nb === str.length) {\n                ++c;\n                if (p.next) list.head = p.next; else list.head = list.tail = null;\n            } else {\n                list.head = p;\n                p.data = str.slice(nb);\n            }\n            break;\n        }\n        ++c;\n    }\n    list.length -= c;\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----copyFromBuffer": "function copyFromBuffer(n, list) {\n    var ret = Buffer.allocUnsafe(n);\n    var p = list.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n    while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n            if (nb === buf.length) {\n                ++c;\n                if (p.next) list.head = p.next; else list.head = list.tail = null;\n            } else {\n                list.head = p;\n                p.data = buf.slice(nb);\n            }\n            break;\n        }\n        ++c;\n    }\n    list.length -= c;\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----cleanUpNextTick": "function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----drainQueue": "function drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}",
	"node_modules/aws-sdk/dist/xml2js----nextTick": "function nextTick(fn, arg1, arg2, arg3) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError('\"callback\" argument must be a function');\n    }\n    var len = arguments.length;\n    var args, i;\n    switch (len) {\n      case 0:\n      case 1:\n        return process.nextTick(fn);\n\n      case 2:\n        return process.nextTick(function afterTickOne() {\n            fn.call(null, arg1);\n        });\n\n      case 3:\n        return process.nextTick(function afterTickTwo() {\n            fn.call(null, arg1, arg2);\n        });\n\n      case 4:\n        return process.nextTick(function afterTickThree() {\n            fn.call(null, arg1, arg2, arg3);\n        });\n\n      default:\n        args = new Array(len - 1);\n        i = 0;\n        while (i < args.length) {\n            args[i++] = arguments[i];\n        }\n        return process.nextTick(function afterTick() {\n            fn.apply(null, args);\n        });\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----BufferList": "function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n}",
	"node_modules/aws-sdk/dist/xml2js----destroy": "function destroy(err, cb) {\n    var _this = this;\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n    if (readableDestroyed || writableDestroyed) {\n        if (cb) {\n            cb(err);\n        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n        }\n        return this;\n    }\n    if (this._readableState) {\n        this._readableState.destroyed = true;\n    }\n    if (this._writableState) {\n        this._writableState.destroyed = true;\n    }\n    this._destroy(err || null, function(err) {\n        if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n            if (_this._writableState) {\n                _this._writableState.errorEmitted = true;\n            }\n        } else if (cb) {\n            cb(err);\n        }\n    });\n    return this;\n}",
	"node_modules/aws-sdk/dist/xml2js----Duplex": "function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once(\"end\", onend);\n}",
	"node_modules/aws-sdk/dist/xml2js----WriteReq": "function WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n}",
	"node_modules/aws-sdk/dist/xml2js----CorkedRequest": "function CorkedRequest(state) {\n    var _this = this;\n    this.next = null;\n    this.entry = null;\n    this.finish = function() {\n        onCorkedFinish(_this, state);\n    };\n}",
	"node_modules/aws-sdk/dist/xml2js----WritableState": "function WritableState(options, stream) {\n    Duplex = Duplex || __webpack_require__(46);\n    options = options || {};\n    var isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    var hwm = options.highWaterMark;\n    var writableHwm = options.writableHighWaterMark;\n    var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm;\n    this.highWaterMark = Math.floor(this.highWaterMark);\n    this.finalCalled = false;\n    this.needDrain = false;\n    this.ending = false;\n    this.ended = false;\n    this.finished = false;\n    this.destroyed = false;\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.length = 0;\n    this.writing = false;\n    this.corked = 0;\n    this.sync = true;\n    this.bufferProcessing = false;\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    this.writecb = null;\n    this.writelen = 0;\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n    this.pendingcb = 0;\n    this.prefinished = false;\n    this.errorEmitted = false;\n    this.bufferedRequestCount = 0;\n    this.corkedRequestsFree = new CorkedRequest(this);\n}",
	"node_modules/aws-sdk/dist/xml2js----Writable": "function Writable(options) {\n    Duplex = Duplex || __webpack_require__(46);\n    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n        return new Writable(options);\n    }\n    this._writableState = new WritableState(options, this);\n    this.writable = true;\n    if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n    }\n    Stream.call(this);\n}",
	"node_modules/aws-sdk/dist/xml2js----validChunk": "function validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    var er = false;\n    if (chunk === null) {\n        er = new TypeError(\"May not write null values to stream\");\n    } else if (typeof chunk !== \"string\" && chunk !== undefined && !state.objectMode) {\n        er = new TypeError(\"Invalid non-string/buffer chunk\");\n    }\n    if (er) {\n        stream.emit(\"error\", er);\n        pna.nextTick(cb, er);\n        valid = false;\n    }\n    return valid;\n}",
	"node_modules/aws-sdk/dist/xml2js----writeOrBuffer": "function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n    if (!isBuf) {\n        var newChunk = decodeChunk(state, chunk, encoding);\n        if (chunk !== newChunk) {\n            isBuf = true;\n            encoding = \"buffer\";\n            chunk = newChunk;\n        }\n    }\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = {\n            chunk: chunk,\n            encoding: encoding,\n            isBuf: isBuf,\n            callback: cb,\n            next: null\n        };\n        if (last) {\n            last.next = state.lastBufferedRequest;\n        } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n        }\n        state.bufferedRequestCount += 1;\n    } else {\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/dist/xml2js----doWrite": "function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}",
	"node_modules/aws-sdk/dist/xml2js----onwriteStateUpdate": "function onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}",
	"node_modules/aws-sdk/dist/xml2js----onwrite": "function onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb); else {\n        var finished = needFinish(state);\n        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            asyncWrite(afterWrite, stream, state, finished, cb);\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----afterWrite": "function afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}",
	"node_modules/aws-sdk/dist/xml2js----clearBuffer": "function clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n    if (stream._writev && entry && entry.next) {\n        var l = state.bufferedRequestCount;\n        var buffer = new Array(l);\n        var holder = state.corkedRequestsFree;\n        holder.entry = entry;\n        var count = 0;\n        var allBuffers = true;\n        while (entry) {\n            buffer[count] = entry;\n            if (!entry.isBuf) allBuffers = false;\n            entry = entry.next;\n            count += 1;\n        }\n        buffer.allBuffers = allBuffers;\n        doWrite(stream, state, true, state.length, buffer, \"\", holder.finish);\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n        if (holder.next) {\n            state.corkedRequestsFree = holder.next;\n            holder.next = null;\n        } else {\n            state.corkedRequestsFree = new CorkedRequest(state);\n        }\n        state.bufferedRequestCount = 0;\n    } else {\n        while (entry) {\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            state.bufferedRequestCount--;\n            if (state.writing) {\n                break;\n            }\n        }\n        if (entry === null) state.lastBufferedRequest = null;\n    }\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n}",
	"node_modules/aws-sdk/dist/xml2js----endWritable": "function endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) pna.nextTick(cb); else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n    stream.writable = false;\n}",
	"node_modules/aws-sdk/dist/xml2js----onCorkedFinish": "function onCorkedFinish(corkReq, state, err) {\n    var entry = corkReq.entry;\n    corkReq.entry = null;\n    while (entry) {\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n        state.corkedRequestsFree.next = corkReq;\n    } else {\n        state.corkedRequestsFree = corkReq;\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----setImmediate": "function setImmediate(callback) {\n    if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n    }\n    var args = new Array(arguments.length - 1);\n    for (var i = 0; i < args.length; i++) {\n        args[i] = arguments[i + 1];\n    }\n    var task = {\n        callback: callback,\n        args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n}",
	"node_modules/aws-sdk/dist/xml2js----installPostMessageImplementation": "function installPostMessageImplementation() {\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n    var onGlobalMessage = function(event) {\n        if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n            runIfPresent(+event.data.slice(messagePrefix.length));\n        }\n    };\n    if (global.addEventListener) {\n        global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n        global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n    registerImmediate = function(handle) {\n        global.postMessage(messagePrefix + handle, \"*\");\n    };\n}",
	"node_modules/aws-sdk/dist/xml2js----deprecate": "function deprecate(fn, msg) {\n    if (config(\"noDeprecation\")) {\n        return fn;\n    }\n    var warned = false;\n    function deprecated() {\n        if (!warned) {\n            if (config(\"throwDeprecation\")) {\n                throw new Error(msg);\n            } else if (config(\"traceDeprecation\")) {\n                console.trace(msg);\n            } else {\n                console.warn(msg);\n            }\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n    return deprecated;\n}",
	"node_modules/aws-sdk/dist/xml2js----config": "function config(name) {\n    try {\n        if (!global.localStorage) return false;\n    } catch (_) {\n        return false;\n    }\n    var val = global.localStorage[name];\n    if (null == val) return false;\n    return String(val).toLowerCase() === \"true\";\n}",
	"node_modules/aws-sdk/dist/xml2js----StringDecoder": "function StringDecoder(encoding) {\n    this.encoding = normalizeEncoding(encoding);\n    var nb;\n    switch (this.encoding) {\n      case \"utf16le\":\n        this.text = utf16Text;\n        this.end = utf16End;\n        nb = 4;\n        break;\n\n      case \"utf8\":\n        this.fillLast = utf8FillLast;\n        nb = 4;\n        break;\n\n      case \"base64\":\n        this.text = base64Text;\n        this.end = base64End;\n        nb = 3;\n        break;\n\n      default:\n        this.write = simpleWrite;\n        this.end = simpleEnd;\n        return;\n    }\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = Buffer.allocUnsafe(nb);\n}",
	"node_modules/aws-sdk/dist/xml2js----utf8CheckIncomplete": "function utf8CheckIncomplete(self, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 1;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 2;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) {\n            if (nb === 2) nb = 0; else self.lastNeed = nb - 3;\n        }\n        return nb;\n    }\n    return 0;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf8FillLast": "function utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = utf8CheckExtraBytes(this, buf, p);\n    if (r !== undefined) return r;\n    if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, p, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n}",
	"node_modules/aws-sdk/dist/xml2js----utf8Text": "function utf8Text(buf, i) {\n    var total = utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString(\"utf8\", i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString(\"utf8\", i, end);\n}",
	"node_modules/aws-sdk/dist/xml2js----utf16Text": "function utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n        var r = buf.toString(\"utf16le\", i);\n        if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 55296 && c <= 56319) {\n                this.lastNeed = 2;\n                this.lastTotal = 4;\n                this.lastChar[0] = buf[buf.length - 2];\n                this.lastChar[1] = buf[buf.length - 1];\n                return r.slice(0, -1);\n            }\n        }\n        return r;\n    }\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString(\"utf16le\", i, buf.length - 1);\n}",
	"node_modules/aws-sdk/dist/xml2js----base64Text": "function base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString(\"base64\", i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n    if (n === 1) {\n        this.lastChar[0] = buf[buf.length - 1];\n    } else {\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n    }\n    return buf.toString(\"base64\", i, buf.length - n);\n}",
	"node_modules/aws-sdk/dist/xml2js----afterTransform": "function afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (!cb) {\n        return this.emit(\"error\", new Error(\"write callback called multiple times\"));\n    }\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null) this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        this._read(rs.highWaterMark);\n    }\n}",
	"node_modules/aws-sdk/dist/xml2js----Transform": "function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n        afterTransform: afterTransform.bind(this),\n        needTransform: false,\n        transforming: false,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n    };\n    this._readableState.needReadable = true;\n    this._readableState.sync = false;\n    if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    this.on(\"prefinish\", prefinish);\n}",
	"node_modules/aws-sdk/dist/xml2js----done": "function done(stream, er, data) {\n    if (er) return stream.emit(\"error\", er);\n    if (data != null) stream.push(data);\n    if (stream._writableState.length) throw new Error(\"Calling transform done when ws.length != 0\");\n    if (stream._transformState.transforming) throw new Error(\"Calling transform done when still transforming\");\n    return stream.push(null);\n}",
	"node_modules/aws-sdk/dist-tools/browser-builder----build": "function build(options, callback) {\n    if (arguments.length === 1) {\n        callback = options;\n        options = {};\n    }\n    var img = require(\"insert-module-globals\");\n    img.vars.process = function() {\n        return \"{browser:true}\";\n    };\n    if (options.services) process.env.AWS_SERVICES = options.services;\n    var browserify = require(\"browserify\");\n    var brOpts = {\n        basedir: path.resolve(__dirname, \"..\")\n    };\n    browserify(brOpts).add(\"./\").ignore(\"domain\").bundle(function(err, data) {\n        if (err) return callback(err);\n        var code = (data || \"\").toString();\n        if (options.minify) code = minify(code);\n        code = license + code;\n        callback(null, code);\n    });\n}",
	"node_modules/aws-sdk/dist-tools/client-creator----ClientCreator": "function ClientCreator(basePath) {\n    basePath = basePath || path.join(__dirname, \"..\");\n    this._metadataPath = path.join(basePath, \"apis\", \"metadata.json\");\n    this._apisFolderPath = path.join(basePath, \"apis\");\n    this._clientFolderPath = path.join(basePath, \"clients\");\n    this._serviceCustomizationsFolderPath = path.join(basePath, \"lib\", \"services\");\n    this._packageJsonPath = path.join(basePath, \"package.json\");\n    this._apiFileNames = null;\n    this._metadata = null;\n}",
	"node_modules/aws-sdk/dist-tools/service-collector----getServiceHeader": "function getServiceHeader(service) {\n    if (service === \"all\") {\n        return Object.keys(serviceClasses).map(function(name) {\n            return getServiceHeader(name);\n        }).join(\"\\n\");\n    }\n    if (!serviceClasses[service]) return null;\n    var versions = serviceClasses[service].apiVersions.map(function(version) {\n        return version.indexOf(\"*\") >= 0 ? null : version;\n    }).filter(function(c) {\n        return c !== null;\n    });\n    var file = util.format(\"if (!Object.prototype.hasOwnProperty.call(AWS, '\" + metadata[service].name + \"')) {\\n\" + \"  AWS.apiLoader.services['%s'] = {};\\n\" + \"  AWS.%s = AWS.Service.defineService('%s', %s);\\n\", service, metadata[service].name, service, util.inspect(versions));\n    var svcPath = path.join(__dirname, \"..\", \"lib\", \"services\", service + \".js\");\n    if (fs.existsSync(svcPath)) {\n        file += \"  require('./services/\" + service + \"');\\n\";\n    }\n    file += \"}\\n\";\n    return file;\n}",
	"node_modules/aws-sdk/dist-tools/service-collector----getService": "function getService(service, version) {\n    if (service === \"all\") {\n        return Object.keys(serviceClasses).map(function(name) {\n            var out = serviceClasses[name].apiVersions.map(function(svcVersion) {\n                if (svcVersion.indexOf(\"*\") >= 0) return null;\n                return getService(name, svcVersion);\n            }).filter(function(c) {\n                return c !== null;\n            }).join(\"\\n\");\n            return out;\n        }).join(\"\\n\");\n    }\n    var svc, api;\n    if (!serviceClasses[service]) {\n        return null;\n    }\n    try {\n        var ClassName = serviceClasses[service];\n        svc = new ClassName({\n            apiVersion: version,\n            endpoint: \"localhost\"\n        });\n        api = svc.api;\n    } catch (e) {\n        return null;\n    }\n    var serviceFileName = metadata[service].prefix || service;\n    var lines = [];\n    var line = util.format(\"AWS.apiLoader.services['%s']['%s'] = %s;\\n\", service, svc.api.apiVersion, \"require('../apis/\" + serviceFileName + \"-\" + svc.api.apiVersion + \".min')\");\n    lines.push(line);\n    if (Object.prototype.hasOwnProperty.call(api, \"paginators\") && Object.keys(api.paginators).length) {\n        line = util.format(\"AWS.apiLoader.services['%s']['%s'].paginators = %s;\\n\", service, svc.api.apiVersion, \"require('../apis/\" + serviceFileName + \"-\" + svc.api.apiVersion + \".paginators').pagination\");\n        lines.push(line);\n    }\n    if (Object.prototype.hasOwnProperty.call(api, \"waiters\") && Object.keys(api.waiters).length) {\n        line = util.format(\"AWS.apiLoader.services['%s']['%s'].waiters = %s;\\n\", service, svc.api.apiVersion, \"require('../apis/\" + serviceFileName + \"-\" + svc.api.apiVersion + \".waiters2').waiters\");\n        lines.push(line);\n    }\n    return lines.join(\"\");\n}",
	"node_modules/aws-sdk/dist-tools/service-collector----ServiceCollector": "function ServiceCollector(services) {\n    var builtServices = {};\n    function buildService(name, usingDefaultServices) {\n        var match = name.match(/^(.+?)(?:-(.+?))?$/);\n        var service = match[1], version = match[2] || \"latest\";\n        var contents = [];\n        var lines, err;\n        if (!builtServices[service]) {\n            builtServices[service] = {};\n            lines = getServiceHeader(service);\n            if (lines === null) {\n                if (!usingDefaultServices) {\n                    err = new Error(\"Invalid module: \" + service);\n                    err.name = \"InvalidModuleError\";\n                    throw err;\n                }\n            } else {\n                contents.push(lines);\n            }\n        }\n        if (!builtServices[service][version]) {\n            builtServices[service][version] = true;\n            lines = getService(service, version);\n            if (lines === null) {\n                if (!usingDefaultServices) {\n                    err = new Error(\"Invalid module: \" + service + \"-\" + version);\n                    err.name = \"InvalidModuleError\";\n                    throw err;\n                }\n            } else {\n                contents.push(lines);\n            }\n        }\n        return contents.join(\"\");\n    }\n    var serviceCode = \"\";\n    var usingDefaultServicesToggle = false;\n    if (!services) {\n        usingDefaultServicesToggle = true;\n        services = defaultServices;\n    }\n    if (services.match(sanitizeRegex)) {\n        throw new Error(\"Incorrectly formatted service names\");\n    }\n    var invalidModules = [];\n    services.split(\",\").sort().forEach(function(name) {\n        if ([ \"cognitoidentity\", \"sts\" ].indexOf(name) >= 0) {\n            return;\n        }\n        try {\n            serviceCode += buildService(name, usingDefaultServicesToggle) + \"\\n\";\n        } catch (e) {\n            if (e.name === \"InvalidModuleError\") invalidModules.push(name); else throw e;\n        }\n    });\n    if (invalidModules.length > 0) {\n        throw new Error(\"Missing modules: \" + invalidModules.join(\", \"));\n    }\n    return serviceCode;\n}",
	"node_modules/aws-sdk/lib/browserHmac----Hmac": "function Hmac(hashCtor, secret) {\n    this.hash = new hashCtor();\n    this.outer = new hashCtor();\n    var inner = bufferFromSecret(hashCtor, secret);\n    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);\n    outer.set(inner);\n    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {\n        inner[i] ^= 54;\n        outer[i] ^= 92;\n    }\n    this.hash.update(inner);\n    this.outer.update(outer);\n    for (var i = 0; i < inner.byteLength; i++) {\n        inner[i] = 0;\n    }\n}",
	"node_modules/aws-sdk/lib/browserHmac----bufferFromSecret": "function bufferFromSecret(hashCtor, secret) {\n    var input = hashUtils.convertToBuffer(secret);\n    if (input.byteLength > hashCtor.BLOCK_SIZE) {\n        var bufferHash = new hashCtor();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n    }\n    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\n    buffer.set(input);\n    return buffer;\n}",
	"node_modules/aws-sdk/lib/browserMd5----Md5": "function Md5() {\n    this.state = [ 1732584193, 4023233417, 2562383102, 271733878 ];\n    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/lib/browserSha1----Sha1": "function Sha1() {\n    this.h0 = 1732584193;\n    this.h1 = 4023233417;\n    this.h2 = 2562383102;\n    this.h3 = 271733878;\n    this.h4 = 3285377520;\n    this.block = new Uint32Array(80);\n    this.offset = 0;\n    this.shift = 24;\n    this.totalLength = 0;\n}",
	"node_modules/aws-sdk/lib/browserSha256----Sha256": "function Sha256() {\n    this.state = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(64);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n}",
	"node_modules/aws-sdk/lib/discover_endpoint----getCacheKey": "function getCacheKey(request) {\n    var service = request.service;\n    var api = service.api || {};\n    var operations = api.operations;\n    var identifiers = {};\n    if (service.config.region) {\n        identifiers.region = service.config.region;\n    }\n    if (api.serviceId) {\n        identifiers.serviceId = api.serviceId;\n    }\n    if (service.config.credentials.accessKeyId) {\n        identifiers.accessKeyId = service.config.credentials.accessKeyId;\n    }\n    return identifiers;\n}",
	"node_modules/aws-sdk/lib/discover_endpoint----optionalDiscoverEndpoint": "function optionalDiscoverEndpoint(request) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var endpoints = AWS.endpointCache.get(cacheKey);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        addApiVersionHeader(endpointRequest);\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        endpointRequest.removeListener(\"retry\", AWS.EventListeners.Core.RETRY_CHECK);\n        AWS.endpointCache.put(cacheKey, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 1\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (data && data.Endpoints) {\n                AWS.endpointCache.put(cacheKey, data.Endpoints);\n            } else if (err) {\n                AWS.endpointCache.put(cacheKey, [ {\n                    Address: \"\",\n                    CachePeriodInMinutes: 1\n                } ]);\n            }\n        });\n    }\n}",
	"node_modules/aws-sdk/lib/discover_endpoint----requiredDiscoverEndpoint": "function requiredDiscoverEndpoint(request, done) {\n    var service = request.service;\n    var api = service.api;\n    var operationModel = api.operations ? api.operations[request.operation] : undefined;\n    var inputShape = operationModel ? operationModel.input : undefined;\n    var identifiers = marshallCustomIdentifiers(request, inputShape);\n    var cacheKey = getCacheKey(request);\n    if (Object.keys(identifiers).length > 0) {\n        cacheKey = util.update(cacheKey, identifiers);\n        if (operationModel) cacheKey.operation = operationModel.name;\n    }\n    var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n    var endpoints = AWS.endpointCache.get(cacheKeyStr);\n    if (endpoints && endpoints.length === 1 && endpoints[0].Address === \"\") {\n        if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n        requestQueue[cacheKeyStr].push({\n            request: request,\n            callback: done\n        });\n        return;\n    } else if (endpoints && endpoints.length > 0) {\n        request.httpRequest.updateEndpoint(endpoints[0].Address);\n        done();\n    } else {\n        var endpointRequest = service.makeRequest(api.endpointOperation, {\n            Operation: operationModel.name,\n            Identifiers: identifiers\n        });\n        endpointRequest.removeListener(\"validate\", AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n        addApiVersionHeader(endpointRequest);\n        AWS.endpointCache.put(cacheKeyStr, [ {\n            Address: \"\",\n            CachePeriodInMinutes: 60\n        } ]);\n        endpointRequest.send(function(err, data) {\n            if (err) {\n                request.response.error = util.error(err, {\n                    retryable: false\n                });\n                AWS.endpointCache.remove(cacheKey);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.response.error = util.error(err, {\n                            retryable: false\n                        });\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            } else if (data) {\n                AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n                request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                if (requestQueue[cacheKeyStr]) {\n                    var pendingRequests = requestQueue[cacheKeyStr];\n                    util.arrayEach(pendingRequests, function(requestContext) {\n                        requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                        requestContext.callback();\n                    });\n                    delete requestQueue[cacheKeyStr];\n                }\n            }\n            done();\n        });\n    }\n}",
	"node_modules/aws-sdk/lib/event_listeners----buildMessage": "function buildMessage() {\n    var time = resp.request.service.getSkewCorrectedDate().getTime();\n    var delta = (time - req.startTime.getTime()) / 1e3;\n    var ansi = logger.isTTY ? true : false;\n    var status = resp.httpResponse.statusCode;\n    var censoredParams = req.params;\n    if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {\n        var inputShape = req.service.api.operations[req.operation].input;\n        censoredParams = filterSensitiveLog(inputShape, req.params);\n    }\n    var params = require(\"util\").inspect(censoredParams, true, null);\n    var message = \"\";\n    if (ansi) message += \"\u001b[33m\";\n    message += \"[AWS \" + req.service.serviceIdentifier + \" \" + status;\n    message += \" \" + delta.toString() + \"s \" + resp.retryCount + \" retries]\";\n    if (ansi) message += \"\u001b[0;1m\";\n    message += \" \" + AWS.util.string.lowerFirst(req.operation);\n    message += \"(\" + params + \")\";\n    if (ansi) message += \"\u001b[0m\";\n    return message;\n}",
	"node_modules/aws-sdk/lib/region_config----getEndpointSuffix": "function getEndpointSuffix(region) {\n    var regionRegexes = {\n        \"^(us|eu|ap|sa|ca|me)\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^cn\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com.cn\",\n        \"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\": \"amazonaws.com\",\n        \"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\": \"c2s.ic.gov\",\n        \"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\": \"sc2s.sgov.gov\"\n    };\n    var defaultSuffix = \"amazonaws.com\";\n    var regexes = Object.keys(regionRegexes);\n    for (var i = 0; i < regexes.length; i++) {\n        var regionPattern = RegExp(regexes[i]);\n        var dnsSuffix = regionRegexes[regexes[i]];\n        if (regionPattern.test(region)) return dnsSuffix;\n    }\n    return defaultSuffix;\n}",
	"node_modules/aws-sdk/lib/request----wrappedCallback": "function wrappedCallback(err, data) {\n    if (err) return callback(err, null);\n    if (data === null) return callback(null, null);\n    var config = self.service.paginationConfig(self.operation);\n    var resultKey = config.resultKey;\n    if (Array.isArray(resultKey)) resultKey = resultKey[0];\n    var items = jmespath.search(data, resultKey);\n    var continueIteration = true;\n    AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n            return AWS.util.abort;\n        }\n    });\n    return continueIteration;\n}",
	"node_modules/aws-sdk/lib/resource_waiter----CHECK_ACCEPTORS": "function CHECK_ACCEPTORS(resp) {\n    var waiter = resp.request._waiter;\n    var acceptors = waiter.config.acceptors;\n    var acceptorMatched = false;\n    var state = \"retry\";\n    acceptors.forEach(function(acceptor) {\n        if (!acceptorMatched) {\n            var matcher = waiter.matchers[acceptor.matcher];\n            if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n                acceptorMatched = true;\n                state = acceptor.state;\n            }\n        }\n    });\n    if (!acceptorMatched && resp.error) state = \"failure\";\n    if (state === \"success\") {\n        waiter.setSuccess(resp);\n    } else {\n        waiter.setError(resp, state === \"retry\");\n    }\n}",
	"node_modules/eventemitter3/umd/eventemitter3----addListener": "function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++; else if (!emitter._events[evt].fn) emitter._events[evt].push(listener); else emitter._events[evt] = [ emitter._events[evt], listener ];\n    return emitter;\n}",
	"node_modules/events/tests/add-listeners----hello": "function hello(a, b) {\n    console.log(\"hello\");\n    times_hello_emited += 1;\n    assert.equal(\"a\", a);\n    assert.equal(\"b\", b);\n}",
	"node_modules/events/tests/modify-in-emit----callback1": "function callback1() {\n    callbacks_called.push(\"callback1\");\n    e.on(\"foo\", callback2);\n    e.on(\"foo\", callback3);\n    e.removeListener(\"foo\", callback1);\n}",
	"node_modules/events/tests/remove-all-listeners----expect": "function expect(expected) {\n    var actual = [];\n    after_checks.push(function() {\n        assert.deepEqual(actual.sort(), expected.sort());\n    });\n    function listener(name) {\n        actual.push(name);\n    }\n    return common.mustCall(listener, expected.length);\n}",
	"node_modules/events/tests/subclass----MyEE": "function MyEE(cb) {\n    this.once(1, cb);\n    this.emit(1);\n    this.removeAllListeners();\n    EventEmitter.call(this);\n}",
	"node_modules/jmespath/artifacts/jmespath.min----d": "function d(a, e) {\n    if (a === e) return !0;\n    var f = Object.prototype.toString.call(a);\n    if (f !== Object.prototype.toString.call(e)) return !1;\n    if (b(a) === !0) {\n        if (a.length !== e.length) return !1;\n        for (var g = 0; g < a.length; g++) if (d(a[g], e[g]) === !1) return !1;\n        return !0;\n    }\n    if (c(a) === !0) {\n        var h = {};\n        for (var i in a) if (hasOwnProperty.call(a, i)) {\n            if (d(a[i], e[i]) === !1) return !1;\n            h[i] = !0;\n        }\n        for (var j in e) if (hasOwnProperty.call(e, j) && h[j] !== !0) return !1;\n        return !0;\n    }\n    return !1;\n}",
	"node_modules/jmespath/artifacts/jmespath.min----e": "function e(a) {\n    if (\"\" === a || a === !1 || null === a) return !0;\n    if (b(a) && 0 === a.length) return !0;\n    if (c(a)) {\n        for (var d in a) if (a.hasOwnProperty(d)) return !1;\n        return !0;\n    }\n    return !1;\n}",
	"node_modules/jmespath/artifacts/jmespath.min----p": "function p(a, b) {\n    var c = new k(), d = new m(), e = new l(d);\n    d.a = e;\n    var f = c.parse(b);\n    return e.search(f, a);\n}",
	"node_modules/node-addon-api/tools/check-napi----checkFile": "function checkFile(file, command, argv, reducer) {\n    const child = child_process.spawn(command, argv, {\n        stdio: [ \"inherit\", \"pipe\", \"inherit\" ]\n    });\n    let leftover = \"\";\n    let isNapi = undefined;\n    child.stdout.on(\"data\", chunk => {\n        if (isNapi === undefined) {\n            chunk = (leftover + chunk.toString()).split(/[\\r\\n]+/);\n            leftover = chunk.pop();\n            isNapi = chunk.reduce(reducer, isNapi);\n            if (isNapi !== undefined) {\n                child.kill();\n            }\n        }\n    });\n    child.on(\"close\", (code, signal) => {\n        if (code === null && signal !== null || code !== 0) {\n            console.log(command + \" exited with code: \" + code + \" and signal: \" + signal);\n        } else {\n            console.log(\"\u001b[\" + (isNapi ? \"42\" : \"41\") + \"m\" + (isNapi ? \"    N-API\" : \"Not N-API\") + \"\u001b[0m: \" + file);\n        }\n    });\n}",
	"node_modules/node-addon-api/tools/clang-format----main": "function main(args) {\n    let fix = false;\n    while (args.length > 0) {\n        switch (args[0]) {\n          case \"-f\":\n          case \"--fix\":\n            fix = true;\n            break;\n\n          default:\n        }\n        args.shift();\n    }\n    const clangFormatPath = path.dirname(require.resolve(\"clang-format\"));\n    const binary = process.platform === \"win32\" ? \"node_modules\\\\.bin\\\\clang-format.cmd\" : \"node_modules/.bin/clang-format\";\n    const options = [ \"--binary=\" + binary, \"--style=file\" ];\n    if (fix) {\n        options.push(FORMAT_START);\n    } else {\n        options.push(\"--diff\", FORMAT_START);\n    }\n    const gitClangFormatPath = path.join(clangFormatPath, \"bin/git-clang-format\");\n    const result = spawn(\"python\", [ gitClangFormatPath, ...options, \"--\", ...filesToCheck ], {\n        encoding: \"utf-8\"\n    });\n    if (result.stderr) {\n        console.error(\"Error running git-clang-format:\", result.stderr);\n        return 2;\n    }\n    const clangFormatOutput = result.stdout.trim();\n    if (fix) {\n        console.log(clangFormatOutput);\n        return 0;\n    }\n    if (clangFormatOutput !== \"\" && clangFormatOutput !== \"no modified files to format\" && clangFormatOutput !== \"clang-format did not modify any files\") {\n        console.error(clangFormatOutput);\n        const fixCmd = \"npm run lint:fix\";\n        console.error(`\n      ERROR: please run \"${fixCmd}\" to format changes in your commit\n        Note that when running the command locally, please keep your local\n        main branch and working branch up to date with nodejs/node-addon-api\n        to exclude un-related complains.\n        Or you can run \"env FORMAT_START=upstream/main ${fixCmd}\".`);\n        return 1;\n    }\n}",
	"node_modules/node-addon-api/tools/conversion----listFiles": "function listFiles(dir, filelist) {\n    var files = fs.readdirSync(dir);\n    filelist = filelist || [];\n    files.forEach(function(file) {\n        if (file === \"node_modules\") {\n            return;\n        }\n        if (fs.statSync(path.join(dir, file)).isDirectory()) {\n            filelist = listFiles(path.join(dir, file), filelist);\n        } else {\n            filelist.push(path.join(dir, file));\n        }\n    });\n    return filelist;\n}",
	"node_modules/node-addon-api/tools/eslint-format----main": "function main(args) {\n    let fix = false;\n    while (args.length > 0) {\n        switch (args[0]) {\n          case \"-f\":\n          case \"--fix\":\n            fix = true;\n            break;\n\n          default:\n        }\n        args.shift();\n    }\n    const fileUnStaged = spawn(\"git\", [ \"diff\", \"--name-only\", FORMAT_START, filesToCheck ], {\n        encoding: \"utf-8\"\n    });\n    const fileStaged = spawn(\"git\", [ \"diff\", \"--name-only\", \"--cached\", FORMAT_START, filesToCheck ], {\n        encoding: \"utf-8\"\n    });\n    const options = [ ...fileStaged.stdout.split(\"\\n\").filter(f => f !== \"\"), ...fileUnStaged.stdout.split(\"\\n\").filter(f => f !== \"\") ];\n    if (fix) {\n        options.push(\"--fix\");\n    }\n    const result = spawn(\"node_modules/.bin/eslint\", [ ...options ], {\n        encoding: \"utf-8\"\n    });\n    if (result.status === 1) {\n        console.error(\"Eslint error:\", result.stdout);\n        const fixCmd = \"npm run lint:fix\";\n        console.error(`ERROR: please run \"${fixCmd}\" to format changes in your commit\n    Note that when running the command locally, please keep your local\n    main branch and working branch up to date with nodejs/node-addon-api\n    to exclude un-related complains.\n    Or you can run \"env FORMAT_START=upstream/main ${fixCmd}\".\n    Also fix JS files by yourself if necessary.`);\n        return 1;\n    }\n    if (result.stderr) {\n        console.error(\"Error running eslint:\", result.stderr);\n        return 2;\n    }\n}",
	"node_modules/readable-stream/lib/_stream_duplex----Duplex": "function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    this.allowHalfOpen = true;\n    if (options) {\n        if (options.readable === false) this.readable = false;\n        if (options.writable === false) this.writable = false;\n        if (options.allowHalfOpen === false) {\n            this.allowHalfOpen = false;\n            this.once(\"end\", onend);\n        }\n    }\n}",
	"node_modules/readable-stream/lib/_stream_readable----ReadableState": "function ReadableState(options, stream, isDuplex) {\n    Duplex = Duplex || require(\"./_stream_duplex\");\n    options = options || {};\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    this.highWaterMark = getHighWaterMark(this, options, \"readableHighWaterMark\", isDuplex);\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    this.sync = true;\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n    this.paused = true;\n    this.emitClose = options.emitClose !== false;\n    this.autoDestroy = !!options.autoDestroy;\n    this.destroyed = false;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.awaitDrain = 0;\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = require(\"string_decoder/\").StringDecoder;\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}",
	"node_modules/readable-stream/lib/_stream_readable----Readable": "function Readable(options) {\n    Duplex = Duplex || require(\"./_stream_duplex\");\n    if (!(this instanceof Readable)) return new Readable(options);\n    var isDuplex = this instanceof Duplex;\n    this._readableState = new ReadableState(options, this, isDuplex);\n    this.readable = true;\n    if (options) {\n        if (typeof options.read === \"function\") this._read = options.read;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n    }\n    Stream.call(this);\n}",
	"node_modules/readable-stream/lib/_stream_readable----readableAddChunk": "function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n    debug(\"readableAddChunk\", chunk);\n    var state = stream._readableState;\n    if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n    } else {\n        var er;\n        if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n        if (er) {\n            errorOrDestroy(stream, er);\n        } else if (state.objectMode || chunk && chunk.length > 0) {\n            if (typeof chunk !== \"string\" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                chunk = _uint8ArrayToBuffer(chunk);\n            }\n            if (addToFront) {\n                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()); else addChunk(stream, state, chunk, true);\n            } else if (state.ended) {\n                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n            } else if (state.destroyed) {\n                return false;\n            } else {\n                state.reading = false;\n                if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);\n                } else {\n                    addChunk(stream, state, chunk, false);\n                }\n            }\n        } else if (!addToFront) {\n            state.reading = false;\n            maybeReadMore(stream, state);\n        }\n    }\n    return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}",
	"node_modules/readable-stream/lib/_stream_readable----howMuchToRead": "function howMuchToRead(n, state) {\n    if (n <= 0 || state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return 1;\n    if (n !== n) {\n        if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;\n    }\n    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state.length) return n;\n    if (!state.ended) {\n        state.needReadable = true;\n        return 0;\n    }\n    return state.length;\n}",
	"node_modules/readable-stream/lib/_stream_readable----onEofChunk": "function onEofChunk(stream, state) {\n    debug(\"onEofChunk\");\n    if (state.ended) return;\n    if (state.decoder) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    if (state.sync) {\n        emitReadable(stream);\n    } else {\n        state.needReadable = false;\n        if (!state.emittedReadable) {\n            state.emittedReadable = true;\n            emitReadable_(stream);\n        }\n    }\n}",
	"node_modules/readable-stream/lib/_stream_readable----emitReadable": "function emitReadable(stream) {\n    var state = stream._readableState;\n    debug(\"emitReadable\", state.needReadable, state.emittedReadable);\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        debug(\"emitReadable\", state.flowing);\n        state.emittedReadable = true;\n        process.nextTick(emitReadable_, stream);\n    }\n}",
	"node_modules/readable-stream/lib/_stream_readable----emitReadable_": "function emitReadable_(stream) {\n    var state = stream._readableState;\n    debug(\"emitReadable_\", state.destroyed, state.length, state.ended);\n    if (!state.destroyed && (state.length || state.ended)) {\n        stream.emit(\"readable\");\n        state.emittedReadable = false;\n    }\n    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n    flow(stream);\n}",
	"node_modules/readable-stream/lib/_stream_readable----cleanup": "function cleanup() {\n    debug(\"cleanup\");\n    dest.removeListener(\"close\", onclose);\n    dest.removeListener(\"finish\", onfinish);\n    dest.removeListener(\"drain\", ondrain);\n    dest.removeListener(\"error\", onerror);\n    dest.removeListener(\"unpipe\", onunpipe);\n    src.removeListener(\"end\", onend);\n    src.removeListener(\"end\", unpipe);\n    src.removeListener(\"data\", ondata);\n    cleanedUp = true;\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n}",
	"node_modules/readable-stream/lib/_stream_readable----ondata": "function ondata(chunk) {\n    debug(\"ondata\");\n    var ret = dest.write(chunk);\n    debug(\"dest.write\", ret);\n    if (ret === false) {\n        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n            debug(\"false write response, pause\", state.awaitDrain);\n            state.awaitDrain++;\n        }\n        src.pause();\n    }\n}",
	"node_modules/readable-stream/lib/_stream_readable----onerror": "function onerror(er) {\n    debug(\"onerror\", er);\n    unpipe();\n    dest.removeListener(\"error\", onerror);\n    if (EElistenerCount(dest, \"error\") === 0) errorOrDestroy(dest, er);\n}",
	"node_modules/readable-stream/lib/_stream_readable----resume_": "function resume_(stream, state) {\n    debug(\"resume\", state.reading);\n    if (!state.reading) {\n        stream.read(0);\n    }\n    state.resumeScheduled = false;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}",
	"node_modules/readable-stream/lib/_stream_readable----fromList": "function fromList(n, state) {\n    if (state.length === 0) return null;\n    var ret;\n    if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\"); else if (state.buffer.length === 1) ret = state.buffer.first(); else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n    } else {\n        ret = state.buffer.consume(n, state.decoder);\n    }\n    return ret;\n}",
	"node_modules/readable-stream/lib/_stream_transform----afterTransform": "function afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (cb === null) {\n        return this.emit(\"error\", new ERR_MULTIPLE_CALLBACK());\n    }\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null) this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        this._read(rs.highWaterMark);\n    }\n}",
	"node_modules/readable-stream/lib/_stream_transform----Transform": "function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n        afterTransform: afterTransform.bind(this),\n        needTransform: false,\n        transforming: false,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n    };\n    this._readableState.needReadable = true;\n    this._readableState.sync = false;\n    if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    this.on(\"prefinish\", prefinish);\n}",
	"node_modules/readable-stream/lib/_stream_transform----done": "function done(stream, er, data) {\n    if (er) return stream.emit(\"error\", er);\n    if (data != null) stream.push(data);\n    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n    return stream.push(null);\n}",
	"node_modules/readable-stream/lib/_stream_writable----WriteReq": "function WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n    this.next = null;\n}",
	"node_modules/readable-stream/lib/_stream_writable----CorkedRequest": "function CorkedRequest(state) {\n    var _this = this;\n    this.next = null;\n    this.entry = null;\n    this.finish = function() {\n        onCorkedFinish(_this, state);\n    };\n}",
	"node_modules/readable-stream/lib/_stream_writable----WritableState": "function WritableState(options, stream, isDuplex) {\n    Duplex = Duplex || require(\"./_stream_duplex\");\n    options = options || {};\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    this.highWaterMark = getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex);\n    this.finalCalled = false;\n    this.needDrain = false;\n    this.ending = false;\n    this.ended = false;\n    this.finished = false;\n    this.destroyed = false;\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.length = 0;\n    this.writing = false;\n    this.corked = 0;\n    this.sync = true;\n    this.bufferProcessing = false;\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    this.writecb = null;\n    this.writelen = 0;\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n    this.pendingcb = 0;\n    this.prefinished = false;\n    this.errorEmitted = false;\n    this.emitClose = options.emitClose !== false;\n    this.autoDestroy = !!options.autoDestroy;\n    this.bufferedRequestCount = 0;\n    this.corkedRequestsFree = new CorkedRequest(this);\n}",
	"node_modules/readable-stream/lib/_stream_writable----Writable": "function Writable(options) {\n    Duplex = Duplex || require(\"./_stream_duplex\");\n    var isDuplex = this instanceof Duplex;\n    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n    this._writableState = new WritableState(options, this, isDuplex);\n    this.writable = true;\n    if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n    }\n    Stream.call(this);\n}",
	"node_modules/readable-stream/lib/_stream_writable----validChunk": "function validChunk(stream, state, chunk, cb) {\n    var er;\n    if (chunk === null) {\n        er = new ERR_STREAM_NULL_VALUES();\n    } else if (typeof chunk !== \"string\" && !state.objectMode) {\n        er = new ERR_INVALID_ARG_TYPE(\"chunk\", [ \"string\", \"Buffer\" ], chunk);\n    }\n    if (er) {\n        errorOrDestroy(stream, er);\n        process.nextTick(cb, er);\n        return false;\n    }\n    return true;\n}",
	"node_modules/readable-stream/lib/_stream_writable----writeOrBuffer": "function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n    if (!isBuf) {\n        var newChunk = decodeChunk(state, chunk, encoding);\n        if (chunk !== newChunk) {\n            isBuf = true;\n            encoding = \"buffer\";\n            chunk = newChunk;\n        }\n    }\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked) {\n        var last = state.lastBufferedRequest;\n        state.lastBufferedRequest = {\n            chunk: chunk,\n            encoding: encoding,\n            isBuf: isBuf,\n            callback: cb,\n            next: null\n        };\n        if (last) {\n            last.next = state.lastBufferedRequest;\n        } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n        }\n        state.bufferedRequestCount += 1;\n    } else {\n        doWrite(stream, state, false, len, chunk, encoding, cb);\n    }\n    return ret;\n}",
	"node_modules/readable-stream/lib/_stream_writable----doWrite": "function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\")); else if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}",
	"node_modules/readable-stream/lib/_stream_writable----onwriteStateUpdate": "function onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}",
	"node_modules/readable-stream/lib/_stream_writable----onwrite": "function onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    if (typeof cb !== \"function\") throw new ERR_MULTIPLE_CALLBACK();\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb); else {\n        var finished = needFinish(state) || stream.destroyed;\n        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            process.nextTick(afterWrite, stream, state, finished, cb);\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}",
	"node_modules/readable-stream/lib/_stream_writable----afterWrite": "function afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}",
	"node_modules/readable-stream/lib/_stream_writable----clearBuffer": "function clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    var entry = state.bufferedRequest;\n    if (stream._writev && entry && entry.next) {\n        var l = state.bufferedRequestCount;\n        var buffer = new Array(l);\n        var holder = state.corkedRequestsFree;\n        holder.entry = entry;\n        var count = 0;\n        var allBuffers = true;\n        while (entry) {\n            buffer[count] = entry;\n            if (!entry.isBuf) allBuffers = false;\n            entry = entry.next;\n            count += 1;\n        }\n        buffer.allBuffers = allBuffers;\n        doWrite(stream, state, true, state.length, buffer, \"\", holder.finish);\n        state.pendingcb++;\n        state.lastBufferedRequest = null;\n        if (holder.next) {\n            state.corkedRequestsFree = holder.next;\n            holder.next = null;\n        } else {\n            state.corkedRequestsFree = new CorkedRequest(state);\n        }\n        state.bufferedRequestCount = 0;\n    } else {\n        while (entry) {\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            state.bufferedRequestCount--;\n            if (state.writing) {\n                break;\n            }\n        }\n        if (entry === null) state.lastBufferedRequest = null;\n    }\n    state.bufferedRequest = entry;\n    state.bufferProcessing = false;\n}",
	"node_modules/readable-stream/lib/_stream_writable----endWritable": "function endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) process.nextTick(cb); else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n    stream.writable = false;\n}",
	"node_modules/readable-stream/lib/_stream_writable----onCorkedFinish": "function onCorkedFinish(corkReq, state, err) {\n    var entry = corkReq.entry;\n    corkReq.entry = null;\n    while (entry) {\n        var cb = entry.callback;\n        state.pendingcb--;\n        cb(err);\n        entry = entry.next;\n    }\n    state.corkedRequestsFree.next = corkReq;\n}",
	"node_modules/sax/lib/sax----checkBufferLength": "function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n        var len = parser[buffers[i]].length;\n        if (len > maxAllowed) {\n            switch (buffers[i]) {\n              case \"textNode\":\n                closeText(parser);\n                break;\n\n              case \"cdata\":\n                emitNode(parser, \"oncdata\", parser.cdata);\n                parser.cdata = \"\";\n                break;\n\n              case \"script\":\n                emitNode(parser, \"onscript\", parser.script);\n                parser.script = \"\";\n                break;\n\n              default:\n                error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n            }\n        }\n        maxActual = Math.max(maxActual, len);\n    }\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n}",
	"node_modules/sax/lib/sax----SAXStream": "function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n        return new SAXStream(strict, opt);\n    }\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n    this._parser.onend = function() {\n        me.emit(\"end\");\n    };\n    this._parser.onerror = function(er) {\n        me.emit(\"error\", er);\n        me._parser.error = null;\n    };\n    this._decoder = null;\n    streamWraps.forEach(function(ev) {\n        Object.defineProperty(me, \"on\" + ev, {\n            get: function() {\n                return me._parser[\"on\" + ev];\n            },\n            set: function(h) {\n                if (!h) {\n                    me.removeAllListeners(ev);\n                    me._parser[\"on\" + ev] = h;\n                    return h;\n                }\n                me.on(ev, h);\n            },\n            enumerable: true,\n            configurable: false\n        });\n    });\n}",
	"node_modules/sax/lib/sax----error": "function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n        er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n}",
	"node_modules/sax/lib/sax----end": "function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n        error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n}",
	"node_modules/sax/lib/sax----newTag": "function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = parser.tag = {\n        name: parser.tagName,\n        attributes: {}\n    };\n    if (parser.opt.xmlns) {\n        tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n}",
	"node_modules/sax/lib/sax----qname": "function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [ \"\", name ] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n    if (attribute && name === \"xmlns\") {\n        prefix = \"xmlns\";\n        local = \"\";\n    }\n    return {\n        prefix: prefix,\n        local: local\n    };\n}",
	"node_modules/sax/lib/sax----attrib": "function attrib(parser) {\n    if (!parser.strict) {\n        parser.attribName = parser.attribName[parser.looseCase]();\n    }\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n        parser.attribName = parser.attribValue = \"\";\n        return;\n    }\n    if (parser.opt.xmlns) {\n        var qn = qname(parser.attribName, true);\n        var prefix = qn.prefix;\n        var local = qn.local;\n        if (prefix === \"xmlns\") {\n            if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n                strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n            } else {\n                var tag = parser.tag;\n                var parent = parser.tags[parser.tags.length - 1] || parser;\n                if (tag.ns === parent.ns) {\n                    tag.ns = Object.create(parent.ns);\n                }\n                tag.ns[local] = parser.attribValue;\n            }\n        }\n        parser.attribList.push([ parser.attribName, parser.attribValue ]);\n    } else {\n        parser.tag.attributes[parser.attribName] = parser.attribValue;\n        emitNode(parser, \"onattribute\", {\n            name: parser.attribName,\n            value: parser.attribValue\n        });\n    }\n    parser.attribName = parser.attribValue = \"\";\n}",
	"node_modules/sax/lib/sax----openTag": "function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n        var tag = parser.tag;\n        var qn = qname(parser.tagName);\n        tag.prefix = qn.prefix;\n        tag.local = qn.local;\n        tag.uri = tag.ns[qn.prefix] || \"\";\n        if (tag.prefix && !tag.uri) {\n            strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n            tag.uri = qn.prefix;\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (tag.ns && parent.ns !== tag.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                emitNode(parser, \"onopennamespace\", {\n                    prefix: p,\n                    uri: tag.ns[p]\n                });\n            });\n        }\n        for (var i = 0, l = parser.attribList.length; i < l; i++) {\n            var nv = parser.attribList[i];\n            var name = nv[0];\n            var value = nv[1];\n            var qualName = qname(name, true);\n            var prefix = qualName.prefix;\n            var local = qualName.local;\n            var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n            var a = {\n                name: name,\n                value: value,\n                prefix: prefix,\n                local: local,\n                uri: uri\n            };\n            if (prefix && prefix !== \"xmlns\" && !uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                a.uri = prefix;\n            }\n            parser.tag.attributes[name] = a;\n            emitNode(parser, \"onattribute\", a);\n        }\n        parser.attribList.length = 0;\n    }\n    parser.tag.isSelfClosing = !!selfClosing;\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n        if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n            parser.state = S.SCRIPT;\n        } else {\n            parser.state = S.TEXT;\n        }\n        parser.tag = null;\n        parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n}",
	"node_modules/sax/lib/sax----closeTag": "function closeTag(parser) {\n    if (!parser.tagName) {\n        strictFail(parser, \"Weird empty close tag.\");\n        parser.textNode += \"</>\";\n        parser.state = S.TEXT;\n        return;\n    }\n    if (parser.script) {\n        if (parser.tagName !== \"script\") {\n            parser.script += \"</\" + parser.tagName + \">\";\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n            return;\n        }\n        emitNode(parser, \"onscript\", parser.script);\n        parser.script = \"\";\n    }\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n        tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n        var close = parser.tags[t];\n        if (close.name !== closeTo) {\n            strictFail(parser, \"Unexpected close tag\");\n        } else {\n            break;\n        }\n    }\n    if (t < 0) {\n        strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n        parser.textNode += \"</\" + parser.tagName + \">\";\n        parser.state = S.TEXT;\n        return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n        var tag = parser.tag = parser.tags.pop();\n        parser.tagName = parser.tag.name;\n        emitNode(parser, \"onclosetag\", parser.tagName);\n        var x = {};\n        for (var i in tag.ns) {\n            x[i] = tag.ns[i];\n        }\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        if (parser.opt.xmlns && tag.ns !== parent.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n                var n = tag.ns[p];\n                emitNode(parser, \"onclosenamespace\", {\n                    prefix: p,\n                    uri: n\n                });\n            });\n        }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n}",
	"node_modules/sax/lib/sax----parseEntity": "function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n    if (parser.ENTITIES[entity]) {\n        return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n        return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n        if (entity.charAt(1) === \"x\") {\n            entity = entity.slice(2);\n            num = parseInt(entity, 16);\n            numStr = num.toString(16);\n        } else {\n            entity = entity.slice(1);\n            num = parseInt(entity, 10);\n            numStr = num.toString(10);\n        }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (numStr.toLowerCase() !== entity) {\n        strictFail(parser, \"Invalid character entity\");\n        return \"&\" + parser.entity + \";\";\n    }\n    return String.fromCodePoint(num);\n}",
	"node_modules/sax/lib/sax----write": "function write(chunk) {\n    var parser = this;\n    if (this.error) {\n        throw this.error;\n    }\n    if (parser.closed) {\n        return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    }\n    if (chunk === null) {\n        return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n        chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n        c = charAt(chunk, i++);\n        parser.c = c;\n        if (!c) {\n            break;\n        }\n        if (parser.trackPosition) {\n            parser.position++;\n            if (c === \"\\n\") {\n                parser.line++;\n                parser.column = 0;\n            } else {\n                parser.column++;\n            }\n        }\n        switch (parser.state) {\n          case S.BEGIN:\n            parser.state = S.BEGIN_WHITESPACE;\n            if (c === \"\\ufeff\") {\n                continue;\n            }\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.BEGIN_WHITESPACE:\n            beginWhiteSpace(parser, c);\n            continue;\n\n          case S.TEXT:\n            if (parser.sawRoot && !parser.closedRoot) {\n                var starti = i - 1;\n                while (c && c !== \"<\" && c !== \"&\") {\n                    c = charAt(chunk, i++);\n                    if (c && parser.trackPosition) {\n                        parser.position++;\n                        if (c === \"\\n\") {\n                            parser.line++;\n                            parser.column = 0;\n                        } else {\n                            parser.column++;\n                        }\n                    }\n                }\n                parser.textNode += chunk.substring(starti, i - 1);\n            }\n            if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n            } else {\n                if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n                    strictFail(parser, \"Text data outside of root node.\");\n                }\n                if (c === \"&\") {\n                    parser.state = S.TEXT_ENTITY;\n                } else {\n                    parser.textNode += c;\n                }\n            }\n            continue;\n\n          case S.SCRIPT:\n            if (c === \"<\") {\n                parser.state = S.SCRIPT_ENDING;\n            } else {\n                parser.script += c;\n            }\n            continue;\n\n          case S.SCRIPT_ENDING:\n            if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n            } else {\n                parser.script += \"<\" + c;\n                parser.state = S.SCRIPT;\n            }\n            continue;\n\n          case S.OPEN_WAKA:\n            if (c === \"!\") {\n                parser.state = S.SGML_DECL;\n                parser.sgmlDecl = \"\";\n            } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {\n                parser.state = S.OPEN_TAG;\n                parser.tagName = c;\n            } else if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n                parser.tagName = \"\";\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST;\n                parser.procInstName = parser.procInstBody = \"\";\n            } else {\n                strictFail(parser, \"Unencoded <\");\n                if (parser.startTagPosition + 1 < parser.position) {\n                    var pad = parser.position - parser.startTagPosition;\n                    c = new Array(pad).join(\" \") + c;\n                }\n                parser.textNode += \"<\" + c;\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.SGML_DECL:\n            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                emitNode(parser, \"onopencdata\");\n                parser.state = S.CDATA;\n                parser.sgmlDecl = \"\";\n                parser.cdata = \"\";\n            } else if (parser.sgmlDecl + c === \"--\") {\n                parser.state = S.COMMENT;\n                parser.comment = \"\";\n                parser.sgmlDecl = \"\";\n            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                parser.state = S.DOCTYPE;\n                if (parser.doctype || parser.sawRoot) {\n                    strictFail(parser, \"Inappropriately located doctype declaration\");\n                }\n                parser.doctype = \"\";\n                parser.sgmlDecl = \"\";\n            } else if (c === \">\") {\n                emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                parser.sgmlDecl = \"\";\n                parser.state = S.TEXT;\n            } else if (is(quote, c)) {\n                parser.state = S.SGML_DECL_QUOTED;\n                parser.sgmlDecl += c;\n            } else {\n                parser.sgmlDecl += c;\n            }\n            continue;\n\n          case S.SGML_DECL_QUOTED:\n            if (c === parser.q) {\n                parser.state = S.SGML_DECL;\n                parser.q = \"\";\n            }\n            parser.sgmlDecl += c;\n            continue;\n\n          case S.DOCTYPE:\n            if (c === \">\") {\n                parser.state = S.TEXT;\n                emitNode(parser, \"ondoctype\", parser.doctype);\n                parser.doctype = true;\n            } else {\n                parser.doctype += c;\n                if (c === \"[\") {\n                    parser.state = S.DOCTYPE_DTD;\n                } else if (is(quote, c)) {\n                    parser.state = S.DOCTYPE_QUOTED;\n                    parser.q = c;\n                }\n            }\n            continue;\n\n          case S.DOCTYPE_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.q = \"\";\n                parser.state = S.DOCTYPE;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD:\n            parser.doctype += c;\n            if (c === \"]\") {\n                parser.state = S.DOCTYPE;\n            } else if (is(quote, c)) {\n                parser.state = S.DOCTYPE_DTD_QUOTED;\n                parser.q = c;\n            }\n            continue;\n\n          case S.DOCTYPE_DTD_QUOTED:\n            parser.doctype += c;\n            if (c === parser.q) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.q = \"\";\n            }\n            continue;\n\n          case S.COMMENT:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDING;\n            } else {\n                parser.comment += c;\n            }\n            continue;\n\n          case S.COMMENT_ENDING:\n            if (c === \"-\") {\n                parser.state = S.COMMENT_ENDED;\n                parser.comment = textopts(parser.opt, parser.comment);\n                if (parser.comment) {\n                    emitNode(parser, \"oncomment\", parser.comment);\n                }\n                parser.comment = \"\";\n            } else {\n                parser.comment += \"-\" + c;\n                parser.state = S.COMMENT;\n            }\n            continue;\n\n          case S.COMMENT_ENDED:\n            if (c !== \">\") {\n                strictFail(parser, \"Malformed comment\");\n                parser.comment += \"--\" + c;\n                parser.state = S.COMMENT;\n            } else {\n                parser.state = S.TEXT;\n            }\n            continue;\n\n          case S.CDATA:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING;\n            } else {\n                parser.cdata += c;\n            }\n            continue;\n\n          case S.CDATA_ENDING:\n            if (c === \"]\") {\n                parser.state = S.CDATA_ENDING_2;\n            } else {\n                parser.cdata += \"]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.CDATA_ENDING_2:\n            if (c === \">\") {\n                if (parser.cdata) {\n                    emitNode(parser, \"oncdata\", parser.cdata);\n                }\n                emitNode(parser, \"onclosecdata\");\n                parser.cdata = \"\";\n                parser.state = S.TEXT;\n            } else if (c === \"]\") {\n                parser.cdata += \"]\";\n            } else {\n                parser.cdata += \"]]\" + c;\n                parser.state = S.CDATA;\n            }\n            continue;\n\n          case S.PROC_INST:\n            if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else if (is(whitespace, c)) {\n                parser.state = S.PROC_INST_BODY;\n            } else {\n                parser.procInstName += c;\n            }\n            continue;\n\n          case S.PROC_INST_BODY:\n            if (!parser.procInstBody && is(whitespace, c)) {\n                continue;\n            } else if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n            } else {\n                parser.procInstBody += c;\n            }\n            continue;\n\n          case S.PROC_INST_ENDING:\n            if (c === \">\") {\n                emitNode(parser, \"onprocessinginstruction\", {\n                    name: parser.procInstName,\n                    body: parser.procInstBody\n                });\n                parser.procInstName = parser.procInstBody = \"\";\n                parser.state = S.TEXT;\n            } else {\n                parser.procInstBody += \"?\" + c;\n                parser.state = S.PROC_INST_BODY;\n            }\n            continue;\n\n          case S.OPEN_TAG:\n            if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else {\n                newTag(parser);\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (c === \"/\") {\n                    parser.state = S.OPEN_TAG_SLASH;\n                } else {\n                    if (not(whitespace, c)) {\n                        strictFail(parser, \"Invalid character in tag name\");\n                    }\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.OPEN_TAG_SLASH:\n            if (c === \">\") {\n                openTag(parser, true);\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.ATTRIB:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (c === \">\") {\n                strictFail(parser, \"Attribute without value\");\n                parser.attribValue = parser.attribName;\n                attrib(parser);\n                openTag(parser);\n            } else if (is(whitespace, c)) {\n                parser.state = S.ATTRIB_NAME_SAW_WHITE;\n            } else if (is(nameBody, c)) {\n                parser.attribName += c;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_NAME_SAW_WHITE:\n            if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n            } else if (is(whitespace, c)) {\n                continue;\n            } else {\n                strictFail(parser, \"Attribute without value\");\n                parser.tag.attributes[parser.attribName] = \"\";\n                parser.attribValue = \"\";\n                emitNode(parser, \"onattribute\", {\n                    name: parser.attribName,\n                    value: \"\"\n                });\n                parser.attribName = \"\";\n                if (c === \">\") {\n                    openTag(parser);\n                } else if (is(nameStart, c)) {\n                    parser.attribName = c;\n                    parser.state = S.ATTRIB_NAME;\n                } else {\n                    strictFail(parser, \"Invalid attribute name\");\n                    parser.state = S.ATTRIB;\n                }\n            }\n            continue;\n\n          case S.ATTRIB_VALUE:\n            if (is(whitespace, c)) {\n                continue;\n            } else if (is(quote, c)) {\n                parser.q = c;\n                parser.state = S.ATTRIB_VALUE_QUOTED;\n            } else {\n                strictFail(parser, \"Unquoted attribute value\");\n                parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                parser.attribValue = c;\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_QUOTED:\n            if (c !== parser.q) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            parser.q = \"\";\n            parser.state = S.ATTRIB_VALUE_CLOSED;\n            continue;\n\n          case S.ATTRIB_VALUE_CLOSED:\n            if (is(whitespace, c)) {\n                parser.state = S.ATTRIB;\n            } else if (c === \">\") {\n                openTag(parser);\n            } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n            } else if (is(nameStart, c)) {\n                strictFail(parser, \"No whitespace between attributes\");\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n            } else {\n                strictFail(parser, \"Invalid attribute name\");\n            }\n            continue;\n\n          case S.ATTRIB_VALUE_UNQUOTED:\n            if (not(attribEnd, c)) {\n                if (c === \"&\") {\n                    parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                } else {\n                    parser.attribValue += c;\n                }\n                continue;\n            }\n            attrib(parser);\n            if (c === \">\") {\n                openTag(parser);\n            } else {\n                parser.state = S.ATTRIB;\n            }\n            continue;\n\n          case S.CLOSE_TAG:\n            if (!parser.tagName) {\n                if (is(whitespace, c)) {\n                    continue;\n                } else if (not(nameStart, c)) {\n                    if (parser.script) {\n                        parser.script += \"</\" + c;\n                        parser.state = S.SCRIPT;\n                    } else {\n                        strictFail(parser, \"Invalid tagname in closing tag.\");\n                    }\n                } else {\n                    parser.tagName = c;\n                }\n            } else if (c === \">\") {\n                closeTag(parser);\n            } else if (is(nameBody, c)) {\n                parser.tagName += c;\n            } else if (parser.script) {\n                parser.script += \"</\" + parser.tagName;\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n            } else {\n                if (not(whitespace, c)) {\n                    strictFail(parser, \"Invalid tagname in closing tag\");\n                }\n                parser.state = S.CLOSE_TAG_SAW_WHITE;\n            }\n            continue;\n\n          case S.CLOSE_TAG_SAW_WHITE:\n            if (is(whitespace, c)) {\n                continue;\n            }\n            if (c === \">\") {\n                closeTag(parser);\n            } else {\n                strictFail(parser, \"Invalid characters in closing tag\");\n            }\n            continue;\n\n          case S.TEXT_ENTITY:\n          case S.ATTRIB_VALUE_ENTITY_Q:\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState;\n            var buffer;\n            switch (parser.state) {\n              case S.TEXT_ENTITY:\n                returnState = S.TEXT;\n                buffer = \"textNode\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_Q:\n                returnState = S.ATTRIB_VALUE_QUOTED;\n                buffer = \"attribValue\";\n                break;\n\n              case S.ATTRIB_VALUE_ENTITY_U:\n                returnState = S.ATTRIB_VALUE_UNQUOTED;\n                buffer = \"attribValue\";\n                break;\n            }\n            if (c === \";\") {\n                parser[buffer] += parseEntity(parser);\n                parser.entity = \"\";\n                parser.state = returnState;\n            } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n                parser.entity += c;\n            } else {\n                strictFail(parser, \"Invalid character in entity name\");\n                parser[buffer] += \"&\" + parser.entity + c;\n                parser.entity = \"\";\n                parser.state = returnState;\n            }\n            continue;\n\n          default:\n            throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n    }\n    if (parser.position >= parser.bufferCheckPosition) {\n        checkBufferLength(parser);\n    }\n    return parser;\n}",
	"node_modules/sharp/lib/channel----extractChannel": "function extractChannel(channel) {\n    const channelMap = {\n        red: 0,\n        green: 1,\n        blue: 2,\n        alpha: 3\n    };\n    if (Object.keys(channelMap).includes(channel)) {\n        channel = channelMap[channel];\n    }\n    if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n        this.options.extractChannel = channel;\n    } else {\n        throw is.invalidParameterError(\"channel\", \"integer or one of: red, green, blue, alpha\", channel);\n    }\n    return this.toColourspace(\"b-w\");\n}",
	"node_modules/sharp/lib/colour----tint": "function tint(rgb) {\n    const colour = color(rgb);\n    this.options.tintA = colour.a();\n    this.options.tintB = colour.b();\n    return this;\n}",
	"node_modules/sharp/lib/constructor----clone": "function clone() {\n    const clone = this.constructor.call();\n    clone.options = Object.assign({}, this.options);\n    if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n            this._flattenBufferIn();\n            clone.options.bufferIn = this.options.bufferIn;\n            clone.emit(\"finish\");\n        });\n    }\n    return clone;\n}",
	"node_modules/sharp/lib/output----toFile": "function toFile(fileOut, callback) {\n    let err;\n    if (!is.string(fileOut)) {\n        err = new Error(\"Missing output file path\");\n    } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n        err = new Error(\"Cannot use same file for input and output\");\n    }\n    if (err) {\n        if (is.fn(callback)) {\n            callback(err);\n        } else {\n            return Promise.reject(err);\n        }\n    } else {\n        this.options.fileOut = fileOut;\n        return this._pipeline(callback);\n    }\n    return this;\n}",
	"node_modules/sharp/lib/operation----affine": "function affine(matrix, options) {\n    const flatMatrix = [].concat(...matrix);\n    if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n        this.options.affineMatrix = flatMatrix;\n    } else {\n        throw is.invalidParameterError(\"matrix\", \"1x4 or 2x2 array\", matrix);\n    }\n    if (is.defined(options)) {\n        if (is.object(options)) {\n            this._setBackgroundColourOption(\"affineBackground\", options.background);\n            if (is.defined(options.idx)) {\n                if (is.number(options.idx)) {\n                    this.options.affineIdx = options.idx;\n                } else {\n                    throw is.invalidParameterError(\"options.idx\", \"number\", options.idx);\n                }\n            }\n            if (is.defined(options.idy)) {\n                if (is.number(options.idy)) {\n                    this.options.affineIdy = options.idy;\n                } else {\n                    throw is.invalidParameterError(\"options.idy\", \"number\", options.idy);\n                }\n            }\n            if (is.defined(options.odx)) {\n                if (is.number(options.odx)) {\n                    this.options.affineOdx = options.odx;\n                } else {\n                    throw is.invalidParameterError(\"options.odx\", \"number\", options.odx);\n                }\n            }\n            if (is.defined(options.ody)) {\n                if (is.number(options.ody)) {\n                    this.options.affineOdy = options.ody;\n                } else {\n                    throw is.invalidParameterError(\"options.ody\", \"number\", options.ody);\n                }\n            }\n            if (is.defined(options.interpolator)) {\n                if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n                    this.options.affineInterpolator = options.interpolator;\n                } else {\n                    throw is.invalidParameterError(\"options.interpolator\", \"valid interpolator name\", options.interpolator);\n                }\n            }\n        } else {\n            throw is.invalidParameterError(\"options\", \"object\", options);\n        }\n    }\n    return this;\n}",
	"node_modules/sharp/lib/operation----clahe": "function clahe(options) {\n    if (!is.plainObject(options)) {\n        throw is.invalidParameterError(\"options\", \"plain object\", options);\n    }\n    if (!(\"width\" in options) || !is.integer(options.width) || options.width <= 0) {\n        throw is.invalidParameterError(\"width\", \"integer above zero\", options.width);\n    } else {\n        this.options.claheWidth = options.width;\n    }\n    if (!(\"height\" in options) || !is.integer(options.height) || options.height <= 0) {\n        throw is.invalidParameterError(\"height\", \"integer above zero\", options.height);\n    } else {\n        this.options.claheHeight = options.height;\n    }\n    if (!is.defined(options.maxSlope)) {\n        this.options.claheMaxSlope = 3;\n    } else if (!is.integer(options.maxSlope) || options.maxSlope < 0 || options.maxSlope > 100) {\n        throw is.invalidParameterError(\"maxSlope\", \"integer 0-100\", options.maxSlope);\n    } else {\n        this.options.claheMaxSlope = options.maxSlope;\n    }\n    return this;\n}",
	"node_modules/sharp/lib/operation----convolve": "function convolve(kernel) {\n    if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {\n        throw new Error(\"Invalid convolution kernel\");\n    }\n    if (!is.integer(kernel.scale)) {\n        kernel.scale = kernel.kernel.reduce(function(a, b) {\n            return a + b;\n        }, 0);\n    }\n    if (kernel.scale < 1) {\n        kernel.scale = 1;\n    }\n    if (!is.integer(kernel.offset)) {\n        kernel.offset = 0;\n    }\n    this.options.convKernel = kernel;\n    return this;\n}",
	"node_modules/sharp/lib/operation----modulate": "function modulate(options) {\n    if (!is.plainObject(options)) {\n        throw is.invalidParameterError(\"options\", \"plain object\", options);\n    }\n    if (\"brightness\" in options) {\n        if (is.number(options.brightness) && options.brightness >= 0) {\n            this.options.brightness = options.brightness;\n        } else {\n            throw is.invalidParameterError(\"brightness\", \"number above zero\", options.brightness);\n        }\n    }\n    if (\"saturation\" in options) {\n        if (is.number(options.saturation) && options.saturation >= 0) {\n            this.options.saturation = options.saturation;\n        } else {\n            throw is.invalidParameterError(\"saturation\", \"number above zero\", options.saturation);\n        }\n    }\n    if (\"hue\" in options) {\n        if (is.integer(options.hue)) {\n            this.options.hue = options.hue % 360;\n        } else {\n            throw is.invalidParameterError(\"hue\", \"number\", options.hue);\n        }\n    }\n    if (\"lightness\" in options) {\n        if (is.number(options.lightness)) {\n            this.options.lightness = options.lightness;\n        } else {\n            throw is.invalidParameterError(\"lightness\", \"number\", options.lightness);\n        }\n    }\n    return this;\n}",
	"node_modules/sharp/lib/resize----extract": "function extract(options) {\n    const suffix = this.options.width === -1 && this.options.height === -1 ? \"Pre\" : \"Post\";\n    [ \"left\", \"top\", \"width\", \"height\" ].forEach(function(name) {\n        const value = options[name];\n        if (is.integer(value) && value >= 0) {\n            this.options[name + (name === \"left\" || name === \"top\" ? \"Offset\" : \"\") + suffix] = value;\n        } else {\n            throw is.invalidParameterError(name, \"integer\", value);\n        }\n    }, this);\n    if (suffix === \"Pre\" && isRotationExpected(this.options)) {\n        this.options.rotateBeforePreExtract = true;\n    }\n    return this;\n}",
	"node_modules/string_decoder/lib/string_decoder----StringDecoder": "function StringDecoder(encoding) {\n    this.encoding = normalizeEncoding(encoding);\n    var nb;\n    switch (this.encoding) {\n      case \"utf16le\":\n        this.text = utf16Text;\n        this.end = utf16End;\n        nb = 4;\n        break;\n\n      case \"utf8\":\n        this.fillLast = utf8FillLast;\n        nb = 4;\n        break;\n\n      case \"base64\":\n        this.text = base64Text;\n        this.end = base64End;\n        nb = 3;\n        break;\n\n      default:\n        this.write = simpleWrite;\n        this.end = simpleEnd;\n        return;\n    }\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = Buffer.allocUnsafe(nb);\n}",
	"node_modules/string_decoder/lib/string_decoder----utf8CheckIncomplete": "function utf8CheckIncomplete(self, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 1;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 2;\n        return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n        if (nb > 0) {\n            if (nb === 2) nb = 0; else self.lastNeed = nb - 3;\n        }\n        return nb;\n    }\n    return 0;\n}",
	"node_modules/string_decoder/lib/string_decoder----utf8FillLast": "function utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = utf8CheckExtraBytes(this, buf, p);\n    if (r !== undefined) return r;\n    if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, p, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n}",
	"node_modules/string_decoder/lib/string_decoder----utf8Text": "function utf8Text(buf, i) {\n    var total = utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString(\"utf8\", i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString(\"utf8\", i, end);\n}",
	"node_modules/string_decoder/lib/string_decoder----utf16Text": "function utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n        var r = buf.toString(\"utf16le\", i);\n        if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 55296 && c <= 56319) {\n                this.lastNeed = 2;\n                this.lastTotal = 4;\n                this.lastChar[0] = buf[buf.length - 2];\n                this.lastChar[1] = buf[buf.length - 1];\n                return r.slice(0, -1);\n            }\n        }\n        return r;\n    }\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString(\"utf16le\", i, buf.length - 1);\n}",
	"node_modules/string_decoder/lib/string_decoder----base64Text": "function base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString(\"base64\", i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n    if (n === 1) {\n        this.lastChar[0] = buf[buf.length - 1];\n    } else {\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n    }\n    return buf.toString(\"base64\", i, buf.length - n);\n}",
	"node_modules/uuid/dist/md5-browser----md5ToHexEncodedArray": "function md5ToHexEncodedArray(input) {\n    var i;\n    var x;\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    var hex;\n    for (i = 0; i < length32; i += 8) {\n        x = input[i >> 5] >>> i % 32 & 255;\n        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n        output.push(hex);\n    }\n    return output;\n}",
	"node_modules/uuid/dist/md5-browser----wordsToMd5": "function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var i;\n    var olda;\n    var oldb;\n    var oldc;\n    var oldd;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [ a, b, c, d ];\n}",
	"node_modules/uuid/dist/md5-browser----bytesToWords": "function bytesToWords(input) {\n    var i;\n    var output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    var length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n}",
	"node_modules/uuid/dist/sha1-browser----sha1": "function sha1(bytes) {\n    var K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof bytes == \"string\") {\n        var msg = unescape(encodeURIComponent(bytes));\n        bytes = new Array(msg.length);\n        for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {\n            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n        }\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var i = 0; i < N; i++) {\n        var W = new Array(80);\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 80; t++) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        var a = H[0];\n        var b = H[1];\n        var c = H[2];\n        var d = H[3];\n        var e = H[4];\n        for (var t = 0; t < 80; t++) {\n            var s = Math.floor(t / 20);\n            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = H[0] + a >>> 0;\n        H[1] = H[1] + b >>> 0;\n        H[2] = H[2] + c >>> 0;\n        H[3] = H[3] + d >>> 0;\n        H[4] = H[4] + e >>> 0;\n    }\n    return [ H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255 ];\n}",
	"node_modules/uuid/dist/uuid-bin----usage": "function usage() {\n    console.log(\"Usage:\");\n    console.log(\"  uuid\");\n    console.log(\"  uuid v1\");\n    console.log(\"  uuid v3 <name> <namespace uuid>\");\n    console.log(\"  uuid v4\");\n    console.log(\"  uuid v5 <name> <namespace uuid>\");\n    console.log(\"  uuid --help\");\n    console.log('\\nNote: <namespace uuid> may be \"URL\" or \"DNS\" to use the corresponding UUIDs defined by RFC4122');\n}",
	"node_modules/uuid/dist/v1----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || _rng.default)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : (0, _bytesToUuid.default)(b);\n}",
	"node_modules/uuid/dist/v35----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/uuid/dist/v35----_default": "function _default(name, version, hashfunc) {\n    var generateUUID = function(value, namespace, buf, offset) {\n        var off = buf && offset || 0;\n        if (typeof value == \"string\") value = stringToBytes(value);\n        if (typeof namespace == \"string\") namespace = uuidToBytes(namespace);\n        if (!Array.isArray(value)) throw TypeError(\"value must be an array of bytes\");\n        if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError(\"namespace must be uuid string or an Array of 16 byte values\");\n        var bytes = hashfunc(namespace.concat(value));\n        bytes[6] = bytes[6] & 15 | version;\n        bytes[8] = bytes[8] & 63 | 128;\n        if (buf) {\n            for (var idx = 0; idx < 16; ++idx) {\n                buf[off + idx] = bytes[idx];\n            }\n        }\n        return buf || (0, _bytesToUuid.default)(bytes);\n    };\n    try {\n        generateUUID.name = name;\n    } catch (err) {}\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n}",
	"node_modules/uuid/dist/v4----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || _rng.default)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || (0, _bytesToUuid.default)(rnds);\n}",
	"node_modules/xml2js/lib/builder----Builder": "function Builder(opts) {\n    var key, ref, value;\n    this.options = {};\n    ref = defaults[\"0.2\"];\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n    }\n    for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLAttribute----XMLAttribute": "function XMLAttribute(parent, name, value) {\n    this.options = parent.options;\n    this.stringify = parent.stringify;\n    if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n    }\n    if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n    }\n    this.name = this.stringify.attName(name);\n    this.value = this.stringify.attValue(value);\n}",
	"node_modules/xmlbuilder/lib/XMLDTDAttList----XMLDTDAttList": "function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n    XMLDTDAttList.__super__.constructor.call(this, parent);\n    if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n    }\n    if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n    }\n    if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n    }\n    if (defaultValueType.indexOf(\"#\") !== 0) {\n        defaultValueType = \"#\" + defaultValueType;\n    }\n    if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n    }\n    if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n    }\n    this.elementName = this.stringify.eleName(elementName);\n    this.attributeName = this.stringify.attName(attributeName);\n    this.attributeType = this.stringify.dtdAttType(attributeType);\n    this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n    this.defaultValueType = defaultValueType;\n}",
	"node_modules/xmlbuilder/lib/XMLDTDElement----XMLDTDElement": "function XMLDTDElement(parent, name, value) {\n    XMLDTDElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n    }\n    if (!value) {\n        value = \"(#PCDATA)\";\n    }\n    if (Array.isArray(value)) {\n        value = \"(\" + value.join(\",\") + \")\";\n    }\n    this.name = this.stringify.eleName(name);\n    this.value = this.stringify.dtdElementValue(value);\n}",
	"node_modules/xmlbuilder/lib/XMLDTDEntity----XMLDTDEntity": "function XMLDTDEntity(parent, pe, name, value) {\n    XMLDTDEntity.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing entity name\");\n    }\n    if (value == null) {\n        throw new Error(\"Missing entity value\");\n    }\n    this.pe = !!pe;\n    this.name = this.stringify.eleName(name);\n    if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n    } else {\n        if (!value.pubID && !value.sysID) {\n            throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n            throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n            this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n            this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n            this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n            throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLDTDNotation----XMLDTDNotation": "function XMLDTDNotation(parent, name, value) {\n    XMLDTDNotation.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing notation name\");\n    }\n    if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n    }\n    this.name = this.stringify.eleName(name);\n    if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n    }\n    if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLDeclaration----XMLDeclaration": "function XMLDeclaration(parent, version, encoding, standalone) {\n    var ref;\n    XMLDeclaration.__super__.constructor.call(this, parent);\n    if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n    }\n    if (!version) {\n        version = \"1.0\";\n    }\n    this.version = this.stringify.xmlVersion(version);\n    if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n    }\n    if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLDocType----XMLDocType": "function XMLDocType(parent, pubID, sysID) {\n    var ref, ref1;\n    XMLDocType.__super__.constructor.call(this, parent);\n    this.documentObject = parent;\n    if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n    }\n    if (sysID == null) {\n        ref1 = [ pubID, sysID ], sysID = ref1[0], pubID = ref1[1];\n    }\n    if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n    }\n    if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLDocument----XMLDocument": "function XMLDocument(options) {\n    XMLDocument.__super__.constructor.call(this, null);\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter();\n    }\n    this.options = options;\n    this.stringify = new XMLStringifier(options);\n    this.isDocument = true;\n}",
	"node_modules/xmlbuilder/lib/XMLDocumentCB----XMLDocumentCB": "function XMLDocumentCB(options, onData, onEnd) {\n    var writerOptions;\n    options || (options = {});\n    if (!options.writer) {\n        options.writer = new XMLStringWriter(options);\n    } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter(writerOptions);\n    }\n    this.options = options;\n    this.writer = options.writer;\n    this.stringify = new XMLStringifier(options);\n    this.onDataCallback = onData || function() {};\n    this.onEndCallback = onEnd || function() {};\n    this.currentNode = null;\n    this.currentLevel = -1;\n    this.openTags = {};\n    this.documentStarted = false;\n    this.documentCompleted = false;\n    this.root = null;\n}",
	"node_modules/xmlbuilder/lib/XMLElement----XMLElement": "function XMLElement(parent, name, attributes) {\n    XMLElement.__super__.constructor.call(this, parent);\n    if (name == null) {\n        throw new Error(\"Missing element name\");\n    }\n    this.name = this.stringify.eleName(name);\n    this.attributes = {};\n    if (attributes != null) {\n        this.attribute(attributes);\n    }\n    if (parent.isDocument) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLNode----XMLNode": "function XMLNode(parent) {\n    this.parent = parent;\n    if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n    }\n    this.children = [];\n    if (!XMLElement) {\n        XMLElement = require(\"./XMLElement\");\n        XMLCData = require(\"./XMLCData\");\n        XMLComment = require(\"./XMLComment\");\n        XMLDeclaration = require(\"./XMLDeclaration\");\n        XMLDocType = require(\"./XMLDocType\");\n        XMLRaw = require(\"./XMLRaw\");\n        XMLText = require(\"./XMLText\");\n        XMLProcessingInstruction = require(\"./XMLProcessingInstruction\");\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLProcessingInstruction----XMLProcessingInstruction": "function XMLProcessingInstruction(parent, target, value) {\n    XMLProcessingInstruction.__super__.constructor.call(this, parent);\n    if (target == null) {\n        throw new Error(\"Missing instruction target\");\n    }\n    this.target = this.stringify.insTarget(target);\n    if (value) {\n        this.value = this.stringify.insValue(value);\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLStringifier----XMLStringifier": "function XMLStringifier(options) {\n    this.assertLegalChar = bind(this.assertLegalChar, this);\n    var key, ref, value;\n    options || (options = {});\n    this.noDoubleEncoding = options.noDoubleEncoding;\n    ref = options.stringify || {};\n    for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n    }\n}",
	"node_modules/xmlbuilder/lib/XMLWriterBase----XMLWriterBase": "function XMLWriterBase(options) {\n    var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;\n    options || (options = {});\n    this.pretty = options.pretty || false;\n    this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;\n    if (this.pretty) {\n        this.indent = (ref1 = options.indent) != null ? ref1 : \"  \";\n        this.newline = (ref2 = options.newline) != null ? ref2 : \"\\n\";\n        this.offset = (ref3 = options.offset) != null ? ref3 : 0;\n        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;\n    } else {\n        this.indent = \"\";\n        this.newline = \"\";\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n    }\n    this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : \"\";\n    if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = \" \";\n    }\n    this.newlinedefault = this.newline;\n    this.prettydefault = this.pretty;\n    ref6 = options.writer || {};\n    for (key in ref6) {\n        if (!hasProp.call(ref6, key)) continue;\n        value = ref6[key];\n        this[key] = value;\n    }\n}",
	"node_modules/aws-sdk/lib/dynamodb/converter----formatSet": "function formatSet(data, options) {\n    options = options || {};\n    var values = data.values;\n    if (options.convertEmptyValues) {\n        values = filterEmptySetValues(data);\n        if (values.length === 0) {\n            return AWS.DynamoDB.Converter.input(null);\n        }\n    }\n    var map = {};\n    switch (data.type) {\n      case \"String\":\n        map[\"SS\"] = values;\n        break;\n\n      case \"Binary\":\n        map[\"BS\"] = values;\n        break;\n\n      case \"Number\":\n        map[\"NS\"] = values.map(function(value) {\n            return value.toString();\n        });\n    }\n    return map;\n}",
	"node_modules/aws-sdk/lib/dynamodb/converter----filterEmptySetValues": "function filterEmptySetValues(set) {\n    var nonEmptyValues = [];\n    var potentiallyEmptyTypes = {\n        String: true,\n        Binary: true,\n        Number: false\n    };\n    if (potentiallyEmptyTypes[set.type]) {\n        for (var i = 0; i < set.values.length; i++) {\n            if (set.values[i].length === 0) {\n                continue;\n            }\n            nonEmptyValues.push(set.values[i]);\n        }\n        return nonEmptyValues;\n    }\n    return set.values;\n}",
	"node_modules/aws-sdk/lib/dynamodb/types----isBinary": "function isBinary(data) {\n    var types = [ \"Buffer\", \"File\", \"Blob\", \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\" ];\n    if (util.isNode()) {\n        var Stream = util.stream.Stream;\n        if (util.Buffer.isBuffer(data) || data instanceof Stream) {\n            return true;\n        }\n    }\n    for (var i = 0; i < types.length; i++) {\n        if (data !== undefined && data.constructor) {\n            if (util.isType(data, types[i])) return true;\n            if (util.typeName(data.constructor) === types[i]) return true;\n        }\n    }\n    return false;\n}",
	"node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream----createEventStream": "function createEventStream(body, parser, model) {\n    var eventMessages = eventMessageChunker(body);\n    var events = [];\n    for (var i = 0; i < eventMessages.length; i++) {\n        events.push(parseEvent(parser, eventMessages[i], model));\n    }\n    return events;\n}",
	"node_modules/aws-sdk/lib/event-stream/build-message----buildMessage": "function buildMessage(message) {\n    var formattedHeaders = buildHeaders(message.headers);\n    var headerLengthBytes = allocBuffer(4);\n    headerLengthBytes.writeUInt32BE(formattedHeaders.length, 0);\n    var totalLengthBytes = allocBuffer(4);\n    totalLengthBytes.writeUInt32BE(totalLengthBytes.length + headerLengthBytes.length + 4 + formattedHeaders.length + message.body.length + 4, 0);\n    var prelude = Buffer.concat([ totalLengthBytes, headerLengthBytes ], totalLengthBytes.length + headerLengthBytes.length);\n    var preludeCrc32 = crc32(prelude);\n    var totalSansCrc32 = Buffer.concat([ prelude, preludeCrc32, formattedHeaders, message.body ], prelude.length + preludeCrc32.length + formattedHeaders.length + message.body.length);\n    var totalCrc32 = crc32(totalSansCrc32);\n    return Buffer.concat([ totalSansCrc32, totalCrc32 ]);\n}",
	"node_modules/aws-sdk/lib/event-stream/build-message----buildHeaders": "function buildHeaders(headers) {\n    var chunks = [];\n    var totalSize = 0;\n    var headerNames = Object.keys(headers);\n    for (var i = 0; i < headerNames.length; i++) {\n        var headerName = headerNames[i];\n        var bytes = toBuffer(headerName);\n        var headerValue = buildHeaderValue(headers[headerName]);\n        var nameLength = allocBuffer(1);\n        nameLength[0] = headerName.length;\n        chunks.push(nameLength, bytes, headerValue);\n        totalSize += nameLength.length + bytes.length + headerValue.length;\n    }\n    var out = allocBuffer(totalSize);\n    var position = 0;\n    for (var j = 0; j < chunks.length; j++) {\n        var chunk = chunks[j];\n        for (var k = 0; k < chunk.length; k++) {\n            out[position] = chunk[k];\n            position++;\n        }\n    }\n    return out;\n}",
	"node_modules/aws-sdk/lib/event-stream/build-message----crc32": "function crc32(buffer) {\n    var crc32 = crypto.crc32(buffer);\n    var crc32Buffer = allocBuffer(4);\n    crc32Buffer.writeUInt32BE(crc32, 0);\n    return crc32Buffer;\n}",
	"node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream----EventMessageChunkerStream": "function EventMessageChunkerStream(options) {\n    Transform.call(this, options);\n    this.currentMessageTotalLength = 0;\n    this.currentMessagePendingLength = 0;\n    this.currentMessage = null;\n    this.messageLengthBuffer = null;\n}",
	"node_modules/aws-sdk/lib/event-stream/event-message-chunker----eventMessageChunker": "function eventMessageChunker(buffer) {\n    var messages = [];\n    var offset = 0;\n    while (offset < buffer.length) {\n        var totalLength = buffer.readInt32BE(offset);\n        var message = buffer.slice(offset, totalLength + offset);\n        offset += totalLength;\n        messages.push(message);\n    }\n    return messages;\n}",
	"node_modules/aws-sdk/lib/event-stream/event-message-unmarshaller-stream----EventUnmarshallerStream": "function EventUnmarshallerStream(options) {\n    options = options || {};\n    options.readableObjectMode = true;\n    Transform.call(this, options);\n    this._readableState.objectMode = true;\n    this.parser = options.parser;\n    this.eventStreamModel = options.eventStreamModel;\n}",
	"node_modules/aws-sdk/lib/event-stream/parse-event----parseEvent": "function parseEvent(parser, message, shape) {\n    var parsedMessage = parseMessage(message);\n    var messageType = parsedMessage.headers[\":message-type\"];\n    if (messageType) {\n        if (messageType.value === \"error\") {\n            throw parseError(parsedMessage);\n        } else if (messageType.value !== \"event\") {\n            return;\n        }\n    }\n    var eventType = parsedMessage.headers[\":event-type\"];\n    var eventModel = shape.members[eventType.value];\n    if (!eventModel) {\n        return;\n    }\n    var result = {};\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n    if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName];\n        if (payloadShape.type === \"binary\") {\n            result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n    }\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\n    for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n        if (parsedMessage.headers[name]) {\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n    }\n    var output = {};\n    output[eventType.value] = result;\n    return output;\n}",
	"node_modules/aws-sdk/lib/event-stream/parse-event----parseError": "function parseError(message) {\n    var errorCode = message.headers[\":error-code\"];\n    var errorMessage = message.headers[\":error-message\"];\n    var error = new Error(errorMessage.value || errorMessage);\n    error.code = error.name = errorCode.value || errorCode;\n    return error;\n}",
	"node_modules/aws-sdk/lib/event-stream/parse-message----parseHeaders": "function parseHeaders(headers) {\n    var out = {};\n    var position = 0;\n    while (position < headers.length) {\n        var nameLength = headers.readUInt8(position++);\n        var name = headers.slice(position, position + nameLength).toString();\n        position += nameLength;\n        switch (headers.readUInt8(position++)) {\n          case 0:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: true\n            };\n            break;\n\n          case 1:\n            out[name] = {\n                type: BOOLEAN_TAG,\n                value: false\n            };\n            break;\n\n          case 2:\n            out[name] = {\n                type: BYTE_TAG,\n                value: headers.readInt8(position++)\n            };\n            break;\n\n          case 3:\n            out[name] = {\n                type: SHORT_TAG,\n                value: headers.readInt16BE(position)\n            };\n            position += 2;\n            break;\n\n          case 4:\n            out[name] = {\n                type: INT_TAG,\n                value: headers.readInt32BE(position)\n            };\n            position += 4;\n            break;\n\n          case 5:\n            out[name] = {\n                type: LONG_TAG,\n                value: new Int64(headers.slice(position, position + 8))\n            };\n            position += 8;\n            break;\n\n          case 6:\n            var binaryLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: BINARY_TAG,\n                value: headers.slice(position, position + binaryLength)\n            };\n            position += binaryLength;\n            break;\n\n          case 7:\n            var stringLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n                type: STRING_TAG,\n                value: headers.slice(position, position + stringLength).toString()\n            };\n            position += stringLength;\n            break;\n\n          case 8:\n            out[name] = {\n                type: TIMESTAMP_TAG,\n                value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())\n            };\n            position += 8;\n            break;\n\n          case 9:\n            var uuidChars = headers.slice(position, position + 16).toString(\"hex\");\n            position += 16;\n            out[name] = {\n                type: UUID_TAG,\n                value: uuidChars.substr(0, 8) + \"-\" + uuidChars.substr(8, 4) + \"-\" + uuidChars.substr(12, 4) + \"-\" + uuidChars.substr(16, 4) + \"-\" + uuidChars.substr(20)\n            };\n            break;\n\n          default:\n            throw new Error(\"Unrecognized header type tag\");\n        }\n    }\n    return out;\n}",
	"node_modules/aws-sdk/lib/event-stream/split-message----splitMessage": "function splitMessage(message) {\n    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\n    if (message.length < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    if (message.length !== message.readUInt32BE(0)) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\n    if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {\n        throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum.\");\n    }\n    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\n    if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {\n        throw new Error(\"The message checksum did not match the expected value of \" + expectedMessageChecksum);\n    }\n    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\n    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\n    return {\n        headers: message.slice(headersStart, headersEnd),\n        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)\n    };\n}",
	"node_modules/aws-sdk/lib/event-stream/streaming-create-event-stream----createEventStream": "function createEventStream(stream, parser, model) {\n    var eventStream = new EventUnmarshallerStream({\n        parser: parser,\n        eventStreamModel: model\n    });\n    var eventMessageChunker = new EventMessageChunkerStream();\n    stream.pipe(eventMessageChunker).pipe(eventStream);\n    stream.on(\"error\", function(err) {\n        eventMessageChunker.emit(\"error\", err);\n    });\n    eventMessageChunker.on(\"error\", function(err) {\n        eventStream.emit(\"error\", err);\n    });\n    return eventStream;\n}",
	"node_modules/aws-sdk/lib/json/builder----translateStructure": "function translateStructure(structure, shape) {\n    if (shape.isDocument) {\n        return structure;\n    }\n    var struct = {};\n    util.each(structure, function(name, value) {\n        var memberShape = shape.members[name];\n        if (memberShape) {\n            if (memberShape.location !== \"body\") return;\n            var locationName = memberShape.isLocationName ? memberShape.name : name;\n            var result = translate(value, memberShape);\n            if (result !== undefined) struct[locationName] = result;\n        }\n    });\n    return struct;\n}",
	"node_modules/aws-sdk/lib/json/parser----translateStructure": "function translateStructure(structure, shape) {\n    if (structure == null) return undefined;\n    if (shape.isDocument) return structure;\n    var struct = {};\n    var shapeMembers = shape.members;\n    util.each(shapeMembers, function(name, memberShape) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n            var value = structure[locationName];\n            var result = translate(value, memberShape);\n            if (result !== undefined) struct[name] = result;\n        }\n    });\n    return struct;\n}",
	"node_modules/aws-sdk/lib/json/parser----translateList": "function translateList(list, shape) {\n    if (list == null) return undefined;\n    var out = [];\n    util.arrayEach(list, function(value) {\n        var result = translate(value, shape.member);\n        if (result === undefined) out.push(null); else out.push(result);\n    });\n    return out;\n}",
	"node_modules/aws-sdk/lib/json/parser----translateMap": "function translateMap(map, shape) {\n    if (map == null) return undefined;\n    var out = {};\n    util.each(map, function(key, value) {\n        var result = translate(value, shape.value);\n        if (result === undefined) out[key] = null; else out[key] = result;\n    });\n    return out;\n}",
	"node_modules/aws-sdk/lib/model/paginator----Paginator": "function Paginator(name, paginator) {\n    property(this, \"inputToken\", paginator.input_token);\n    property(this, \"limitKey\", paginator.limit_key);\n    property(this, \"moreResults\", paginator.more_results);\n    property(this, \"outputToken\", paginator.output_token);\n    property(this, \"resultKey\", paginator.result_key);\n}",
	"node_modules/aws-sdk/lib/model/resource_waiter----ResourceWaiter": "function ResourceWaiter(name, waiter, options) {\n    options = options || {};\n    property(this, \"name\", name);\n    property(this, \"api\", options.api, false);\n    if (waiter.operation) {\n        property(this, \"operation\", util.string.lowerFirst(waiter.operation));\n    }\n    var self = this;\n    var keys = [ \"type\", \"description\", \"delay\", \"maxAttempts\", \"acceptors\" ];\n    keys.forEach(function(key) {\n        var value = waiter[key];\n        if (value) {\n            property(self, key, value);\n        }\n    });\n}",
	"node_modules/aws-sdk/lib/model/shape----ListShape": "function ListShape(shape, options) {\n    var self = this, firstInit = !this.isShape;\n    CompositeShape.apply(this, arguments);\n    if (firstInit) {\n        property(this, \"defaultValue\", function() {\n            return [];\n        });\n    }\n    if (shape.member) {\n        memoizedProperty(this, \"member\", function() {\n            return Shape.create(shape.member, options);\n        });\n    }\n    if (this.flattened) {\n        var oldName = this.name;\n        memoizedProperty(this, \"name\", function() {\n            return self.member.name || oldName;\n        });\n    }\n}",
	"node_modules/aws-sdk/lib/model/shape----TimestampShape": "function TimestampShape(shape) {\n    var self = this;\n    Shape.apply(this, arguments);\n    if (shape.timestampFormat) {\n        property(this, \"timestampFormat\", shape.timestampFormat);\n    } else if (self.isTimestampFormatSet && this.timestampFormat) {\n        property(this, \"timestampFormat\", this.timestampFormat);\n    } else if (this.location === \"header\") {\n        property(this, \"timestampFormat\", \"rfc822\");\n    } else if (this.location === \"querystring\") {\n        property(this, \"timestampFormat\", \"iso8601\");\n    } else if (this.api) {\n        switch (this.api.protocol) {\n          case \"json\":\n          case \"rest-json\":\n            property(this, \"timestampFormat\", \"unixTimestamp\");\n            break;\n\n          case \"rest-xml\":\n          case \"query\":\n          case \"ec2\":\n            property(this, \"timestampFormat\", \"iso8601\");\n            break;\n        }\n    }\n    this.toType = function(value) {\n        if (value === null || value === undefined) return null;\n        if (typeof value.toUTCString === \"function\") return value;\n        return typeof value === \"string\" || typeof value === \"number\" ? util.date.parseTimestamp(value) : null;\n    };\n    this.toWireFormat = function(value) {\n        return util.date.format(value, self.timestampFormat);\n    };\n}",
	"node_modules/aws-sdk/lib/protocol/json----buildRequest": "function buildRequest(req) {\n    var httpRequest = req.httpRequest;\n    var api = req.service.api;\n    var target = api.targetPrefix + \".\" + api.operations[req.operation].name;\n    var version = api.jsonVersion || \"1.0\";\n    var input = api.operations[req.operation].input;\n    var builder = new JsonBuilder();\n    if (version === 1) version = \"1.0\";\n    httpRequest.body = builder.build(req.params || {}, input);\n    httpRequest.headers[\"Content-Type\"] = \"application/x-amz-json-\" + version;\n    httpRequest.headers[\"X-Amz-Target\"] = target;\n    populateHostPrefix(req);\n}",
	"node_modules/aws-sdk/lib/protocol/json----extractError": "function extractError(resp) {\n    var error = {};\n    var httpResponse = resp.httpResponse;\n    error.code = httpResponse.headers[\"x-amzn-errortype\"] || \"UnknownError\";\n    if (typeof error.code === \"string\") {\n        error.code = error.code.split(\":\")[0];\n    }\n    if (httpResponse.body.length > 0) {\n        try {\n            var e = JSON.parse(httpResponse.body.toString());\n            var code = e.__type || e.code || e.Code;\n            if (code) {\n                error.code = code.split(\"#\").pop();\n            }\n            if (error.code === \"RequestEntityTooLarge\") {\n                error.message = \"Request body must be less than 1 MB\";\n            } else {\n                error.message = e.message || e.Message || null;\n            }\n        } catch (e) {\n            error.statusCode = httpResponse.statusCode;\n            error.message = httpResponse.statusMessage;\n        }\n    } else {\n        error.statusCode = httpResponse.statusCode;\n        error.message = httpResponse.statusCode.toString();\n    }\n    resp.error = util.error(new Error(), error);\n}",
	"node_modules/aws-sdk/lib/protocol/query----buildRequest": "function buildRequest(req) {\n    var operation = req.service.api.operations[req.operation];\n    var httpRequest = req.httpRequest;\n    httpRequest.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded; charset=utf-8\";\n    httpRequest.params = {\n        Version: req.service.api.apiVersion,\n        Action: operation.name\n    };\n    var builder = new QueryParamSerializer();\n    builder.serialize(req.params, operation.input, function(name, value) {\n        httpRequest.params[name] = value;\n    });\n    httpRequest.body = util.queryParamsToString(httpRequest.params);\n    populateHostPrefix(req);\n}",
	"node_modules/aws-sdk/lib/protocol/query----extractError": "function extractError(resp) {\n    var data, body = resp.httpResponse.body.toString();\n    if (body.match(\"<UnknownOperationException\")) {\n        data = {\n            Code: \"UnknownOperation\",\n            Message: \"Unknown operation \" + resp.request.operation\n        };\n    } else {\n        try {\n            data = new AWS.XML.Parser().parse(body);\n        } catch (e) {\n            data = {\n                Code: resp.httpResponse.statusCode,\n                Message: resp.httpResponse.statusMessage\n            };\n        }\n    }\n    if (data.requestId && !resp.requestId) resp.requestId = data.requestId;\n    if (data.Errors) data = data.Errors;\n    if (data.Error) data = data.Error;\n    if (data.Code) {\n        resp.error = util.error(new Error(), {\n            code: data.Code,\n            message: data.Message\n        });\n    } else {\n        resp.error = util.error(new Error(), {\n            code: resp.httpResponse.statusCode,\n            message: null\n        });\n    }\n}",
	"node_modules/aws-sdk/lib/protocol/query----extractData": "function extractData(resp) {\n    var req = resp.request;\n    var operation = req.service.api.operations[req.operation];\n    var shape = operation.output || {};\n    var origRules = shape;\n    if (origRules.resultWrapper) {\n        var tmp = Shape.create({\n            type: \"structure\"\n        });\n        tmp.members[origRules.resultWrapper] = shape;\n        tmp.memberNames = [ origRules.resultWrapper ];\n        util.property(shape, \"name\", shape.resultWrapper);\n        shape = tmp;\n    }\n    var parser = new AWS.XML.Parser();\n    if (shape && shape.members && !shape.members._XAMZRequestId) {\n        var requestIdShape = Shape.create({\n            type: \"string\"\n        }, {\n            api: {\n                protocol: \"query\"\n            }\n        }, \"requestId\");\n        shape.members._XAMZRequestId = requestIdShape;\n    }\n    var data = parser.parse(resp.httpResponse.body.toString(), shape);\n    resp.requestId = data._XAMZRequestId || data.requestId;\n    if (data._XAMZRequestId) delete data._XAMZRequestId;\n    if (origRules.resultWrapper) {\n        if (data[origRules.resultWrapper]) {\n            util.update(data, data[origRules.resultWrapper]);\n            delete data[origRules.resultWrapper];\n        }\n    }\n    resp.data = data;\n}",
	"node_modules/aws-sdk/lib/protocol/rest_json----extractData": "function extractData(resp) {\n    Rest.extractData(resp);\n    var req = resp.request;\n    var operation = req.service.api.operations[req.operation];\n    var rules = req.service.api.operations[req.operation].output || {};\n    var parser;\n    var hasEventOutput = operation.hasEventOutput;\n    if (rules.payload) {\n        var payloadMember = rules.members[rules.payload];\n        var body = resp.httpResponse.body;\n        if (payloadMember.isEventStream) {\n            parser = new JsonParser();\n            resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body, parser, payloadMember);\n        } else if (payloadMember.type === \"structure\" || payloadMember.type === \"list\") {\n            var parser = new JsonParser();\n            resp.data[rules.payload] = parser.parse(body, payloadMember);\n        } else if (payloadMember.type === \"binary\" || payloadMember.isStreaming) {\n            resp.data[rules.payload] = body;\n        } else {\n            resp.data[rules.payload] = payloadMember.toType(body);\n        }\n    } else {\n        var data = resp.data;\n        Json.extractData(resp);\n        resp.data = util.merge(data, resp.data);\n    }\n}",
	"node_modules/aws-sdk/lib/protocol/rest_xml----populateBody": "function populateBody(req) {\n    var input = req.service.api.operations[req.operation].input;\n    var builder = new AWS.XML.Builder();\n    var params = req.params;\n    var payload = input.payload;\n    if (payload) {\n        var payloadMember = input.members[payload];\n        params = params[payload];\n        if (params === undefined) return;\n        if (payloadMember.type === \"structure\") {\n            var rootElement = payloadMember.name;\n            req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n        } else {\n            req.httpRequest.body = params;\n        }\n    } else {\n        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + \"Request\");\n    }\n}",
	"node_modules/aws-sdk/lib/signers/presign----signedUrlBuilder": "function signedUrlBuilder(request) {\n    var expires = request.httpRequest.headers[expiresHeader];\n    var signerClass = request.service.getSignerClass(request);\n    delete request.httpRequest.headers[\"User-Agent\"];\n    delete request.httpRequest.headers[\"X-Amz-User-Agent\"];\n    if (signerClass === AWS.Signers.V4) {\n        if (expires > 604800) {\n            var message = \"Presigning does not support expiry time greater \" + \"than a week with SigV4 signing.\";\n            throw AWS.util.error(new Error(), {\n                code: \"InvalidExpiryTime\",\n                message: message,\n                retryable: false\n            });\n        }\n        request.httpRequest.headers[expiresHeader] = expires;\n    } else if (signerClass === AWS.Signers.S3) {\n        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();\n        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();\n    } else {\n        throw AWS.util.error(new Error(), {\n            message: \"Presigning only supports S3 or SigV4 signing.\",\n            code: \"UnsupportedSigner\",\n            retryable: false\n        });\n    }\n}",
	"node_modules/aws-sdk/lib/signers/presign----signedUrlSigner": "function signedUrlSigner(request) {\n    var endpoint = request.httpRequest.endpoint;\n    var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n    var queryParams = {};\n    if (parsedUrl.search) {\n        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n    }\n    var auth = request.httpRequest.headers[\"Authorization\"].split(\" \");\n    if (auth[0] === \"AWS\") {\n        auth = auth[1].split(\":\");\n        queryParams[\"Signature\"] = auth.pop();\n        queryParams[\"AWSAccessKeyId\"] = auth.join(\":\");\n        AWS.util.each(request.httpRequest.headers, function(key, value) {\n            if (key === expiresHeader) key = \"Expires\";\n            if (key.indexOf(\"x-amz-meta-\") === 0) {\n                delete queryParams[key];\n                key = key.toLowerCase();\n            }\n            queryParams[key] = value;\n        });\n        delete request.httpRequest.headers[expiresHeader];\n        delete queryParams[\"Authorization\"];\n        delete queryParams[\"Host\"];\n    } else if (auth[0] === \"AWS4-HMAC-SHA256\") {\n        auth.shift();\n        var rest = auth.join(\" \");\n        var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n        queryParams[\"X-Amz-Signature\"] = signature;\n        delete queryParams[\"Expires\"];\n    }\n    endpoint.pathname = parsedUrl.pathname;\n    endpoint.search = AWS.util.queryParamsToString(queryParams);\n}",
	"node_modules/aws-sdk/lib/token/token_provider_chain----resolveNext": "function resolveNext(err, token) {\n    if (!err && token || index === providers.length) {\n        AWS.util.arrayEach(self.resolveCallbacks, function(callback) {\n            callback(err, token);\n        });\n        self.resolveCallbacks.length = 0;\n        return;\n    }\n    var provider = providers[index++];\n    if (typeof provider === \"function\") {\n        token = provider.call();\n    } else {\n        token = provider;\n    }\n    if (token.get) {\n        token.get(function(getErr) {\n            resolveNext(getErr, getErr ? null : token);\n        });\n    } else {\n        resolveNext(null, token);\n    }\n}",
	"node_modules/aws-sdk/lib/xml/browser_parser----parseStructure": "function parseStructure(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    util.each(shape.members, function(memberName, memberShape) {\n        if (memberShape.isXmlAttribute) {\n            if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n                var value = xml.attributes[memberShape.name].value;\n                data[memberName] = parseXml({\n                    textContent: value\n                }, memberShape);\n            }\n        } else {\n            var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);\n            if (xmlChild) {\n                data[memberName] = parseXml(xmlChild, memberShape);\n            } else if (!memberShape.flattened && memberShape.type === \"list\" && !shape.api.xmlNoDefaultLists) {\n                data[memberName] = memberShape.defaultValue;\n            }\n        }\n    });\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/browser_parser----parseMap": "function parseMap(xml, shape) {\n    var data = {};\n    var xmlKey = shape.key.name || \"key\";\n    var xmlValue = shape.value.name || \"value\";\n    var tagName = shape.flattened ? shape.name : \"entry\";\n    var child = xml.firstElementChild;\n    while (child) {\n        if (child.nodeName === tagName) {\n            var key = getElementByTagName(child, xmlKey).textContent;\n            var value = getElementByTagName(child, xmlValue);\n            data[key] = parseXml(value, shape.value);\n        }\n        child = child.nextElementSibling;\n    }\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/browser_parser----parseList": "function parseList(xml, shape) {\n    var data = [];\n    var tagName = shape.flattened ? shape.name : shape.member.name || \"member\";\n    var child = xml.firstElementChild;\n    while (child) {\n        if (child.nodeName === tagName) {\n            data.push(parseXml(child, shape.member));\n        }\n        child = child.nextElementSibling;\n    }\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/browser_parser----parseScalar": "function parseScalar(xml, shape) {\n    if (xml.getAttribute) {\n        var encoding = xml.getAttribute(\"encoding\");\n        if (encoding === \"base64\") {\n            shape = new Shape.create({\n                type: encoding\n            });\n        }\n    }\n    var text = xml.textContent;\n    if (text === \"\") text = null;\n    if (typeof shape.toType === \"function\") {\n        return shape.toType(text);\n    } else {\n        return text;\n    }\n}",
	"node_modules/aws-sdk/lib/xml/browser_parser----parseUnknown": "function parseUnknown(xml) {\n    if (xml === undefined || xml === null) return \"\";\n    if (!xml.firstElementChild) {\n        if (xml.parentNode.parentNode === null) return {};\n        if (xml.childNodes.length === 0) return \"\"; else return xml.textContent;\n    }\n    var shape = {\n        type: \"structure\",\n        members: {}\n    };\n    var child = xml.firstElementChild;\n    while (child) {\n        var tag = child.nodeName;\n        if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n            shape.members[tag].type = \"list\";\n        } else {\n            shape.members[tag] = {\n                name: tag\n            };\n        }\n        child = child.nextElementSibling;\n    }\n    return parseStructure(xml, shape);\n}",
	"node_modules/aws-sdk/lib/xml/node_parser----parseStructure": "function parseStructure(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    util.each(shape.members, function(memberName, memberShape) {\n        var xmlName = memberShape.name;\n        if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {\n            var xmlChild = xml[xmlName];\n            if (!memberShape.flattened) xmlChild = xmlChild[0];\n            data[memberName] = parseXml(xmlChild, memberShape);\n        } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {\n            data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n        } else if (memberShape.type === \"list\" && !shape.api.xmlNoDefaultLists) {\n            data[memberName] = memberShape.defaultValue;\n        }\n    });\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/node_parser----parseMap": "function parseMap(xml, shape) {\n    var data = {};\n    if (xml === null) return data;\n    var xmlKey = shape.key.name || \"key\";\n    var xmlValue = shape.value.name || \"value\";\n    var iterable = shape.flattened ? xml : xml.entry;\n    if (Array.isArray(iterable)) {\n        util.arrayEach(iterable, function(child) {\n            data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n        });\n    }\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/node_parser----parseList": "function parseList(xml, shape) {\n    var data = [];\n    var name = shape.member.name || \"member\";\n    if (shape.flattened) {\n        util.arrayEach(xml, function(xmlChild) {\n            data.push(parseXml(xmlChild, shape.member));\n        });\n    } else if (xml && Array.isArray(xml[name])) {\n        util.arrayEach(xml[name], function(child) {\n            data.push(parseXml(child, shape.member));\n        });\n    }\n    return data;\n}",
	"node_modules/aws-sdk/lib/xml/xml-node----XmlNode": "function XmlNode(name, children) {\n    if (children === void 0) {\n        children = [];\n    }\n    this.name = name;\n    this.children = children;\n    this.attributes = {};\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----from": "function from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----alloc": "function alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----allocUnsafe": "function allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----fromString": "function fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        that = that.slice(0, actual);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----fromArrayLike": "function fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----fromArrayBuffer": "function fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength;\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----byteLength": "function byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n\n          case \"utf8\":\n          case \"utf-8\":\n          case undefined:\n            return utf8ToBytes(string).length;\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n\n          case \"hex\":\n            return len >>> 1;\n\n          case \"base64\":\n            return base64ToBytes(string).length;\n\n          default:\n            if (loweredCase) return utf8ToBytes(string).length;\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----slowToString": "function slowToString(encoding, start, end) {\n    var loweredCase = false;\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n\n          case \"base64\":\n            return base64Slice(this, start, end);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n    }\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----bidirectionalIndexOf": "function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    if (buffer.length === 0) return -1;\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (isNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1; else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0; else return -1;\n    }\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    if (Buffer.isBuffer(val)) {\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----arrayIndexOf": "function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----hexWrite": "function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----utf8Slice": "function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 128) {\n                    codePoint = firstByte;\n                }\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                        codePoint = tempCodePoint;\n                    }\n                }\n            }\n        }\n        if (codePoint === null) {\n            codePoint = 65533;\n            bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n            codePoint -= 65536;\n            res.push(codePoint >>> 10 & 1023 | 55296);\n            codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----decodeCodePointsArray": "function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----asciiSlice": "function asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----latin1Slice": "function latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----hexSlice": "function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----utf16leSlice": "function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----base64clean": "function base64clean(str) {\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2) return \"\";\n    while (str.length % 4 !== 0) {\n        str = str + \"=\";\n    }\n    return str;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----utf8ToBytes": "function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n            if (!leadSurrogate) {\n                if (codePoint > 56319) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                } else if (i + 1 === length) {\n                    if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                    continue;\n                }\n                leadSurrogate = codePoint;\n                continue;\n            }\n            if (codePoint < 56320) {\n                if ((units -= 3) > -1) bytes.push(239, 191, 189);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}",
	"node_modules/aws-sdk/node_modules/buffer/index----utf16leToBytes": "function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}",
	"node_modules/aws-sdk/scripts/changelog/change-creator----ChangeCreator": "function ChangeCreator(config) {\n    this._config = config || {};\n    this._type = \"\";\n    this._category = \"\";\n    this._description = \"\";\n}",
	"node_modules/aws-sdk/scripts/changelog/util----getLatestVersion": "function getLatestVersion() {\n    if (!changelog) readChangelog();\n    var match = changelog.match(versionMarkerReg);\n    latest = {\n        major: parseInt(match[1], 10),\n        minor: parseInt(match[2], 10),\n        patch: parseInt(match[3], 10)\n    };\n    return latest;\n}",
	"node_modules/aws-sdk/scripts/changelog/util----readChangesFromJSON": "function readChangesFromJSON(filepath) {\n    var changes = JSON.parse(fsSyncFromRoot(\"readFile\", filepath));\n    if (!Array.isArray(changes)) changes = [ changes ];\n    if (!changes.length) throw new Error(filepath + \" contains no changes\");\n    try {\n        changes.forEach(checkChangeFormat);\n    } catch (err) {\n        if (err.code === \"InvalidFormat\") {\n            err.message += \" in \" + filepath;\n        }\n        throw err;\n    }\n    return changes;\n}",
	"node_modules/aws-sdk/scripts/changelog/util----addVersionJSONToChangelog": "function addVersionJSONToChangelog(version, changes) {\n    if (!changelog) readChangelog();\n    var entry = \"\\n\\n## \" + version;\n    changes.forEach(function(change) {\n        entry += \"\\n* \" + change.type + \": \" + change.category + \": \" + change.description;\n    });\n    var logParts = changelog.split(insertMarker);\n    logParts[0] = logParts[0].replace(versionMarkerReg, versionMarker.join(version)) + insertMarker;\n    changelog = logParts.join(entry);\n}",
	"node_modules/aws-sdk/scripts/lib/get-operation-shape-names----getOperationShapeNames": "function getOperationShapeNames(model) {\n    var operationShapeNames = [];\n    var operations = model.operations;\n    for (var operationName of Object.keys(operations)) {\n        var operation = operations[operationName];\n        if (operation.input && operation.input.shape) {\n            operationShapeNames.push(operation.input.shape);\n        }\n        if (operation.output && operation.output.shape) {\n            operationShapeNames.push(operation.output.shape);\n        }\n    }\n    return operationShapeNames;\n}",
	"node_modules/aws-sdk/scripts/lib/prune-shapes----pruneShapes": "function pruneShapes(model) {\n    var operationShapeNames = getOperationShapeNames(model);\n    var shapeMap = model.shapes;\n    for (operationShape of operationShapeNames) {\n        visitRelatedShapeNames(operationShape, shapeMap);\n    }\n    var shapeNames = Object.keys(shapeMap);\n    for (var name of shapeNames) {\n        if (!shapeMap[name].visited) {\n            delete shapeMap[name];\n        }\n    }\n}",
	"node_modules/aws-sdk/scripts/lib/remove-event-stream-ops----removeEventStreamOperations": "function removeEventStreamOperations(model) {\n    var modifiedModel = false;\n    var operations = model.operations;\n    var operationNames = Object.keys(operations);\n    for (var i = 0; i < operationNames.length; i++) {\n        var operationName = operationNames[i];\n        var operation = operations[operationName];\n        var inputShapeName = operation.input && operation.input.shape;\n        var outputShapeName = operation.output && operation.output.shape;\n        var requiresEventStream = false;\n        if (inputShapeName && hasEventStream(model.shapes[inputShapeName], model)) {\n            requiresEventStream = true;\n        }\n        if (requiresEventStream) {\n            modifiedModel = true;\n            console.log(\"Removing \" + operationName + \" because it depends on event streams on input.\");\n            delete model.operations[operationName];\n        }\n    }\n    return modifiedModel;\n}",
	"node_modules/aws-sdk/scripts/lib/translator----Translator": "function Translator(api, options) {\n    var origLength = JSON.stringify(api, null, 2).length;\n    var debugInfo = {\n        flattened: {},\n        pruned: {}\n    };\n    var shapeName = \"S0\";\n    var shapeNameMap = {};\n    var visitedShapes = {};\n    function logResults() {\n        console.log(\"** Generated\", api.metadata.endpointPrefix + \"-\" + api.metadata.apiVersion + \".min.json\" + (process.env.DEBUG ? \":\" : \"\"));\n        if (process.env.DEBUG) {\n            var pruned = Object.keys(debugInfo.pruned);\n            var flattened = Object.keys(debugInfo.flattened);\n            var newLength = JSON.stringify(api, null, 2).length;\n            console.log(\"- Pruned Shapes:\", pruned.length);\n            console.log(\"- Flattened Shapes:\", flattened.length);\n            console.log(\"- Remaining Shapes:\", Object.keys(api.shapes).length);\n            console.log(\"- Original Size:\", origLength / 1024, \"kb\");\n            console.log(\"- Minified Size:\", newLength / 1024, \"kb\");\n            console.log(\"- Size Saving:\", (origLength - newLength) / 1024, \"kb\");\n            console.log(\"\");\n        }\n    }\n    function deleteTraits(obj) {\n        if (!options.documentation) {\n            delete obj.documentation;\n            delete obj.documentationUrl;\n            delete obj.errors;\n            delete obj.min;\n            delete obj.max;\n            delete obj.pattern;\n            delete obj[\"enum\"];\n            delete obj.box;\n        }\n    }\n    function trackShapeDeclaration(ref) {\n        if (ref.shape && !shapeNameMap[ref.shape]) {\n            var oldShapeName = ref.shape;\n            ref.shape = shapeName = nextString(shapeName);\n            visitedShapes[shapeName] = api.shapes[oldShapeName];\n            shapeNameMap[oldShapeName] = {\n                name: shapeName,\n                refs: [ ref ]\n            };\n            traverseShapeRef(api.shapes[oldShapeName]);\n        } else if (ref.shape && shapeNameMap[ref.shape]) {\n            var map = shapeNameMap[ref.shape];\n            map.refs.push(ref);\n            ref.shape = map.name;\n        }\n    }\n    function pruneShapes() {\n        each(shapeNameMap, function(name, map) {\n            if (Object.keys(visitedShapes[map.name]).join() === \"type\" && [ \"structure\", \"map\", \"list\" ].indexOf(visitedShapes[map.name].type) < 0) {\n                for (var i = 0; i < map.refs.length; i++) {\n                    var ref = map.refs[i];\n                    debugInfo.flattened[name] = true;\n                    delete ref.shape;\n                    ref.type = visitedShapes[map.name].type;\n                    if (ref.type === \"string\") delete ref.type;\n                }\n                delete visitedShapes[map.name];\n                debugInfo.pruned[name] = true;\n            } else if (map.refs.length === 1) {\n                var shape = visitedShapes[map.name];\n                for (var i = 0; i < map.refs.length; i++) {\n                    delete map.refs[i].shape;\n                    for (var prop in shape) {\n                        if (shape.hasOwnProperty(prop)) {\n                            if (map.refs[i].hasOwnProperty(prop) && [ \"timestampFormat\" ].indexOf(prop) >= 0) {\n                                continue;\n                            }\n                            map.refs[i][prop] = shape[prop];\n                        }\n                    }\n                }\n                delete visitedShapes[map.name];\n                debugInfo.pruned[name] = true;\n            }\n        });\n    }\n    function traverseShapeRef(ref) {\n        if (!ref) return;\n        deleteTraits(ref);\n        traverseShapeRef(ref.key);\n        traverseShapeRef(ref.value);\n        traverseShapeRef(ref.member);\n        each(ref.members || {}, function(key, value) {\n            traverseShapeRef(value);\n        });\n        trackShapeDeclaration(ref);\n    }\n    function traverseOperation(op) {\n        deleteTraits(op);\n        delete op.name;\n        if (op.http) {\n            if (op.http.method === \"POST\") delete op.http.method;\n            if (op.http.requestUri === \"/\") delete op.http.requestUri;\n            if (Object.keys(op.http).length === 0) delete op.http;\n        }\n        traverseShapeRef(op.input);\n        traverseShapeRef(op.output);\n    }\n    function traverseApi() {\n        deleteTraits(api);\n        each(api.operations, function(name, op) {\n            traverseOperation(op);\n        });\n        api.shapes = visitedShapes;\n    }\n    traverseApi();\n    pruneShapes();\n    logResults();\n    return api;\n}",
	"node_modules/aws-sdk/scripts/lib/ts-generator----TSGenerator": "function TSGenerator(options) {\n    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n    this._apiRootDir = path.join(this._sdkRootDir, \"apis\");\n    this._metadataPath = path.join(this._apiRootDir, \"metadata.json\");\n    this._clientsDir = path.join(this._sdkRootDir, \"clients\");\n    this.metadata = null;\n    this.typings = {};\n    this.streamTypes = {};\n}",
	"node_modules/aws-sdk/scripts/lib/visit-related-shape-names----visitRelatedShapeNames": "function visitRelatedShapeNames(startingShape, shapeMap) {\n    var shape = shapeMap[startingShape];\n    if (shape.visited) {\n        return;\n    }\n    shape.visited = true;\n    if ([ \"structure\", \"map\", \"list\" ].indexOf(shape.type) < 0) {\n        return;\n    }\n    if (shape.type === \"structure\") {\n        var members = shape.members;\n        for (var memberName of Object.keys(members)) {\n            var memberShapeName = members[memberName].shape;\n            visitRelatedShapeNames(memberShapeName, shapeMap);\n        }\n    } else if (shape.type === \"map\") {\n        var keyShape = shape.key.shape;\n        var valueShape = shape.value.shape;\n        visitRelatedShapeNames(keyShape, shapeMap);\n        visitRelatedShapeNames(valueShape, shapeMap);\n    } else if (shape.type === \"list\") {\n        var memberShape = shape.member.shape;\n        visitRelatedShapeNames(memberShape, shapeMap);\n    }\n}",
	"node_modules/aws-sdk/scripts/region-checker/index----checkFile": "function checkFile(location) {\n    var file = fs.readFileSync(location);\n    var code = file.toString();\n    var lines = code.split(\"\\n\");\n    var regionMatches = [];\n    lines.forEach(function(line, idx) {\n        var matches = line.match(/(us|eu|ap|sa|ca)-\\w+-\\d+/g);\n        if (matches) {\n            regionMatches.push({\n                file: location,\n                line: idx,\n                code: line\n            });\n        }\n    });\n    return regionMatches;\n}",
	"node_modules/aws-sdk/scripts/region-checker/index----recursiveGetFilesIn": "function recursiveGetFilesIn(directory, extensions) {\n    var filenames = [];\n    var keys = fs.readdirSync(directory);\n    for (var i = 0, iLen = keys.length; i < iLen; i++) {\n        var keyPath = path.join(directory, keys[i]);\n        var stats = fs.statSync(keyPath);\n        if (stats.isDirectory()) {\n            filenames = filenames.concat(recursiveGetFilesIn(keyPath, extensions));\n            continue;\n        }\n        if (extensions.indexOf(path.extname(keyPath)) >= 0) {\n            filenames.push(path.join(keyPath));\n        }\n    }\n    return filenames;\n}",
	"node_modules/aws-sdk/scripts/region-checker/index----checkForRegions": "function checkForRegions() {\n    var libPath = path.join(__dirname, \"..\", \"..\", \"lib\");\n    var filePaths = recursiveGetFilesIn(libPath, [ \".js\" ]);\n    var regionMatches = [];\n    var warnings = [];\n    filePaths.forEach(function(filePath) {\n        regionMatches = regionMatches.concat(checkFile(filePath));\n    });\n    regionMatches.forEach(function(match) {\n        var normalizedPath = match.file.substring(libPath.length);\n        if (allowlist[normalizedPath] && allowlist[normalizedPath].indexOf(match.line) >= 0) {\n            return;\n        }\n        warnings.push(\"File: \" + normalizedPath + \"\\tLine \" + match.line + \":\\t\" + match.code.trim());\n    });\n    if (warnings.length) {\n        console.error(\"Hard-coded regions detected. This should only be done if absolutely certain!\");\n        warnings.forEach(function(warning) {\n            console.error(warning);\n        });\n        process.exit(1);\n    }\n}",
	"node_modules/uuid/dist/esm-browser/md5----md5ToHexEncodedArray": "function md5ToHexEncodedArray(input) {\n    var i;\n    var x;\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    var hex;\n    for (i = 0; i < length32; i += 8) {\n        x = input[i >> 5] >>> i % 32 & 255;\n        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n        output.push(hex);\n    }\n    return output;\n}",
	"node_modules/uuid/dist/esm-browser/md5----wordsToMd5": "function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[(len + 64 >>> 9 << 4) + 14] = len;\n    var i;\n    var olda;\n    var oldb;\n    var oldc;\n    var oldd;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [ a, b, c, d ];\n}",
	"node_modules/uuid/dist/esm-browser/md5----bytesToWords": "function bytesToWords(input) {\n    var i;\n    var output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    var length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n}",
	"node_modules/uuid/dist/esm-browser/sha1----sha1": "function sha1(bytes) {\n    var K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];\n    var H = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];\n    if (typeof bytes == \"string\") {\n        var msg = unescape(encodeURIComponent(bytes));\n        bytes = new Array(msg.length);\n        for (var i = 0; i < msg.length; i++) {\n            bytes[i] = msg.charCodeAt(i);\n        }\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {\n            M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n        }\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var i = 0; i < N; i++) {\n        var W = new Array(80);\n        for (var t = 0; t < 16; t++) {\n            W[t] = M[i][t];\n        }\n        for (var t = 16; t < 80; t++) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        var a = H[0];\n        var b = H[1];\n        var c = H[2];\n        var d = H[3];\n        var e = H[4];\n        for (var t = 0; t < 80; t++) {\n            var s = Math.floor(t / 20);\n            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = H[0] + a >>> 0;\n        H[1] = H[1] + b >>> 0;\n        H[2] = H[2] + c >>> 0;\n        H[3] = H[3] + d >>> 0;\n        H[4] = H[4] + e >>> 0;\n    }\n    return [ H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255 ];\n}",
	"node_modules/uuid/dist/esm-browser/v1----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || rng)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : bytesToUuid(b);\n}",
	"node_modules/uuid/dist/esm-browser/v35----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/uuid/dist/esm-browser/v4----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || rng)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || bytesToUuid(rnds);\n}",
	"node_modules/uuid/dist/esm-node/v1----v1": "function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n        var seedBytes = options.random || (options.rng || rng)();\n        if (node == null) {\n            node = _nodeId = [ seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ];\n        }\n        if (clockseq == null) {\n            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n        }\n    }\n    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n        throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n    }\n    return buf ? buf : bytesToUuid(b);\n}",
	"node_modules/uuid/dist/esm-node/v35----stringToBytes": "function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n    for (var i = 0; i < str.length; i++) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}",
	"node_modules/uuid/dist/esm-node/v4----v4": "function v4(options, buf, offset) {\n    var i = buf && offset || 0;\n    if (typeof options == \"string\") {\n        buf = options === \"binary\" ? new Array(16) : null;\n        options = null;\n    }\n    options = options || {};\n    var rnds = options.random || (options.rng || rng)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n            buf[i + ii] = rnds[ii];\n        }\n    }\n    return buf || bytesToUuid(rnds);\n}",
	"node_modules/aws-sdk/node_modules/buffer/bin/test----runBrowserTests": "function runBrowserTests() {\n    var zuulYmlPath = path.join(__dirname, \"..\", \".zuul.yml\");\n    writeES5ZuulYml();\n    cp.spawn(\"npm\", [ \"run\", \"test-browser-es5\" ], {\n        stdio: \"inherit\"\n    }).on(\"close\", function(code) {\n        if (code !== 0) process.exit(code);\n        writeES6ZuulYml();\n        cp.spawn(\"npm\", [ \"run\", \"test-browser-es6\" ], {\n            stdio: \"inherit\"\n        }).on(\"close\", function(code) {\n            process.exit(code);\n        });\n    });\n    function writeES5ZuulYml() {\n        fs.writeFileSync(zuulYmlPath, fs.readFileSync(path.join(__dirname, \"zuul-es5.yml\")));\n    }\n    function writeES6ZuulYml() {\n        fs.writeFileSync(zuulYmlPath, fs.readFileSync(path.join(__dirname, \"zuul-es6.yml\")));\n    }\n}",
	"node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU----LRUCache": "function LRUCache(size) {\n    this.nodeMap = {};\n    this.size = 0;\n    if (typeof size !== \"number\" || size < 1) {\n        throw new Error(\"Cache size can only be positive number\");\n    }\n    this.sizeLimit = size;\n}",
	"node_modules/readable-stream/lib/internal/streams/buffer_list----BufferList": "function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n}",
	"node_modules/readable-stream/lib/internal/streams/destroy----destroy": "function destroy(err, cb) {\n    var _this = this;\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n    if (readableDestroyed || writableDestroyed) {\n        if (cb) {\n            cb(err);\n        } else if (err) {\n            if (!this._writableState) {\n                process.nextTick(emitErrorNT, this, err);\n            } else if (!this._writableState.errorEmitted) {\n                this._writableState.errorEmitted = true;\n                process.nextTick(emitErrorNT, this, err);\n            }\n        }\n        return this;\n    }\n    if (this._readableState) {\n        this._readableState.destroyed = true;\n    }\n    if (this._writableState) {\n        this._writableState.destroyed = true;\n    }\n    this._destroy(err || null, function(err) {\n        if (!cb && err) {\n            if (!_this._writableState) {\n                process.nextTick(emitErrorAndCloseNT, _this, err);\n            } else if (!_this._writableState.errorEmitted) {\n                _this._writableState.errorEmitted = true;\n                process.nextTick(emitErrorAndCloseNT, _this, err);\n            } else {\n                process.nextTick(emitCloseNT, _this);\n            }\n        } else if (cb) {\n            process.nextTick(emitCloseNT, _this);\n            cb(err);\n        } else {\n            process.nextTick(emitCloseNT, _this);\n        }\n    });\n    return this;\n}",
	"node_modules/readable-stream/lib/internal/streams/end-of-stream----eos": "function eos(stream, opts, callback) {\n    if (typeof opts === \"function\") return eos(stream, null, opts);\n    if (!opts) opts = {};\n    callback = once(callback || noop);\n    var readable = opts.readable || opts.readable !== false && stream.readable;\n    var writable = opts.writable || opts.writable !== false && stream.writable;\n    var onlegacyfinish = function onlegacyfinish() {\n        if (!stream.writable) onfinish();\n    };\n    var writableEnded = stream._writableState && stream._writableState.finished;\n    var onfinish = function onfinish() {\n        writable = false;\n        writableEnded = true;\n        if (!readable) callback.call(stream);\n    };\n    var readableEnded = stream._readableState && stream._readableState.endEmitted;\n    var onend = function onend() {\n        readable = false;\n        readableEnded = true;\n        if (!writable) callback.call(stream);\n    };\n    var onerror = function onerror(err) {\n        callback.call(stream, err);\n    };\n    var onclose = function onclose() {\n        var err;\n        if (readable && !readableEnded) {\n            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n        }\n        if (writable && !writableEnded) {\n            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n        }\n    };\n    var onrequest = function onrequest() {\n        stream.req.on(\"finish\", onfinish);\n    };\n    if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        stream.on(\"abort\", onclose);\n        if (stream.req) onrequest(); else stream.on(\"request\", onrequest);\n    } else if (writable && !stream._writableState) {\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n    }\n    stream.on(\"end\", onend);\n    stream.on(\"finish\", onfinish);\n    if (opts.error !== false) stream.on(\"error\", onerror);\n    stream.on(\"close\", onclose);\n    return function() {\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n    };\n}",
	"node_modules/readable-stream/lib/internal/streams/from----from": "function from(Readable, iterable, opts) {\n    var iterator;\n    if (iterable && typeof iterable.next === \"function\") {\n        iterator = iterable;\n    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator](); else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator](); else throw new ERR_INVALID_ARG_TYPE(\"iterable\", [ \"Iterable\" ], iterable);\n    var readable = new Readable(_objectSpread({\n        objectMode: true\n    }, opts));\n    var reading = false;\n    readable._read = function() {\n        if (!reading) {\n            reading = true;\n            next();\n        }\n    };\n    function next() {\n        return _next2.apply(this, arguments);\n    }\n    function _next2() {\n        _next2 = _asyncToGenerator(function*() {\n            try {\n                var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;\n                if (done) {\n                    readable.push(null);\n                } else if (readable.push(yield value)) {\n                    next();\n                } else {\n                    reading = false;\n                }\n            } catch (err) {\n                readable.destroy(err);\n            }\n        });\n        return _next2.apply(this, arguments);\n    }\n    return readable;\n}",
	"node_modules/readable-stream/lib/internal/streams/pipeline----destroyer": "function destroyer(stream, reading, writing, callback) {\n    callback = once(callback);\n    var closed = false;\n    stream.on(\"close\", function() {\n        closed = true;\n    });\n    if (eos === undefined) eos = require(\"./end-of-stream\");\n    eos(stream, {\n        readable: reading,\n        writable: writing\n    }, function(err) {\n        if (err) return callback(err);\n        closed = true;\n        callback();\n    });\n    var destroyed = false;\n    return function(err) {\n        if (closed) return;\n        if (destroyed) return;\n        destroyed = true;\n        if (isRequest(stream)) return stream.abort();\n        if (typeof stream.destroy === \"function\") return stream.destroy();\n        callback(err || new ERR_STREAM_DESTROYED(\"pipe\"));\n    };\n}",
	"node_modules/readable-stream/lib/internal/streams/pipeline----pipeline": "function pipeline() {\n    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n        streams[_key] = arguments[_key];\n    }\n    var callback = popCallback(streams);\n    if (Array.isArray(streams[0])) streams = streams[0];\n    if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n    }\n    var error;\n    var destroys = streams.map(function(stream, i) {\n        var reading = i < streams.length - 1;\n        var writing = i > 0;\n        return destroyer(stream, reading, writing, function(err) {\n            if (!error) error = err;\n            if (err) destroys.forEach(call);\n            if (reading) return;\n            destroys.forEach(call);\n            callback(error);\n        });\n    });\n    return streams.reduce(pipe);\n}"
}